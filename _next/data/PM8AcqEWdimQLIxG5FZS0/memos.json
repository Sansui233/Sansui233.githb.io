{"pageProps":{"client":"static","source":[{"id":"2023-11-24 05:39:50","content":"\n图片浏览器移动端的交互手势重写了啦啦啦，成功做到了可以看长图！并且流畅度全程靠 css 动画！帧率感人！我对 css 动画有一种执念，性能上的执念可能是，再烂的 css 匹配性能都比 JS 好。JS 的动画一般 chrome 上都还好，safari 真机测试时开始掉帧，整个交互说好听点就突出一个灵活，说难听点就是乱飞。\n\n没有用库，很臃肿，而且要实现我要的方向锁定的功能也还得再封装一次。自己写下来交互没那么全，但够用了，毕竟打包大小 1k 不到啊！高度内聚啊，没有多事件冗余啊。\n\n之后要写一下 zoom，还有 zoom 状态下的拖拽。不过其实不是很有必要，基本是网页端屏幕太大的时候会用到。\n\n参考了微博移动版的的图片组件事件绑定逻辑，对于 react 的事件绑定也看了use-gesture 库。我真的想了很久很久传统的 query 要怎么绑定，因为 react 是没有办法检测到 ref 值的变动的，也就是没有一个渲染完成的时机，传 ref 的 current custom hook 也压根不会触发刷新，毕竟 useEffect 也不会刷新。监听 onload listener 也许可以，但他妈有的组件是 lazyload 啊！比如这个问题：[What is the easiest or recommended method to add a copy code button?](https://github.com/orgs/mdx-js/discussions/1948)。在原生 dom 上很好实现的东西，在 react 上堪称世纪难题，最正确的做法还得是自己写插件……我操了，我真的操了。\n\n所以当我想“绑定完一个事件后再绑定其他事件”，想用 ref  时也是一个完完全全的“我操了”。后面看到 use-guesture 库的绑法，fine，真的很奇葩，很 react，但 work。完全不是时间序的东西，后面慢慢改改改，逐渐有了分组绑定的思路。个人觉得交互事件比较重要的一点是需要使用外部的 state ，只有输出刷新页面的数据才放在组件内部。不然改个内部状态就得重建一个函数就重新绑定……还玩不玩了？\n\n到现在我拆复杂的hook，都没法第一时间完全想出哪些状态放外面哪些状态放里面。把 search 拆出来时拆死我了。很多东西拆了其实也没有地方复用，一般也只有框架类的才有机会复用，只是为了看起来清楚一点。就比如拖拽手势，虽然理论上是可以到处用，但我也是真的想不到还要什么地方有加的必要。而且图片浏览的拖拽实际上也比一般的拖拽要复杂，只是拖拽倒是很好实现，但有方向锁定，自动回弹，复合点击判定、结束事件一类的，用库也要再封装一次，还要加新功能只暴露出需要使用的部分，更重要的是 css 的配合，又不想再引入个react-spring。如果是工作而不是个人博客，我倒是很情愿开发用库的。\n\n另外，看代码看到这一行时，笑了，好抽象，又带着一丝合理。\n\n\n\n\n\n\n\n","tags":[],"imgsmd":["![](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202311240640679.webp)"],"sourceFile":"002.md","csrIndex":[0,0],"code":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"图片浏览器移动端的交互手势重写了啦啦啦，成功做到了可以看长图！并且流畅度全程靠 css 动画！帧率感人！我对 css 动画有一种执念，性能上的执念可能是，再烂的 css 匹配性能都比 JS 好。JS 的动画一般 chrome 上都还好，safari 真机测试时开始掉帧，整个交互说好听点就突出一个灵活，说难听点就是乱飞。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"没有用库，很臃肿，而且要实现我要的方向锁定的功能也还得再封装一次。自己写下来交互没那么全，但够用了，毕竟打包大小 1k 不到啊！高度内聚啊，没有多事件冗余啊。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"之后要写一下 zoom，还有 zoom 状态下的拖拽。不过其实不是很有必要，基本是网页端屏幕太大的时候会用到。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"参考了微博移动版的的图片组件事件绑定逻辑，对于 react 的事件绑定也看了use-gesture 库。我真的想了很久很久传统的 query 要怎么绑定，因为 react 是没有办法检测到 ref 值的变动的，也就是没有一个渲染完成的时机，传 ref 的 current custom hook 也压根不会触发刷新，毕竟 useEffect 也不会刷新。监听 onload listener 也许可以，但他妈有的组件是 lazyload 啊！比如这个问题：\", _jsx(_components.a, {\n        href: \"https://github.com/orgs/mdx-js/discussions/1948\",\n        children: \"What is the easiest or recommended method to add a copy code button?\"\n      }), \"。在原生 dom 上很好实现的东西，在 react 上堪称世纪难题，最正确的做法还得是自己写插件……我操了，我真的操了。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"所以当我想“绑定完一个事件后再绑定其他事件”，想用 ref  时也是一个完完全全的“我操了”。后面看到 use-guesture 库的绑法，fine，真的很奇葩，很 react，但 work。完全不是时间序的东西，后面慢慢改改改，逐渐有了分组绑定的思路。个人觉得交互事件比较重要的一点是需要使用外部的 state ，只有输出刷新页面的数据才放在组件内部。不然改个内部状态就得重建一个函数就重新绑定……还玩不玩了？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"到现在我拆复杂的hook，都没法第一时间完全想出哪些状态放外面哪些状态放里面。把 search 拆出来时拆死我了。很多东西拆了其实也没有地方复用，一般也只有框架类的才有机会复用，只是为了看起来清楚一点。就比如拖拽手势，虽然理论上是可以到处用，但我也是真的想不到还要什么地方有加的必要。而且图片浏览的拖拽实际上也比一般的拖拽要复杂，只是拖拽倒是很好实现，但有方向锁定，自动回弹，复合点击判定、结束事件一类的，用库也要再封装一次，还要加新功能只暴露出需要使用的部分，更重要的是 css 的配合，又不想再引入个react-spring。如果是工作而不是个人博客，我倒是很情愿开发用库的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"另外，看代码看到这一行时，笑了，好抽象，又带着一丝合理。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":1246},{"id":"2023-11-21 00:57:14","content":"\n#工具 [BundlePhobia](https://bundlephobia.com/) 查看库的打包大小\n\n","tags":["工具"],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,1],"code":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_components.p, {\n    children: [_jsx(Tag, {\n      text: \"工具 \"\n    }), _jsx(_components.a, {\n      href: \"https://bundlephobia.com/\",\n      children: \"BundlePhobia\"\n    }), \" 查看库的打包大小\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","length":57},{"id":"2023-11-21 00:42:14","content":"\n大概是换了电脑，我很久没用过 logseq 的暗色模式，结果现在发现可真是……五彩斑斓的黑啊！我觉得是 dell 这屏幕的显色有问题。同一个色相调饱和度从绿色到紫色，数值调了 1 都看得出来……要准还是专业显示器或者苹果吧。不过果子不同产品线设备的色偏也是挺严重的（我觉得\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,2],"code":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"大概是换了电脑，我很久没用过 logseq 的暗色模式，结果现在发现可真是……五彩斑斓的黑啊！我觉得是 dell 这屏幕的显色有问题。同一个色相调饱和度从绿色到紫色，数值调了 1 都看得出来……要准还是专业显示器或者苹果吧。不过果子不同产品线设备的色偏也是挺严重的（我觉得\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":139},{"id":"2023-11-20 19:34:18","content":"\n想要变得可爱！\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,3],"code":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"想要变得可爱！\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":10},{"id":"2023-11-20 05:30:40","content":"\n我草草草，原来是mdx.js 的方法打包完有400k………当入 unist 这一圈时，打包体积就已经下不去了，解析速度也是。这东西其实真就不适合给网页前端用的……我看了下别人的，在想能不能分离，把 html 部分提前渲染，JSX 最后单独注入……但这样也还是不行，因为我是要 CSR，还要去兼顾搜索的数据……头痛，有没有小一点的库。还是SSR好…我改ssr试试看\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,4],"code":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"我草草草，原来是mdx.js 的方法打包完有400k………当入 unist 这一圈时，打包体积就已经下不去了，解析速度也是。这东西其实真就不适合给网页前端用的……我看了下别人的，在想能不能分离，把 html 部分提前渲染，JSX 最后单独注入……但这样也还是不行，因为我是要 CSR，还要去兼顾搜索的数据……头痛，有没有小一点的库。还是SSR好…我改ssr试试看\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":184},{"id":"2023-11-19 19:02:29","content":"\n[zustand](https://github.com/pmndrs/zustand) 好好用好好用…… 属于是理想的 use 外部 state 的方式了。\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,5],"code":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [_jsx(_components.a, {\n      href: \"https://github.com/pmndrs/zustand\",\n      children: \"zustand\"\n    }), \" 好好用好好用…… 属于是理想的 use 外部 state 的方式了。\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":82},{"id":"2023-11-19 06:09:27","content":"\n昨天是靠褪黑素睡觉的，今天真的睡不了一点。\n\n大概是我无法忍受我一天啥也不看的感觉，个人的事情做起来太容易没日没夜的了，我又要订计划了。最近变得不是很想嗑cp，大概是无法靠画同人调整作息了。但我想看一些书，永远有想干的事情。\n\n齐木楠雄的灾难，我看了一个多月了，每天都说看一集，还是看不了，看20分钟视频跟完成任务似的。\n\n再见博客。\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,6],"code":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"昨天是靠褪黑素睡觉的，今天真的睡不了一点。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"大概是我无法忍受我一天啥也不看的感觉，个人的事情做起来太容易没日没夜的了，我又要订计划了。最近变得不是很想嗑cp，大概是无法靠画同人调整作息了。但我想看一些书，永远有想干的事情。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"齐木楠雄的灾难，我看了一个多月了，每天都说看一集，还是看不了，看20分钟视频跟完成任务似的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"再见博客。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":170},{"id":"2023-11-19 04:29:12","content":"\n笑死，什么叫程序恰好能跑通，靠 bug 跑通吗？写程序从来没有靠运气跑通的说法。自己不能完全理解怎么运行的，项目运行起来的核心依赖了什么东西都不知道，兼容性的核心是怎么做的不知道，不想去了解，更新核心导致依赖不兼容，没出问题就叫恰好能跑通，出问题就叫烂代码，够牛的……有问题先debug而不是抱怨有bug竟然一个难得的品质。不能接受bug是常态，不想debug，从来靠命跑通第三方项目的人不适合维护程序，又没KPI又不挣钱，洗洗睡吧。\n\n我觉得人家（原作者）代码不管结构和结构已经都写得够清楚了。唯一缺的就是没有公开的测试。测试挺重要的，自己用不到这么多内容，考虑不了那么多的边界条件，又永远不知道来自互联网的内容会有什么bug……写10行代码写100行测试，还要起测试用服务器和mock数据，就问你，一个人写累不累……\n\n我最近也是越来越不喜欢更新依赖了，每一次更新都要去处理兼容性问题，不兼容就是版本回退。还有尽量少用在持续更新的小的第三方库，我宁愿照着再写一遍，有bug也好改。\n\n不过说来其实大部分项目开头后不重构都是屎山，如果开头的架构就非常好了，那就是工程经验和产品经验都很丰富的人。而且就算都是有经验的人，也会根据习惯认为另一种有经验的东西是屎山，没有必要……在我接触JSX，css-in-js 和函数式组件之初，我的天哪，这不是很容易写成屎山……但其实也就是不了解而已……虽然我还是很讨厌 JS 和 TS 的类型推断，但明显随着使用时间的增长觉得，函数式还是挺好用的。但是对象有对象的好处，如果没有 this 指针问题我还是会用 class。除了 css-in-js，这个我现在还是不喜欢，我还是更喜欢 CSSOM。tailwind 这类挺好的，除了要多记些东西（我从前可不是这么说的）\n\n我现在正处于到处是屎山的状态。并且我自己每一年的习惯都有点不一样，还可能看了某个库的架构感觉真好，想抄，导致改着改着后发现全变成了屎山……我也不是很想改了，现在心态就是，看得懂，任何时候可以捡起来维护，能用，就行。细节有空再说吧，又没有KPI。少更新依赖真的……\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,7],"code":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"笑死，什么叫程序恰好能跑通，靠 bug 跑通吗？写程序从来没有靠运气跑通的说法。自己不能完全理解怎么运行的，项目运行起来的核心依赖了什么东西都不知道，兼容性的核心是怎么做的不知道，不想去了解，更新核心导致依赖不兼容，没出问题就叫恰好能跑通，出问题就叫烂代码，够牛的……有问题先debug而不是抱怨有bug竟然一个难得的品质。不能接受bug是常态，不想debug，从来靠命跑通第三方项目的人不适合维护程序，又没KPI又不挣钱，洗洗睡吧。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我觉得人家（原作者）代码不管结构和结构已经都写得够清楚了。唯一缺的就是没有公开的测试。测试挺重要的，自己用不到这么多内容，考虑不了那么多的边界条件，又永远不知道来自互联网的内容会有什么bug……写10行代码写100行测试，还要起测试用服务器和mock数据，就问你，一个人写累不累……\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我最近也是越来越不喜欢更新依赖了，每一次更新都要去处理兼容性问题，不兼容就是版本回退。还有尽量少用在持续更新的小的第三方库，我宁愿照着再写一遍，有bug也好改。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不过说来其实大部分项目开头后不重构都是屎山，如果开头的架构就非常好了，那就是工程经验和产品经验都很丰富的人。而且就算都是有经验的人，也会根据习惯认为另一种有经验的东西是屎山，没有必要……在我接触JSX，css-in-js 和函数式组件之初，我的天哪，这不是很容易写成屎山……但其实也就是不了解而已……虽然我还是很讨厌 JS 和 TS 的类型推断，但明显随着使用时间的增长觉得，函数式还是挺好用的。但是对象有对象的好处，如果没有 this 指针问题我还是会用 class。除了 css-in-js，这个我现在还是不喜欢，我还是更喜欢 CSSOM。tailwind 这类挺好的，除了要多记些东西（我从前可不是这么说的）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我现在正处于到处是屎山的状态。并且我自己每一年的习惯都有点不一样，还可能看了某个库的架构感觉真好，想抄，导致改着改着后发现全变成了屎山……我也不是很想改了，现在心态就是，看得懂，任何时候可以捡起来维护，能用，就行。细节有空再说吧，又没有KPI。少更新依赖真的……\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":887},{"id":"2023-11-18 21:05:52","content":"\n温知识：shift + esc 可打开 chrome 的任务管理器，查看各个页面和插件的 cpu，内存，网络，pid 等\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,8],"code":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"温知识：shift + esc 可打开 chrome 的任务管理器，查看各个页面和插件的 cpu，内存，网络，pid 等\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":63},{"id":"2023-11-18 20:04:28","content":"\n想在博客养一只猫猫！但是要引入动画库我是不太愿意的……我觉得首屏已经有一点点慢了，代码体积还是有点大的，除了框架外，最占大头就是 mdx 放前端解析，直接让公用JS代码多了40k……但是我又不用！对！重点是我他妈的不用 mdx 写！我唯一用到 mdx 的地方还是解析 tag 绑定 react 事件，标签！好吧这也算了，前端解析数据注定是这个样子的。\n\n当然如果不考虑 seo 的话，可以优化的东西就多多了，seo导致所有内容都必须先加载出来。但我现在想想，除了信息密度大的页面，其他也无所谓的。嗯，就这样吧。\n\n还有，styled-component，说好用也好用，说不好用也不好用，一定要说的话我觉得还是不好用，可能只适合个人搞开发。不如 css 自带的变量管理、tailwind 功能class那一套，那一套是真的挺好用的。\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,9],"code":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"想在博客养一只猫猫！但是要引入动画库我是不太愿意的……我觉得首屏已经有一点点慢了，代码体积还是有点大的，除了框架外，最占大头就是 mdx 放前端解析，直接让公用JS代码多了40k……但是我又不用！对！重点是我他妈的不用 mdx 写！我唯一用到 mdx 的地方还是解析 tag 绑定 react 事件，标签！好吧这也算了，前端解析数据注定是这个样子的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当然如果不考虑 seo 的话，可以优化的东西就多多了，seo导致所有内容都必须先加载出来。但我现在想想，除了信息密度大的页面，其他也无所谓的。嗯，就这样吧。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"还有，styled-component，说好用也好用，说不好用也不好用，一定要说的话我觉得还是不好用，可能只适合个人搞开发。不如 css 自带的变量管理、tailwind 功能class那一套，那一套是真的挺好用的。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":368}],"info":{"pages":14,"memos":141,"tags":5,"imgs":10,"fileMap":[{"srcName":"002.md","lastModified":1700782334400,"dateRange":{"start":"2023-11-24 05:39","end":"2023-08-21 08:00"},"startAt":{"page":0,"index":0},"endAt":{"page":4,"index":6}},{"srcName":"001.md","lastModified":1699708351643,"dateRange":{"start":"2023-03-17 08:00","end":"2019-07-16 08:00"},"startAt":{"page":4,"index":7},"endAt":{"page":13,"index":9}},{"srcName":"000.md","lastModified":1700776741934,"dateRange":{"start":"1980-01-01 00:48","end":"1980-01-01 00:48"},"startAt":{"page":14,"index":0},"endAt":{"page":14,"index":0}}],"pageMap":[{"page":0,"startDate":1700775590000,"endDate":1700309068000},{"page":1,"startDate":1700146064000,"endDate":1699451679000},{"page":2,"startDate":1699378255000,"endDate":1698780786000},{"page":3,"startDate":1698733346000,"endDate":1694736000000},{"page":4,"startDate":1694649600000,"endDate":1677888000000},{"page":5,"startDate":1677786901000,"endDate":1675987200000},{"page":6,"startDate":1675900800000,"endDate":1670001564000},{"page":7,"startDate":1669846748000,"endDate":1661385600000},{"page":8,"startDate":1661212800000,"endDate":1654473600000},{"page":9,"startDate":1653696000000,"endDate":1652659200000},{"page":10,"startDate":1649980800000,"endDate":1638057600000},{"page":11,"startDate":1637452800000,"endDate":1632931199000},{"page":12,"startDate":1625673599000,"endDate":1615910399000},{"page":13,"startDate":1613750399000,"endDate":1563235200000},{"page":14,"startDate":315506908000,"endDate":-1}]},"memotags":[{"name":"工具","memoIds":["2023-11-21 00:57:14","2023-11-02 22:20:54","2023-08-30"]},{"name":"react","memoIds":["2023-11-08 01:30:55"]},{"name":"博客","memoIds":["2023-11-06 21:20:06","2023-10-29 01:13:43","1980-01-01 00:48:28"]},{"name":"漫画","memoIds":["2023-11-06 21:20:06"]},{"name":"mdx","memoIds":["2023-11-05 21:04:56"]}]},"__N_SSG":true}