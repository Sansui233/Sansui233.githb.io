{"pageProps":{"client":"static","source":[{"id":"2023-11-21 00:57:14","content":"\n#工具 [BundlePhobia](https://bundlephobia.com/) 查看库的打包大小\n\n","tags":["工具"],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,0],"code":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_components.p, {\n    children: [_jsx(Tag, {\n      text: \"工具 \"\n    }), _jsx(Tag, {\n      text: \"工具 \"\n    }), _jsx(_components.a, {\n      href: \"https://bundlephobia.com/\",\n      children: \"BundlePhobia\"\n    }), \" 查看库的打包大小\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","length":57},{"id":"2023-11-21 00:42:14","content":"\n大概是换了电脑，我很久没用过 logseq 的暗色模式，结果现在发现可真是……五彩斑斓的黑啊！我觉得是 dell 这屏幕的显色有问题。同一个色相调饱和度从绿色到紫色，数值调了 1 都看得出来……要准还是专业显示器或者苹果吧。不过果子不同产品线设备的色偏也是挺严重的（我觉得\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,1],"code":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"大概是换了电脑，我很久没用过 logseq 的暗色模式，结果现在发现可真是……五彩斑斓的黑啊！我觉得是 dell 这屏幕的显色有问题。同一个色相调饱和度从绿色到紫色，数值调了 1 都看得出来……要准还是专业显示器或者苹果吧。不过果子不同产品线设备的色偏也是挺严重的（我觉得\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":139},{"id":"2023-11-20 19:34:18","content":"\n想要变得可爱！\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,2],"code":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"想要变得可爱！\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":10},{"id":"2023-11-20 05:30:40","content":"\n我草草草，原来是mdx.js 的方法打包完有400k………当入 unist 这一圈时，打包体积就已经下不去了，解析速度也是。这东西其实真就不适合给网页前端用的……我看了下别人的，在想能不能分离，把 html 部分提前渲染，JSX 最后单独注入……但这样也还是不行，因为我是要 CSR，还要去兼顾搜索的数据……头痛，有没有小一点的库。还是SSR好…我改ssr试试看\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,3],"code":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"我草草草，原来是mdx.js 的方法打包完有400k………当入 unist 这一圈时，打包体积就已经下不去了，解析速度也是。这东西其实真就不适合给网页前端用的……我看了下别人的，在想能不能分离，把 html 部分提前渲染，JSX 最后单独注入……但这样也还是不行，因为我是要 CSR，还要去兼顾搜索的数据……头痛，有没有小一点的库。还是SSR好…我改ssr试试看\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":184},{"id":"2023-11-19 19:02:29","content":"\n[zustand](https://github.com/pmndrs/zustand) 好好用好好用…… 属于是理想的 use 外部 state 的方式了。\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,4],"code":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [_jsx(_components.a, {\n      href: \"https://github.com/pmndrs/zustand\",\n      children: \"zustand\"\n    }), \" 好好用好好用…… 属于是理想的 use 外部 state 的方式了。\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":82},{"id":"2023-11-19 06:09:27","content":"\n昨天是靠褪黑素睡觉的，今天真的睡不了一点。\n\n大概是我无法忍受我一天啥也不看的感觉，个人的事情做起来太容易没日没夜的了，我又要订计划了。最近变得不是很想嗑cp，大概是无法靠画同人调整作息了。但我想看一些书，永远有想干的事情。\n\n齐木楠雄的灾难，我看了一个多月了，每天都说看一集，还是看不了，看20分钟视频跟完成任务似的。\n\n再见博客。\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,5],"code":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"昨天是靠褪黑素睡觉的，今天真的睡不了一点。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"大概是我无法忍受我一天啥也不看的感觉，个人的事情做起来太容易没日没夜的了，我又要订计划了。最近变得不是很想嗑cp，大概是无法靠画同人调整作息了。但我想看一些书，永远有想干的事情。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"齐木楠雄的灾难，我看了一个多月了，每天都说看一集，还是看不了，看20分钟视频跟完成任务似的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"再见博客。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":170},{"id":"2023-11-19 04:29:12","content":"\n笑死，什么叫程序恰好能跑通，靠 bug 跑通吗？写程序从来没有靠运气跑通的说法。自己不能完全理解怎么运行的，项目运行起来的核心依赖了什么东西都不知道，兼容性的核心是怎么做的不知道，不想去了解，更新核心导致依赖不兼容，没出问题就叫恰好能跑通，出问题就叫烂代码，够牛的……有问题先debug而不是抱怨有bug竟然一个难得的品质。不能接受bug是常态，不想debug，从来靠命跑通第三方项目的人不适合维护程序，又没KPI又不挣钱，洗洗睡吧。\n\n我觉得人家（原作者）代码不管结构和结构已经都写得够清楚了。唯一缺的就是没有公开的测试。测试挺重要的，自己用不到这么多内容，考虑不了那么多的边界条件，又永远不知道来自互联网的内容会有什么bug……写10行代码写100行测试，还要起测试用服务器和mock数据，就问你，一个人写累不累……\n\n我最近也是越来越不喜欢更新依赖了，每一次更新都要去处理兼容性问题，不兼容就是版本回退。还有尽量少用在持续更新的小的第三方库，我宁愿照着再写一遍，有bug也好改。\n\n不过说来其实大部分项目开头后不重构都是屎山，如果开头的架构就非常好了，那就是工程经验和产品经验都很丰富的人。而且就算都是有经验的人，也会根据习惯认为另一种有经验的东西是屎山，没有必要……在我接触JSX，css-in-js 和函数式组件之初，我的天哪，这不是很容易写成屎山……但其实也就是不了解而已……虽然我还是很讨厌 JS 和 TS 的类型推断，但明显随着使用时间的增长觉得，函数式还是挺好用的。但是对象有对象的好处，如果没有 this 指针问题我还是会用 class。除了 css-in-js，这个我现在还是不喜欢，我还是更喜欢 CSSOM。tailwind 这类挺好的，除了要多记些东西（我从前可不是这么说的）\n\n我现在正处于到处是屎山的状态。并且我自己每一年的习惯都有点不一样，还可能看了某个库的架构感觉真好，想抄，导致改着改着后发现全变成了屎山……我也不是很想改了，现在心态就是，看得懂，任何时候可以捡起来维护，能用，就行。细节有空再说吧，又没有KPI。少更新依赖真的……\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,6],"code":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"笑死，什么叫程序恰好能跑通，靠 bug 跑通吗？写程序从来没有靠运气跑通的说法。自己不能完全理解怎么运行的，项目运行起来的核心依赖了什么东西都不知道，兼容性的核心是怎么做的不知道，不想去了解，更新核心导致依赖不兼容，没出问题就叫恰好能跑通，出问题就叫烂代码，够牛的……有问题先debug而不是抱怨有bug竟然一个难得的品质。不能接受bug是常态，不想debug，从来靠命跑通第三方项目的人不适合维护程序，又没KPI又不挣钱，洗洗睡吧。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我觉得人家（原作者）代码不管结构和结构已经都写得够清楚了。唯一缺的就是没有公开的测试。测试挺重要的，自己用不到这么多内容，考虑不了那么多的边界条件，又永远不知道来自互联网的内容会有什么bug……写10行代码写100行测试，还要起测试用服务器和mock数据，就问你，一个人写累不累……\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我最近也是越来越不喜欢更新依赖了，每一次更新都要去处理兼容性问题，不兼容就是版本回退。还有尽量少用在持续更新的小的第三方库，我宁愿照着再写一遍，有bug也好改。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不过说来其实大部分项目开头后不重构都是屎山，如果开头的架构就非常好了，那就是工程经验和产品经验都很丰富的人。而且就算都是有经验的人，也会根据习惯认为另一种有经验的东西是屎山，没有必要……在我接触JSX，css-in-js 和函数式组件之初，我的天哪，这不是很容易写成屎山……但其实也就是不了解而已……虽然我还是很讨厌 JS 和 TS 的类型推断，但明显随着使用时间的增长觉得，函数式还是挺好用的。但是对象有对象的好处，如果没有 this 指针问题我还是会用 class。除了 css-in-js，这个我现在还是不喜欢，我还是更喜欢 CSSOM。tailwind 这类挺好的，除了要多记些东西（我从前可不是这么说的）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我现在正处于到处是屎山的状态。并且我自己每一年的习惯都有点不一样，还可能看了某个库的架构感觉真好，想抄，导致改着改着后发现全变成了屎山……我也不是很想改了，现在心态就是，看得懂，任何时候可以捡起来维护，能用，就行。细节有空再说吧，又没有KPI。少更新依赖真的……\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":887},{"id":"2023-11-18 21:05:52","content":"\n温知识：shift + esc 可打开 chrome 的任务管理器，查看各个页面和插件的 cpu，内存，网络，pid 等\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,7],"code":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"温知识：shift + esc 可打开 chrome 的任务管理器，查看各个页面和插件的 cpu，内存，网络，pid 等\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":63},{"id":"2023-11-18 20:04:28","content":"\n想在博客养一只猫猫！但是要引入动画库我是不太愿意的……我觉得首屏已经有一点点慢了，代码体积还是有点大的，除了框架外，最占大头就是 mdx 放前端解析，直接让公用JS代码多了40k……但是我又不用！对！重点是我他妈的不用 mdx 写！我唯一用到 mdx 的地方还是解析 tag 绑定 react 事件，标签！好吧这也算了，前端解析数据注定是这个样子的。\n\n当然如果不考虑 seo 的话，可以优化的东西就多多了，seo导致所有内容都必须先加载出来。但我现在想想，除了信息密度大的页面，其他也无所谓的。嗯，就这样吧。\n\n还有，styled-component，说好用也好用，说不好用也不好用，一定要说的话我觉得还是不好用，可能只适合个人搞开发。不如 css 自带的变量管理、tailwind 功能class那一套，那一套是真的挺好用的。\n\n","tags":[],"imgsmd":[],"sourceFile":"002.md","csrIndex":[0,8],"code":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"想在博客养一只猫猫！但是要引入动画库我是不太愿意的……我觉得首屏已经有一点点慢了，代码体积还是有点大的，除了框架外，最占大头就是 mdx 放前端解析，直接让公用JS代码多了40k……但是我又不用！对！重点是我他妈的不用 mdx 写！我唯一用到 mdx 的地方还是解析 tag 绑定 react 事件，标签！好吧这也算了，前端解析数据注定是这个样子的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当然如果不考虑 seo 的话，可以优化的东西就多多了，seo导致所有内容都必须先加载出来。但我现在想想，除了信息密度大的页面，其他也无所谓的。嗯，就这样吧。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"还有，styled-component，说好用也好用，说不好用也不好用，一定要说的话我觉得还是不好用，可能只适合个人搞开发。不如 css 自带的变量管理、tailwind 功能class那一套，那一套是真的挺好用的。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":368},{"id":"2023-11-16 22:47:44","content":"\n微软，你干什么？\n\n\n","tags":[],"imgsmd":["![](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202311162247378.webp)"],"sourceFile":"002.md","csrIndex":[0,9],"code":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"微软，你干什么？\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","length":12}],"info":{"pages":13,"memos":140,"tags":5,"imgs":8,"fileMap":[{"srcName":"002.md","lastModified":1700499489488,"dateRange":{"start":"2023-11-21 00:57","end":"2023-08-21 08:00"},"startAt":{"page":0,"index":0},"endAt":{"page":4,"index":5}},{"srcName":"001.md","lastModified":1699708351643,"dateRange":{"start":"2023-03-17 08:00","end":"2019-07-16 08:00"},"startAt":{"page":4,"index":6},"endAt":{"page":13,"index":8}},{"srcName":"000.md","lastModified":1699185680001,"dateRange":{"start":"1980-01-01 00:48","end":"1980-01-01 00:48"},"startAt":{"page":13,"index":9},"endAt":{"page":13,"index":9}}],"pageMap":[{"page":0,"startDate":1700499434000,"endDate":1700146064000},{"page":1,"startDate":1700062436000,"endDate":1699378255000},{"page":2,"startDate":1699276806000,"endDate":1698733346000},{"page":3,"startDate":1698513223000,"endDate":1694649600000},{"page":4,"startDate":1694131200000,"endDate":1677786901000},{"page":5,"startDate":1677715200000,"endDate":1675900800000},{"page":6,"startDate":1675728000000,"endDate":1669846748000},{"page":7,"startDate":1669248000000,"endDate":1661212800000},{"page":8,"startDate":1658793600000,"endDate":1653696000000},{"page":9,"startDate":1653523200000,"endDate":1649980800000},{"page":10,"startDate":1644883200000,"endDate":1637452800000},{"page":11,"startDate":1637366400000,"endDate":1625673599000},{"page":12,"startDate":1624204799000,"endDate":1613750399000},{"page":13,"startDate":1607097599000,"endDate":-1}]},"memotags":[{"name":"工具","memoIds":["2023-11-21 00:57:14","2023-11-02 22:20:54","2023-08-30"]},{"name":"react","memoIds":["2023-11-08 01:30:55"]},{"name":"博客","memoIds":["2023-11-06 21:20:06","2023-10-29 01:13:43","1980-01-01 00:48:28"]},{"name":"漫画","memoIds":["2023-11-06 21:20:06"]},{"name":"mdx","memoIds":["2023-11-05 21:04:56"]}]},"__N_SSG":true}