{"pageProps":{"memoposts":[{"title":"2022-05-28","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\",\n      a: \"a\",\n      strong: \"strong\",\n      blockquote: \"blockquote\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"今日读文章笔记\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.a, {\n              href: \"https://jesseduffield.com/Testing-Private-Methods/\",\n              children: \"是否测试私有方法？\"\n            }), \" 看完之后我的观点是不测试私有方法。如果需要测试私有方法，那说明着类设计得太复杂，违反了单一责任原则。\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.a, {\n              href: \"https://q.shanyue.tech/deploy/\",\n              children: \"前端部署 15 章\"\n            }), \"，适合没有实践过的新手看，都是教怎么搬砖，换言之是查文档的经验积累，对我个人来说没什么收获。好的地方是还有很多的面试题可以看。毕竟这两年闲得我差不多把有需求也有条件的折腾的东西全折腾了个遍，这之后才能体会到折腾真的不重要，工程的终点是个设计问题，而设计是个哲学问题 ……哦，对于找工作还是重要的，只有想法没有动手能力也不行。\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"还有人吐槽 \", _jsx(_components.a, {\n              href: \"https://neverworkintheory.org/2022/03/18/python-3-types-in-the-wild.html\",\n              children: \"python3 的类型标注\"\n            }), \" 。没有类型标注我不理解，这么喜欢\", _jsx(_components.strong, {\n              children: \"面向记忆/面向文档编程\"\n            }), \"吗？\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.a, {\n              href: \"https://iconmap.io/blog\",\n              children: \"iconmap.io 分析 favicon 的统计数据\"\n            }), \"，还蛮有趣的。\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.a, {\n              href: \"https://jamstack.org/\",\n              children: \"Jamstack\"\n            }), \" 可以了解到一些当下的流行 Web 技术栈，比如 Headless CMS。我觉得后面那些本质上还是 CURD 那一套，只是换成了前端能直接用的 API，抢一下后端 CURD 搬砖人员的工作可还行。不过服务解耦带来了无代码可能性非常棒，但也真的不一定有好的应用场景。并且动态内容的SEO 还是问题很大，必须 SSR 渲染。\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.a, {\n              href: \"https://refactoringguru.cn/design-patterns/catalog\",\n              children: \"关于设计模式的介绍大全\"\n            }), \"，这个算后端面试必备吧，前端我没见几个人问过，本质也算是哲学♂\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"ORM：GraphQL 是一个 API 标准，不用 SQL 进行 CURD。为什么好像近几年的前端对 CURD 这么执着啊，我对这就是库能用，高效，好用，就行了。不过出标准倒也有出标准的好处，服务能分层就是依靠着各种标准联系。\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"低代码 电商平台： \", _jsx(_components.a, {\n              href: \"https://selldone.com/\",\n              children: \"https://selldone.com/\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.a, {\n              href: \"https://www.bramadams.dev/projects/invest-in-lights#light-mode-and-dark-mode-on-websites\",\n              children: \"为什么需要黑暗模式\"\n            }), \"？觉得不需要设计黑暗模式的人，大概是工作环境都太稳定了。\"]\n          }), \"\\n\", _jsxs(_components.blockquote, {\n            children: [\"\\n\", _jsx(_components.p, {\n              children: \"I generally clowned on developers putting so much into building dark modes instead of critical features that prevent their apps from working, until I was working on this site on a red eye flight. The whites were blinding and the websites/apps that had dark mode were comforting.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.a, {\n              href: \"https://www.matuzo.at/blog/building-the-most-inaccessible-site-possible-with-a-perfect-lighthouse-score/\",\n              children: \"完美的可访问性网站\"\n            }), \" 笑死了，行为艺术\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"突然觉得，没太多意思，大家只是在不断追求更好更方便的架构，以适应商业的发展。做的事情还都是这点东西。好的工程师太难了，需要极强的抽象思维，某种程度上可以说是需要哲学天赋。所以到后期不转管理或不做研究几乎不可能……\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"2022-05-26","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      a: \"a\",\n      hr: \"hr\",\n      img: \"img\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"推荐一个网页版\", _jsx(_components.a, {\n          href: \"https://imagestool.com/zh_CN/\",\n          children: \"图片处理 app\"\n        }), \"，目前最全的没有之一。\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n        children: \"前天看完了博人转主线，导致昨天开始没有火影主线看了，于是莫名 emo。emo 了就摸了两张鱼，反而比平时睡得早一点。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/2022-05-26-2.jpg\",\n          alt: \"2022-05-26-2\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/2022-05-26-1.jpg\",\n          alt: \"2022-05-26-1\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"2022-05-25","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"今天实现动画 Mount when scroll into view port，用了一个特别简单有意思的方式做了首屏列表 trail 渲染，通俗说就是元素依次显示出来，每一条有点时间差。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"挂载动画还是用的 css animation，主要是 css 做挂载动画还是很好写的，效率也比 JS 高。重点是在如何给元素的挂载加上时间差。我在这里没有用任何 setTimeout 一类的控制时间的方式。\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"做 scroll into viewport 要用到 \", _jsx(_components.a, {\n          href: \"https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API\",\n          children: \"Intersection Observer API\"\n        }), \"，但如果仅仅是判断 scroll into view 再进行挂载，尽管后续元素的是按动画依次挂载上来的，但首屏的各个条目仍然是一起出现的，没有任何时间差。于是我将 List Item 的占位高度设置为 100vh, 第一个就能挤掉所有后续元素，挂载后回归正常高度，第二个元素进入 viewport；第二个元素高度仍为 100vh，同样挤掉后续的所有元素，挂载后回归正常高度。\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"这样挂载的时间差其实是取决于 JS 修改 height 的时长和浏览器重绘所花费的时间，并非人为可控的。如果不做任何处理，时间差将是非常短的。不过自己实测后感觉已经够用了。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"最烦的其实是 SEO，如果真的 mount on scroll 算是懒加载了，会直接没首屏……所以要兼顾首屏数据只能采用 改 display 或者 visibility 的动画方式，而不是 mount on scroll.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"2022-05-24","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"今天看 react-spring 的标注，发现几乎读不懂。于是去学习了更多有关 typescript 标注的知识，主要是 extends 和 infer。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"看了只有一个感觉：有必要引入如此复杂的编程模式吗！我看标注一般都是因为懒得看文档，认为最容易让人从根本上理解设计原理的文档就是代码本身。但第一次遇到读起来如此困难的标注。实在不知道把类型搞成变量做判断这一套的意义在哪…… 确实可以简化一些代码，但也真的引入了复杂亿点的编程模式。可能还是写库会用到，平时倒没有这个需求。而且由于 function 也是 object 的关系，extends 接箭头函数太难断句了，真的难受，断句断到我哭。算了箭头函数本来就是一个复杂场景下视觉上极难断句的语法……\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"2022-05-22","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      a: \"a\",\n      hr: \"hr\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"2022-05-26 更新：我焯，我服了，兄弟们，是不是微信办公人群都用是不会写长文的啊！又是这位……如果你无意间也看到了这里，希望你能去看一下\", _jsx(_components.a, {\n          href: \"https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md\",\n          children: \"提问的智慧\"\n        }), \"，可以说你算是条条踩雷。我也不是什么厉害的人物，所以不要叫我大佬，这并不能取悦到谁。我回答问题仅仅是出于分享的心情，愉快的问答是聚焦于技术问题本身的平等交流。\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n        children: \"我讨厌上来就给我说：“我不是这种情况，所以你说的情况不存在”的人，把自己的认知当做全部。这已经不是有没有共情能力的问题，是对于世间的多样性已经丧失掉了求知欲与敬畏之心。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"我从前也是这样的人，当时我觉得写个 json 结构转换代码真的特别简单，不认为这个学校里会有人写一整天都不会，一起做大作业的室友不会写我还硬要她写。最后她没办法，求另一个室友用一个小时帮她搞定了。现在我都很后悔这个事，意识到人和人之间的天赋点可能真的差很远时，是在有些理解“艺术”而非“画画技术”之后。在没有人文素养的时候我是真的可怕，可能是那种 pua 人，尽管不是故意 pua，仅仅是觉得“我自己做真的觉得超简单的，你为什么不行”。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"当提出意见时：\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"（可以接受）我知道可能有很多情况，但我觉得是这样比较好，原因是（一系列客观事实）\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"（不能接受）我觉得是这样比较好，因为我的经验中没有别的情况\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"后者如果天天接触，我又无法对他直言，那么之后那个人会触发我 PTSD 的，亲测有效。\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n        children: \"服了，头一回遇到 issue be like:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Q：我出现了 A 问题\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"我: 我明白了，请告知你的运行环境信息，因为我这里无法复现，\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Q：可我出现了 A 问题啊\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"我：你能先把你的环境信息告诉我吗？否则我无法复现\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Q：环境是 xxx，希望快点修谢谢\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"我：已测试，并非此项目的问题，是其它地方的问题，你可以用以下步骤检查哪里出问题……\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Q：可我就是出了A问题呀\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"我：你能先把每个步骤的检查结果告诉我吗？\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"…………(*$^#(^(^@%_这他喵的，总是重复自己的问题不按回复查原因有意思吗？还是说我说的不够明确他不知道自己需要干什么？而且我在开头就很想说，这种问题一看就是自己魔改过其他地方导致的，我还自己去复现环境只是个以防万一，要不是出于礼貌我立刻当街踢皮球。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"没事，很幸运，这么久了这才头一回当客服。\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"2022-05-21","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"博客重构记录：由于吐槽写得太长加了 memo 分页逻辑，使用了首屏静态页面分页前端 query CSR 的方式，以减少 FCP 时间。但这样的问题是即便是带 query 的链接，首屏也是会要先闪一下，再替换掉内容，毕竟是静态页面。 这有点难解决。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"有一个非常 tricky 的办法，在样式做上欺骗，把字号换成和背景一个色（或者加遮罩），在 CSR 逻辑处理完后再显示。但这样的弊端是 FCP 时间会相对比较长，特别是网不好的情况下。本来分页就是用来减少 FCP 时间的。这么做虽然流量减少了，但又很难说到底能减少多少 FCP 时间。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"另外 Link 由于路由处理有延迟，导致换页时体感有延迟，中途没反馈如果网不好可能会以为是页面有 Bug。果然 CSR 异步请求还是得加数据切换时的交互提示……啊烦，设计好难。后续还想抠动画，但就是体力活，纯抠……\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"2022-05-20","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      ol: \"ol\",\n      li: \"li\",\n      strong: \"strong\",\n      blockquote: \"blockquote\",\n      h3: \"h3\",\n      a: \"a\",\n      ul: \"ul\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"关于 Next.js 的容易造成的误区和目前吸引我的点。先说误区。\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"SSG（静态站点生成）这名字取得有误导性，并不是真正完全的静态站点。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"一般对于 \", _jsx(_components.strong, {\n          children: \"静态站点\"\n        }), \" 是指 build 预渲染后的纯前端页面，直接出现最终结果，不需要任何服务器，给一个 index.html 点开就能用。但 SSG 实际做的只有 “可以获取预渲染所需数据”，但有的渲染 Feature 仍然需要用到服务器处理，其 build 结果并不是静态站点，也没有做任何预渲染，export 才是。因此即便没有用到任何的 SSR，也会有 feature 在 export 中不支持。纯 React 客户端的 build 阶段相当于 Next.js 的 export 阶段。\"]\n      }), \"\\n\", _jsxs(_components.ol, {\n        start: \"2\",\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"SSR（服务端渲染）字面上更容易造成误解，和传统的服务端渲染有区别\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"首先要理解 CSR 的对立面是 Pre-render，而不是 SSR。SSR 只是一种 pre-render 的方法，SSG 也是一种 pre-render 的方法。\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"其次要理解，\", _jsx(_components.strong, {\n          children: \"SSG 也运行在服务端\"\n        }), \"。更准确的说法是 SSG 是“服务端 build 时预渲染”，SSR 是“服务端运行时预渲染”。但是 Server-side rendering 字面上把 SSG 也概括进去了。\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Next.js 对 SSG 和 SSR 的定义。\"\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h3, {\n          children: _jsx(_components.a, {\n            href: \"https://nextjs.org/docs/basic-features/pages#two-forms-of-pre-rendering\",\n            children: \"Two forms of Pre-rendering\"\n          })\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.a, {\n                href: \"https://nextjs.org/docs/basic-features/pages#static-generation-recommended\",\n                children: _jsx(_components.strong, {\n                  children: \"Static Generation (Recommended)\"\n                })\n              }), \": The HTML is generated at \", _jsx(_components.strong, {\n                children: \"build time\"\n              }), \" and will be reused on each request.\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.a, {\n              href: \"https://nextjs.org/docs/basic-features/pages#server-side-rendering\",\n              children: _jsx(_components.strong, {\n                children: \"Server-side Rendering\"\n              })\n            }), \": The HTML is generated on \", _jsx(_components.strong, {\n              children: \"each request\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"而传统说的服务端渲染，其实是同时包含了 Next.js 的 SSG 渲染与 SSR 渲染。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"那么问题是，按照 Next.js 的 SSR 定义，SSR 是不是无法 export 成静态页面？\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"这其实要看有没有对 http request 进行处理，或者有别的要和 server 打交道的代码。 即便你用 SSR，但每次都是在做一些和 http request 无关的事情，那这不会对 export 造成影响。这也是为什么 \", _jsx(_components.code, {\n          children: \"getInitialProps\"\n        }), \" 支持 export 但又支持得不太完全。\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"比如 styled-components 可以预渲染时注入 style，但这个有两种写法，第一种是 styled-components \", _jsx(_components.a, {\n          href: \"https://styled-components.com/docs/advanced#server-side-rendering\",\n          children: \"官方文档\"\n        }), \"，用的标准 SSR，无法 export。第二种写法在 \", _jsx(_components.a, {\n          href: \"https://github.com/vercel/next.js/tree/canary/examples/with-styled-components\",\n          children: \"Next.js 仓库\"\n        }), \"，用的了服务端做预渲染，但又不像一般的 SSR，可以 export，只不过 req 和 res 为空，概念上可以说就是个 SSG。\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"再说吸引我的点\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"SSR 和 CSR 同构，可以看成 CSR 基础上增强首屏 SEO 能力，也可以看成传统 SSR 基础上加入 CSR 的优点（节省服务器资源bla），这样小型页面生成不用分开做数据 mock，直接一把唆。\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"CSR 和 build 时预渲染都算是纯前端，能完全生成静态页面的。而 Next.js 依靠 Node 拥有一定的后端处理能力（虽然我用不上）\"\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"2022-05-18","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.p, {\n      children: \"今晚先把 Issue 修了，然后把分类页写完吧，现在和我想象的还是有差别。由于没有提前做界面设计，写起来十分痛苦……做设计真的太费时间了，下次再也不要推着写了。\"\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"2022-05-17","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      hr: \"hr\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"今天早上起床，醒之前是真实的恶梦。梦到我在家里睡觉，一觉醒来，父母都去世了，尸体就躲在我的身旁，就在床上，在睡梦中。\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n        children: \"また自殺したいと思った\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"役に立たない。ただのクソ製造機。生きてる意味もない\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"母は偉いです、それに対して、僕はただのクソなんです。いや、母だけではなく、人一倍ゴミクズです\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"ただの普段の生活もできないし\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"连续一周每天睡 4 小时左右了。主要是因为我睡得晚，室友起得早。基本我睡 4 小时左右就会听到他们开始活动了。我真的不明白我为什么要睡那么晚，真的，心情会很差，但依然睡不着。之前有天晚上强制自己 2 点睡觉强制得我要疯了，最后是看了三集柯南才能稳定睡觉。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"从来没有完成自己的计划这么困难过。虽然从读研起就越来越困难了。但没有什么时候比现在更难。长期无法做自己想做的事情，所做的一切对我和对周围的人没有任何价值可言，只是个单纯的累赘。有很多人羡慕我因为有兴趣而有很强的自驱力，但其实为此我已经牺牲掉了赖以生存的所有，至少我目前是这么觉得的。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"我无法控制我写代码的时间，吃饭的时间，睡觉的时间，也无法控制我看两行论文就会分神。这些似乎都是随缘。这意味，我无法控制我的工作，无法精确计划，无法和他人长期有规律地合作。很可能今天专注了 24 小时，明天精神不好一整天都无法专注。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"我只能控制我画画的时间、打游戏的时间、看剧的时间。这些休闲的时间就可以控制。我不明白。我并无焦虑，我从不为正在做的事情焦虑，因为焦虑会导致完全无法投入。现在看来更像是一种 ADHD，但也无心诊断，就医这些日常都太麻烦了。我总是觉得日常生活太麻烦，以至于无法好好过每一天的日常，注定不会活太久。\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"2022-05-16","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.p, {\n      children: \"博客已重写，遇到不少问题，有机会写点文章。\"\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"2022-04-15 ","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"关于为什么会出现前端框架的思考。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"最近摸鱼看了下 Next.js，确实是很方便，而且这其实像是，Manage your js pages in an html way。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"然后我就在想，如果我的目的是生成静态页面，用框架只是为了组件化，那为什么直接 HTML + JS 不行呢？除开发上的亿点点不便（因为这是可以通过工具解决的），出现了一整个 JS 框架到底是为什么？我就不能用 HTML 和 WebComponent 实现视图组件化复用，JS 还是仅仅实现交互逻辑吗？\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"而且如果只是想组件化，按理说，出个 JSX 和 v-html 弥补 html 不足就 OK 了，JS 做一下语法解析就成，为什么最后直接搞出了一整套虚拟 DOM？有好处，但也没好像那么必要。\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"然后看到一篇文章：\", _jsx(_components.a, {\n          href: \"https://juejin.cn/post/6844903608215945229\",\n          children: \"精读《现代 js 框架存在的根本原因》\"\n        }), \"。里面提到的关键是数据状态与视图绑定的问题。\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"最后又对比着想了客户端的工具链，我个人觉得，根本问题出在，制定 HTML 的 W3C 和 制定 JS 标准的 ECMA 属于两个完全不同的组织。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"前端开发需要处理视图+数据逻辑，需要用到两种语言。不能用一种语言吗？可以，但一般而言非常难用。不同的语言确实有不同擅长的方向，视图还是声明式的语言清晰好用（如HTML、XML），而写逻辑是命令式的长处（如C++，Go）。 对于客户端而言，控制视图的工具和控制逻辑的工具是一起更新的，但对于 Web 则并非如此。ECMA 填 JS 坑填得人要学不动，w3c 在更新 Web API，HTML 语法还是那样的万年不变。即便能一起更新，也很难在几年内覆盖大部分用户， 不像客户端一样是独家定制，还经常强制更新，不更用不了。浏览器总是万年不换，做浏览器的厂商也是五花八门。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"在视图层与逻辑层过于割裂的情况下，为了满足越来越复杂的开发需要，干脆直接摒弃了用 html 控制视图的思路，出现了 jsx 这样的怪东西（不是贬义），用自由度极高的 JS 干完所有活，底层渲染优化一类的全都由框架实现，方便又好使。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"如今的页面大多都是 JS 写的了。Next.js 的路由让人感觉更像是 JS 直接无缝代替了 HTML。还是和从前一样简单而易于理解与维护的站点架构，只是因为 HTML 太拉了，所以用 JS 写了。\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"2022-02-15","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      h3: \"h3\",\n      pre: \"pre\",\n      code: \"code\",\n      hr: \"hr\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"由于兴趣原因想扒一个 Vue 写的前端。虽然 Webpack 经常把变量打包得妈都不认，但对于字符串和 property 是不会替换的。大致步骤如下\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"1. Network 选项卡查看数据文本\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"按照现代前端写 WebApp 的惯性，数据量很大的情况都是 AJAX，请求一个数据文件由浏览器解析。这个数据文件在 Network 中找找很容易获得，是个 JSON 文件。文件 A 字段经过加密，其余都是明文存储。但是 A 字段是最关键的，接下来就是从源代码中找解密方法。\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"2.  搜索 API URL  + 元素审查\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"既然是 AJAX 必然是明文字符串请求的 API。那就先搜寻了一下 API URL 附近代码，发现经过 webpack 打包后，有一个 g 变量原型上绑定了很多方法。其中一个 replaceImgURL 引起了我的注意。因为之前在元素审查时发现，被加密的文本有一部分被替换为了图片。这个处理我不理解……你都加密过了还要换图片？换就换吧，还就换一个字？防得了谁呢……替换的 Img 的 label 刚好对得上。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"然后继续搜寻使用了 replaceImgURL 的代码。这下好了，方法就在原型上，直接叫decryption……\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"3. 查看 decryption 的代码\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"如果加密解密是自己手写的，那复制粘贴就完事。不过出现了报错，还是引入了 module。引入的 module 名自然是被打包成妈都不认的，但是这用法一看就是第三方库，因为让前端自个儿写加解密才不会设计得这么详细……\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"e.enc.Utf8.parse('asdfac')\\ne.DES.decrypt({ciphertext: e.enc.Hex.parse(a)})\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"一眼看到大写的 DES 还有 CRC 一类的，这不就巧了嘛。查了一下，这是 crypto-js 的库。把这几行代码搬到 TS 中写了解密 function，完美。\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n        children: \"所以过程没有很复杂，完全用不到数学，甚至是直接调现有库。前端安全的话，嗯，还是觉得纯客户端解密没有绝对的安全。毕竟都不用和服务器通信，只要有时间总是可以还原出来。但也没有必要追求绝对安全，只需要提高解密的时间成本就可以了，人总是讲收益的。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"也是基于上述想法，我觉得本地差分隐私这个课题是就是扯淡。纯概率论，密码学都不用的，都先不说应用场景，当时看着看着就觉得谁真这么做那我可以去逆向了……\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n        children: \"过年入了个 switch，买了个舞力全开。天生四肢协调小脑发达的我感觉非常不错，就是没什么场地可以动。路易吉鬼屋也不错的，就是太长了当时得在 3 天内刷完有点累。Mario Party 里面大富翁玩法还是 yyds，抢拍照的小游戏真的笑死了。然后入了几个之前 ios 上看过但没有玩的打折游戏，limbo, inside，勇敢的心，光之子。种田流星露谷也买了，可惜之前的存档不能导进去，没有 mod 少了一大乐趣。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"再到之前玩 MC1.18 的基岩版，改了个很久没维护的 Shader 的光照。之前 MC 是亮度 7 以下刷怪，所以 shader 写的是平方衰减。但现在是亮度 0 刷怪了，还是改回了线性。老实说差别也不是那么的大……物理强度和视觉强度还有一个 Log 的差异，不过在亮度 7 以下的地方要好一些了，之前一到亮度 7 以下是乌漆抹黑。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"然后最近有人留言问要不要玩 Java1.18 服，我加了一下，mac 好卡，卒。\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}],"pagelimit":5},"__N_SSG":true}