<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Sansui's blog</title>
        <link>https://sansui233.com</link>
        <description>记录学习和生活的个人博客</description>
        <lastBuildDate>Mon, 20 Feb 2023 09:52:07 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh-CN</language>
        <copyright>All rights reserved 2022, Sansui</copyright>
        <atom:link href="https://sansui233.com/rss" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[Stable Diffusion AI 绘画的实用性经验与总结]]></title>
            <link>https://sansui233.com/posts/2023-02-20-stable-diffusion-AI-experience</link>
            <guid>https://sansui233.com/posts/2023-02-20-stable-diffusion-AI-experience</guid>
            <pubDate>Mon, 20 Feb 2023 17:21:28 GMT</pubDate>
            <description><![CDATA[高强度冲浪三天的AI绘图总结。进阶经验，非科普，基本是名词与对应的画面效果的解释、作为辅助的可能性探索。]]></description>
            <content:encoded><![CDATA[<p>进阶经验，非科普。分为五个部分：模型选择，分辨率调整，采样方法，ControlNet，Lora概述。</p>
<p>此文章涉及多平台发布，由于生成类 AI 的争议，文中无外链推荐。</p>
<h2>一、模型选择</h2>
<p>模型影响构图和笔触和色彩，决定成图的平均水平。社区经常都在换流行的模型，还是根据需求定，huggingface 和 civitai 上很多。</p>
<p>二次元目前主流三家 Anything Orange Counterfeit 。</p>
<p>目前有不少混合了 2D 和 3D 的 2.5D 模型，用来出 cos 的，个人不喜欢。</p>
<p>下图模型为 pastel-mix，图片画质已严重压缩（看不见则需要开代理，如果你用的 Innoreader 手机版阅读此文，大概率被放头图了）
![pastel-mix](https://raw.githubusercontent.com/NamiLing/upic/master/uPic/00153-2596022983-masterpiece, best quality, ultra-detailed, illustration, 1boy, Link in Breath of the wild, sun shine,water, on back, lying in wa.jpg)</p>
<h3>模型精度选择</h3>
<p>fp-16(2G)，fp-32(4G)，full(7G) 用于生产没有肉眼可见的区别。full 主要是训练用的。fp16 生产够用了，快，占用小。</p>
<p>bf-16(2G) 相对 fp-16 会损失一小部分细节，不推荐，会发布 bf-16 版本的模型也较少。</p>
<h3>VAE权重网络</h3>
<p>影响色彩，主观效果是增加饱和度（比修图软件饱和度增强好太多）。目前流行的 VAE 就两个，一个 Waifu 的一个 Anything 的，很多带 vae 模型都是用的这两个改了个名字。</p>
<p>下图为 mix-pro-v3-fp16 模型，叠加了其配套的  WD vae 的 效果，
![Mix-pro-v3](https://raw.githubusercontent.com/NamiLing/upic/master/uPic/00045-311454338-Original Characters, 1boy, sea shore,  pastel-full.jpg)</p>
<h3>Prompt</h3>
<p>prompt（提示词）是玄学范围。不同模型的 prompt 词库不一，目前主流的词库有两个</p>
<ul>
<li>适用 SD v1.x 及其衍生模型的 lexica</li>
<li>适用二次元模型的 Danbooru。</li>
</ul>
<p>对于二次元模型，Prompt 指定物体，调整动作、指定颜色比较容易。取决于模型的泛化能力。</p>
<p>Prompt 难以精确控制画风，所以尽管上限非常高，但主流越来越不倾向于用大量 Prompt 叠 buf，转成微调模型以达成精确需求。</p>
<p>在两个月前关于 Prompt 研究的文档就已经非常多了，这里不做推荐，因为不看文档，直接翻译成英文大概率是有效的。</p>
<h3>文生图与图生图</h3>
<p>文生图与图生图本质上没有什么不同，文生图只是将图片输入换成了一张随机的噪声图。</p>
<h2>二、分辨率</h2>
<p>不同模型在生成时有最佳的分辨率，大部分都在 512px 左右，不超过 1024px。</p>
<p>提高分辨率不仅是单纯放大图片，AI 能够用模型细化图片。</p>
<h3>图生图</h3>
<p>img2img(图生图) 大部分时候被用来衍生，但是其效果最好的是将 txt2img 的低分辨率图放大（用同一个seed）。</p>
<p>在 web-ui 中，仅缩放(just-resize)为无 AI 的放大算法处理。 AI 放大使用的 Latent 方法即将被归入 Upscaler，也就是下面说的 Hires fix。</p>
<h3>Hires fix</h3>
<p>Hires fix（高清修复）的作用是用 AI 从小图生成高分辨率图，处理用得好可以提高大幅提高图片上限。upscaler（放大器）可选几种放大方法，其中的 Latent  就是 SD 的画图方法，文生图与图生图均是这个方法。</p>
<p>在 web-ui 中， 默认只有 txt2img 可用，因为 img2img 本身就可以做图片放大。另外，有专门的 upscaler 选项卡。</p>
<p>使用 Latent upscaler (图生图) 放大到高分辨率图涉及局部重绘，部分模型支持较好，如 Pastel。但在 512 px 完成度就很高的模型上通常没有效果，或者更差（比如炫彩厚涂），这种用 GAN 类 Upscaler 直接放大比较好。</p>
<p>值得注意的是 web-ui 的 Hires fix 有两版算法，目前 txt2img 是新版， img2img是旧版，效果有一些小差别，很难比较好坏。</p>
<h2>三、采样方法</h2>
<p>Sampler（采样方法） 决定笔触和结构的稳定性。常用的有：</p>
<ul>
<li>Euler a 是一个规整稳定的采样方法，出的图较平滑</li>
<li>DDIM 是一个过程不算稳定的采样方法，通常看起来比 Euler a 细节更多</li>
<li>DPM++ 2M Karas，最近在用的，过程稳定但有细节</li>
</ul>
<p>有部分 Sampler 对高分辨率（1024px 以上）支持不好。</p>
<h2>四、 ControlNet</h2>
<p>ControlNet 目前是一个需要额外安装的插件，可以用于给线稿上色并细化，或从草图细化。</p>
<p>你的草图可以决定的是：</p>
<ul>
<li>60%-100% 的线条位置（构图）</li>
<li>主要色块位置。需要搭配图生图，并且色块越碎越好，需要提前做好整体的光影效果。因为 大部分 AI 只会画整，会画碎的比较少（Pastel 会画碎）。</li>
</ul>
<p>细化风格（画风）由模型决定，不由你的草稿决定。模型风格对于画风影响非常关键。Prompt 也可以影响画风。</p>
<p>细化内容（画的具体是什么）由 Prompt 、草稿、模型共同决定，调整 CFG、Denoise 、 ControlNet 的 Weight 可改变三者比例。</p>
<p>下图为自己的线稿使用 ControlNet 与 Anything V3.0 上色：</p>
<p>![Control-Net](https://raw.githubusercontent.com/NamiLing/upic/master/uPic/00275-3225619170-masterpiece, best quality, illustration,face, right hand, atomespheric, cold, sunshine, sky,, high detail, flowers and leafs.jpg)</p>
<p>（这个东西出名是因为某博说 ControlNet 初衷是洗稿……之前 Pixiv 也出过线稿上色的 AI，只是效果好和不好的差别，怎么没人说是搭配 PS 的线稿提取功能洗稿）</p>
<h2>五、Lora</h2>
<p>Lora 是一种训练小模型的方法，可以在 15 张图左右生成稳定的单个角色图。</p>
<p>已有大量角色图积累的流水线漫画苦力会比较省事，搭配 ControlNet 可生成固定姿势，或者使用线稿稳定地上色。但对于连续动作的细微差别不太行，细节演出表现依旧需要依赖线稿，或手动重绘</p>
<p>训练过程分为裁剪、自动打标、训练，最终生成约 100M 左右的 Lora 网络。Web-ui 已自带。</p>
<h2>写在后面</h2>
<p>风格迁移渐渐成熟了，过拟合的问题在逐渐减少。减少过拟合的最终解决思路，还是把端到端的网络，按需求拆成了人为可控的 pipline。个人认为 AI 如果真的要作为工具，模块化的 pipline 是终点。</p>
<p>直接出成图的是对已有作品的模拟，抽抽卡，融入不到创意的工作流。</p>
<p>但是在发展好之前，地球可能已经枯竭了。</p>
<p>![pastel-mix](https://raw.githubusercontent.com/NamiLing/upic/master/uPic/00162-1748765688-masterpiece, best quality, ultra-detailed, illustration, 1boy, Link in Breath of the wild, stronde hair, sun shine,water, emotio.jpg)</p>]]></content:encoded>
            <category domain="https://sansui233.com/categories/摸鱼">摸鱼</category>
        </item>
        <item>
            <title><![CDATA[杂谈20230101-20230207]]></title>
            <link>https://sansui233.com/memos</link>
            <guid>https://sansui233.com/memos?id=2023-02-08</guid>
            <pubDate>Wed, 08 Feb 2023 00:27:03 GMT</pubDate>
            <description><![CDATA[INFP 的无趣生活]]></description>
            <content:encoded><![CDATA[<h2>2023-02-17</h2>
<p>才知道 Bob 的谷歌翻译不用申请 API，有<a href="https://github.com/roojay520/bobplugin-google-translate">插件</a>调取 web 免费版的服务。</p>
<h2>2023-02-15</h2>
<p>被踢了，那安心写论文吧！本来也是因为不想写论文所以想找别的东西写写，但是又因为必须写论文很多事情只能列计划和看看。我 Debug 时说了两次源代码没有 Debug log 合作不方便，有人觉得打断点就挺好是我管太多，于是我被踢了= =我：？？至于吗，多大点事？可能互联网只能用同事的语气说话比较能正确表达情感程度。行，咱不 Debug了，该干啥干啥吧。之前还想测测 API 看更具体怎么传参会出岔子， postman 先设定一堆情况放着，现在觉得自己修修能用就 OK 了。真对不起主播，用你的项目也没法再给你及时反馈和 debug 了，除了 star 也没别的了。可能有空会在 issue 提，但其实平时没有那么频繁地关注项目，不写代码的时候极少开 github。我还是先写论文吧。</p>
<p>原理性的吵架一般是我会气别人走，别人如果是管理那就是踢我走了。因为理论上我觉得没什么好辩的，上万行的大项目不日志定位，纯从开头靠断点单步调试一个试试？但别人个人项目做不做其实都无所谓，我又不想在网上当爹。我的很多记录习惯都源于我记性差，为防止几个月后对着自己代码一脸懵逼不记得思路，会写一遍开发日志/日记一类的，过几个月就又是另一个人的记忆了。rust 的 webserver 也写过但现在让我看 rust 我真的会懵圈，感叹我当时怎么弄清楚这些乱七八糟的。不过不想造轮子了，除非轮子实现得太大了而我只用很小一部分。</p>
<p>说来我上一次差点被踢，是我在画接龙的时候，用 AI 绘图 img2img 看了一下……然后哇，我发誓那次我真的是什么都没说，仅仅是因为有人问起了 AI，我就顺便说了下用 AI 跑的结果，结果群里有初中生反感 AI，碰巧也是个管理员……突然又被骂。不过那个群比较公开的，没有说意气踢人，后面我道歉说我不该用 AI 跑这个就完事了。面子说不要可以不要的，留着脸皮能吃饭吗？不破原则就行。</p>
<p>说来好像这两次在被踢的边缘上摩擦，都是群主觉得其实没啥，管理踢的，嗯？确实 INTP 的时候没 Fi 和 Fe 什么事。这种意义上我这个 INFP 也够人格分裂的。</p>
<h2>2023-02-14</h2>
<p>配置了 neovim，十几天下来感觉算是没太大问题了，只是split的终端没有 filetype 还是有点瑕疵，导致 Lualine 不能忽略终端窗口。float term 不太喜欢用。不过 lsp-formatter也还有点 Bug，有的语言就是不 format 也不知道什么情况，主要是还不知道怎么看 Log。大杀器是异步，还有 LSP 和 Mason 做 LSP 的包管理。果然是能颠覆 vim 的存在。不过没有一个中心化的 GUI Package MarketPlace 还是挺烦的， 幸好网上有整合包这种东西，可以一键开箱用了。</p>
<p>之后就是 Debug，我还没试过 Debug 怎么样，我觉得这点是很难做到 vscode 那样的集成度。 但前端的 Debug 基本上是在浏览器里进行了，后端的话就测测 python 和 go。Java 还是不推荐用这类，直接 IDEA 吧。</p>
<p>vim 主要是编辑方式占优，但要是作为 IDE 全键盘流的上手难度实在是太高了，还是需要优化鼠标操作，否则光是切窗口就可以切到头疼。我也不觉得操作熟了之后定位的效率能超过鼠标， vim定位的方式太多了，而鼠标只有一种还很快。好的是删大段的 Text Obejct 和改 pairs。</p>
<hr/>
<p>（吐槽）最近加了一本书到书单是从 0 制作 CPU，不知道能不能看完。因为我还要写我 6w 字的水文。我已经对此麻木了，目前是只对这一件事有严重的注意力缺陷。但接下来 24 小时我都不能写，我得收东西。已经很多天没有在 4 点之前睡过觉，早睡睡不着。连续被拉出去吃局后前天早上终于崩溃了，那之后难受了一整天。而四年前的情况是，崩溃了，我还知道我要继续重复这种崩溃至少 3 个月，后来靠画画救了我。这是最初抑郁情绪的来源。就崩溃到那种只能躺着的程度都没法诊断出抑郁症，我是不知道抑郁症到底得疯到什么情况。我觉得远离强控制欲的家庭能治好 80%的抑郁，导师只能占 20%。了解我的人没有一个觉得我会找体制内的工作，好像所有人都觉得我是那种互联网的奋斗逼。但我还是没去私企，我没法对抗我长久以来接受的家庭教育，就算我知道有很多缺陷，就算我知道是束缚，我还是没法对抗，只能等待到下一次崩溃的边缘。我连转行都打听好了要怎么做，但是发现实在太他妈难了，除非我一天的时候足够干两人份的活，行内的人也建议我家庭这么反对还是算了。我姐昨天来试试平板画画，突然又说，不说画画了，免得你妈又说你不干正事。隔壁那个体制内画画的是天天画画，通宵画画。我没法通宵，不是不想而是受不住，有次只睡了 4 小时，早上 7 点起来拍照，整个人都困得随时倒下去，到中午开始浑身发冷胃痛，然后睡一觉就好了。就是这种一定要睡觉的体质= =</p>
<p>我喜欢我的姐姐（非直系），因为她是真的会对我说的新东西感兴趣的，觉得很多也还不错……难道长得像的人性格也像？没有没有，至少她不喜欢五金工具，而我每次搬家都会说带上我最爱的五金工具……</p>
<p>我还是希望我能在白天有点效率吧，但我不知道怎么做。我只会对想做/计划怎么做的事情有效率。</p>
<h2>2023-02-11</h2>
<p>年轻真好，年轻人做项目都更得劲。老年人就得考虑现在能不能做这个，做了会不会影响正事，会不会失业。</p>
<p>自从新冠以来咳嗽好像一直没好全，稍微有点空气不好就开始咳，应该去检查一下了。而且标准睡眠时间从 8 小时变成了 10 小时。真的羡慕睡 4-6 小时的人。</p>
<h2>2023-02-10</h2>
<p>谁 Github 把 SVG 当 GIF 用啊！！电脑卡死了！现在办公完全不够用，至少 4 个 word 2 个 PDF 一个 Logseq 和几个 Chrome Tab，有时候还要开个 社交软件，再来个把 SVG 当 GIF 用的，真的是卡，太卡了。很多时候都觉得比较追求“新”的开发者是不太能考虑到大众的设备需求的，因为我就是这样。前端框架出来后有一堆减轻渲染负担的东西，但真的要减轻渲染负担的话，其实还是不要用这么新的东西，不要这么多嵌套，不要 JS 搞这么多动态渲染的操作。交互是要差一点，但少点动画和嵌套也不会差到哪里去，网好响应快才是真正的交互好。不过开发体验可能会变差哈哈。由于这个原因，我想把博客首屏的动画给取消了，或者是换一个更简单一点的。</p>
<h2>2023-02-09</h2>
<p>又是什么都没干的一天，拖延晚期。更新了 About 页的头图，很久没画插画了我看不得这些，看了之后现在非常想去画插画。太多对于自己不重要但又重要的事了。已经四年了，看到微博上有人说：“得过的人会知道，即便是事后恢复了，也不可能回到原来状态了”。非常真实，某种程度上这是永久性的，拖延症也是之前没有的，DDL 完全不管用了。虽然已经恢复了笑的能力，但很明显没法保持住开心了，需要刻意想很多能让自己开心一点的事情。理解痛苦的能力直接从 0 变成了 Level Max。 之前听鹿乃的 hello how are you（是日文名，念出来就是英文），第一次听我直接落泪好吗。虽然这首歌表面上很萌很开心，但我感觉其实唱的并不高兴。后面翻出来一看歌词，是真的不开心。</p>
<h2>2023-02-07</h2>
<ul>
<li>最好用的 Chrome 网页翻译插件推荐：<a href="https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh">Immersive Translate</a></li>
</ul>
<p>之前也提过 Chrome 浏览器自带翻译失效但不想开全局代理的问题，没有提插件级的网页翻译，主要是没遇到好用的。今天这个就非常好用，逐段中英对照，可配置多家翻译的 API。</p>
<ul>
<li>廉价储存服务：<a href="https://www.backblaze.com/b2/cloud-storage.html">B2 Cloud Storage</a> 有 10GB 的免费额度，白嫖的选项又增加了。</li>
<li>老文章但写得非常棒 ：<a href="https://github.com/Liaoct/blog/blob/master/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%EF%BC%8C%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%90%8E%E7%AB%AF%E4%BA%BA%E5%91%98%E5%A6%82%E4%BD%95%E5%90%88%E4%BD%9C%EF%BC%9F.md">前后端分离模式下，前端与后端人员如何合作？</a></li>
</ul>
<p>现在已经 API 设计的工具已经很成熟了。不过有点感触是，前后端分离在简化小型应用的开发流程上其实是负效果，增加人员成本与沟通成本，好处需要到大型单体项目开发才会体现出来。但是，这么大的单体项目有多少呢？外包还是 PHP 的天下。</p>
<p>我从一开始就分离是属于个人强迫症，感觉各模块干各的，符合流水线工作，干净，PHP 写过，表示不能忍，为什么要在 HTML 里夹业务代码？ 不过这好像点和 JSX 也差不多的哈……而且真的比 JSX 简单。</p>
<p>其它好处还是有的：</p>
<ol>
<li>出现许多小型的单独前后端的项目，可灵活组合使用，适用更多业务场景。在此之前靠插件，现在靠 restful。</li>
<li>人员技术栈缩窄，便于在各自的领域做出更高的质量。如果仍然是前后端一体的开发，很给想象做到今天这种程度的复杂交互，即使是有设计师，因为总是后端比较重要。当然技术栈缩窄不代表学习的新东西变少，前端完全没有要停的趋势，因为很多问题依然没有得到解决，离生态稳定还有很长的路要走</li>
</ol>
<hr/>
<p>最近想把 Memos 重构成有后端的，短文还是应该能在线发布，而且想重新设计一下不要把量感做这么大（但架不住我写得长啊……）。另一方面，依然想使用静态博客的部署，可安全性上，认证什么的又必需要用到后端，可我又不想维护一套博客的后端（<del>部署时想白嫖很困难</del>），就算开源有现成的解决方案，还是要自己部署和运维（到底是有多懒）。现在考虑的是 Netfify CMS 这类不用自己部署、有现成 Auth、存储可以继续静态页面白嫖 Github （不好意思）的无头 CMS 解决方案。不过能这样做也是因为我的东西不多，数据也不复杂。 mdx 本身也可以内嵌很多东西，调用外部的资源渲染也没什么问题。CMS 层也只是让我可以不开电脑写字，二进制数据还是会放在其他地方的。</p>
<p>还有想把 Memos 做成可配置的插件什么的，以后再做别的插件。说真的，Next.js 的渲染方式反而不太好做插件系统了，启动一时爽，还是得要自己写路由。目前没考虑太多 ，完全没想要插件API要开放哪些，要定制哪些，以怎样的形式存在。 个人用是完全不需要的，只是为了方便别人用的时候把不用的功能好开关一下。 i18n也没有想好用不用，想做只是纯粹得想看看全中文 UI 是什么想的……我也不可能真的发布多语言版本文章是吧，机翻又不如不翻。</p>
<p>为什么优先考虑无服务器，主要是降低运维成本（真的不是因为能白嫖）。稳定好用的服务器不仅不便宜，还容易一被打就嗝了。能在云平台托管的项目稳定太多，能用的 CDN 起飞。但问题是会造成项目过于分散，前端后端存储都是分开托管的，一个 Waline 就布署得够烦人了。但是！！像是，有 Github 这种平台，托管文件做 web 服务的同时可以解决认证和存储的问题，只是需要一个第三方做这个随时能操作 Github 仓库的中介，毕竟还是要个后端与 github 通信做认证，浏览器 API 还没有到如此神通广大的地步。</p>
<hr/>
<p>再说点题外话，今天看了一个视频，叫“那些只有长相普通的女生，才会知道的人生真相”。是有点好奇才点进去的。说真的，我从小到大的女性朋友， 80%都长得好看，而且有一半是长得非常好看，没有 gakki 和 kanna  那一卦的，但秒杀那啥 48 的绝对不止一两个。高中室友清晰记得一个长了我觉得世界上最好看的丹凤眼，一个长得很桂纶镁但比桂纶镁更好看。我的近亲姐姐都算好看，到我宿舍之后被我室友夸好看的那种，然后我妈还会被同学妈妈夸好看……总之就是不太会接触到“普通长相”，顶多是普通好看。我对普通好看的标准大概是关晓彤/杨紫这样的。但我看男生除了发小和几个哥哥，感觉大部分都很普通……发小是真的帅，我的几个哥哥还挺好看的。我面基的网友也超级好看，可以演电影的那种好看……然后这些人里要化妆的要双眼皮的通常不是因为觉得自己不好看，而是喜欢化妆或者走风格拍抖音啥的，只有一个由于肤色不均但只要肤色白了就非常好看的妹子算是美化性质的化妆。前些天还有个妹妹，有点刘亦菲，但比刘亦菲好看（毕竟刘亦菲全家最丑），吃了三次饭我都不敢提出和她合影，因为她实在过于好看了，好看到我觉得这不是普通人能去随意合影的长相，她大概都要被合影烦了吧。</p>
<p>好了，我说完好看了。看到里面“普通长相”有一点是，不会因为自己的长相而心情变好，有好看的朋友因为长得好看，哭了之后在镜子面前补装，补着补着心情就好了，因为发现自己实在太好看了！我：擦，原来这不是所有人都会有的感受啊。我记得以前一个长得不太好看但人非常好的同学，觉得自己长的也还是可以的，以至于我一直觉得每个人应该都能看到自己好看的地方。反正我每次看照片，觉得自己哪里长得不太好看都要被室友骂，“你还嫌不够好看”？但是说穿得不太好看，就没有人有意见，因为我觉得，长得好看和穿得好看，有一个就行了（狗头）</p>
<p>但是除了长相，还有一个问题，就算我没有表情，或者我维持着一个没有情绪但明显面部肌肉有在发力的表情，就能根据情况被自动解读出“诧异”“开心”“不解”“不满”等多种情绪，实乃餐桌万金油。但有时候也很苦恼， 因为我刚才什么都没想，我可能都没听他们在说什么，完全不知道他们怎么理解出这些的。</p>]]></content:encoded>
            <category>Diary</category>
        </item>
        <item>
            <title><![CDATA[部署饥荒联机版Linux服务器]]></title>
            <link>https://sansui233.com/posts/dontstarvetogether-linux-server</link>
            <guid>https://sansui233.com/posts/dontstarvetogether-linux-server</guid>
            <pubDate>Wed, 28 Dec 2022 14:52:41 GMT</pubDate>
            <description><![CDATA[此文为 Docker 版饥荒联机版服务器在 CentOS 下的部署教程。]]></description>
            <content:encoded><![CDATA[<p>此文为 Docker 版饥荒联机版服务器在 CentOS 下的部署教程。</p>
<blockquote>
<p>为什么要部署Linux服务器？因为玩到后面，只要一联机连主机都卡，闲得想试</p>
</blockquote>
<p><a href="https://www.roci.ltd/dstserver/">这个中文教程</a>讲了native steam版的安装方法，包括了Cent OS缺少的库，坑全踩了一遍写得十分详细。官方文档实在太拉，基本就是没有文档，像跨平台缺库这种事情也没有解决，没有脚本。不过教程中对于网络环境问题与mod的配置方法提得不多。</p>
<p>我这里使用的是<a href="https://hub.docker.com/r/jamesits/dst-server">Docker版本</a>。优点是</p>
<ul>
<li>国内的云平台对于Dockerhub的加速后走内网流量，不使用公网流量下载镜像。而且国内的服务器公网下载速度堪忧。</li>
<li>Docker版本的文档写得对用户友好，易上手</li>
<li>文件管理集中，比较方便。原版服务器的mod和存档是分开放的</li>
</ul>
<p>也有一些在国内环境下比较要命的缺点</p>
<ul>
<li>网络环境原因，无法下载创意工坊mod。最近靠改 hosts 也不行了。</li>
<li>如果想开代理下载，docker容器开代理（设置环境变量）非常麻烦，具体来讲
<ol>
<li>如果每次开关代理都创建一个新的容器，Steam和游戏文件的更新都得再触发一次，又消耗流量又慢</li>
<li>如果动态修改容器的配置文件，docker需要重启才能生效，所有docker服务都得宕机一会儿</li>
</ol>
</li>
</ul>
<h2>准备</h2>
<ul>
<li>一台至少2G内存的服务器</li>
<li>使用ssh连接服务器、传输并管理文件的技能</li>
</ul>
<h2>Docker的安装</h2>
<p>由于涉及到Docker镜像和Dockerhub加速的问题，具体安装步骤建议看docker的文档和各个云平台。</p>
<p>我使用的腾讯云，见<a href="https://cloud.tencent.com/document/product/1207/45596">安装 Docker 并配置镜像加速源</a>，大约花费2分钟。</p>
<h2>服务器防火墙设置</h2>
<p>需要放行 10999，11000，12346，12347 这四个端口的UDP流量。</p>
<ul>
<li>在国内云平台的控制台-防火墙中，放行服务器的这四个端口</li>
<li>如果服务器上iptables有流量拦截，也需要放行</li>
</ul>
<h2>饥荒服务器镜像的启动</h2>
<pre><code class="language-bash">mkdir ${HOME}/Klei # 创建存放数据有文件夹

# 拉取镜像并在前台启动
# 由于Steam要更新，根据网络环境可能要等比较久的时间
# 如果实在无法连接，再考虑给容器挂个代理下载。但总体不建议容器挂代理，因为我不清楚挂代理后steam是连接到服务器的游戏端口还是连到代理的端口上去了，取消容器的代理也非常麻烦。
docker run --name dst -v ${HOME}/Klei:/data -p 10999-11000:10999-11000/udp -p 12346-12347:12346-12347/udp -it jamesits/dst-server:latest
</code></pre>
<p>以上命令执行期间，可以去准备一下游戏存档和Mod相关文件。</p>
<h2>准备游戏存档和Mod</h2>
<p>我使用的Mac，饥荒的游戏文件相关目录位于</p>
<pre><code class="language-bash"># 游戏存档
SAVE_DIR=&quot;~/Documents/Klei/DoNotStarveTogether/324927772/Cluster_1&quot;
# mod下载目录
MODS_DIR=&quot;~/Library/Application Support/Steam/steamapps/common/Don&#x27;t Starve Together/dontstarve_steam.app/Contents/mods&quot; #

cd $SAVE_DIR # 进入存档目录
</code></pre>
<p>windows可以在饥荒游戏内点数据打开游戏存档，并在Steam中查看游戏的安装目录。</p>
<h3>准备存档信息</h3>
<p>点开<a href="https://accounts.klei.com/account/info">饥荒的账号</a>，记下 <strong>Klei User ID</strong>。如果没有就注册一个。</p>
<p>然后，新建<code>adminlist.txt</code>，并写入你的<strong>Klei User ID。</strong></p>
<pre><code class="language-bash">$ vim adminlist.txt
# 写入以下内容
你的Klei User ID
</code></pre>
<p>点开<a href="https://accounts.klei.com/account/game/servers?game=DontStarveTogether">自建饥荒服务器的页面</a>，新建一个服务器，记下生成的Server Token，其他不用管。</p>
<p>然后，新建 <code>cluster_token.txt</code>，并写入Server Token。</p>
<pre><code class="language-bash">$ vim cluster_token.txt
# 写入以下内容
你的Server Token
</code></pre>
<h3>准备mods</h3>
<p>不开mod的可以跳过这一步。</p>
<p>由于国内环境没法下载mod，需要把对应的mod文件复制过来。我为了方便就全复制了</p>
<pre><code class="language-bash">cp -r &quot;$MODS_DIR&quot; mods
</code></pre>
<p>先查看一下目前的存档开了哪些mod。</p>
<pre><code class="language-bash">$ cat Master/modoverrides.lua
# 开启的mod
return {
  [&quot;workshop-1172839635&quot;]={ configuration_options={ icebox_freeze=&quot;0.5&quot; }, enabled=true },
  [&quot;workshop-1294206358&quot;]={ configuration_options={  }, enabled=true },
}
</code></pre>
<p>然后，编辑 <code>mods/dedicated_server_mods_setup.lua</code> 文件，写入上面的mod编号</p>
<pre><code class="language-bash">$ vim mods/dedicated_server_mods_setup.lua
# 写入以下内容
ServerModSetup(&quot;workshop-1294206358&quot;)
ServerModSetup(&quot;workshop-1595631294&quot;)
</code></pre>
<p>至此，游戏存档和mods就准备好了。</p>
<h2>转移游戏存档和Mods至服务器</h2>
<p>上传游戏存档到服务器。打包和上传文件我一般使用GUI操作，用命令行的话是这样</p>
<pre><code class="language-bash">cd ~/Documents/Klei/DoNotStarveTogether/324927772/
tar -cvf Cluster_1.tar.gz Cluster_1 
scp Cluster_1.tar.gz root@myserver:/Klei/
</code></pre>
<p>如果之前的服务器连接还在，等无新日志输出后使用control+c退出容器。如果已断开连接，重新用ssh登录服务器。</p>
<p>然后可以看到在服务器的 <code>~/Klei/DoNotStarveTogether</code> 中有了一个 <code>Cluster_1</code> 存档。</p>
<p><strong>转移游戏存档时，需要注意有两种情况（来自<a href="https://hub.docker.com/r/jamesits/dst-server">文档</a>）</strong></p>
<p>第一种情况是，如果自己的存档开启了洞穴，把自己的存档覆盖过去即可。</p>
<pre><code class="language-bash">rm -rf Cluster_1
tar -xvf Cluster_1.tar.gz
</code></pre>
<p>第二种情况是，自己的存档没有开启洞穴，需要</p>
<ol>
<li>在自己的电脑中，存档的上一级有个 <code>client_save</code> 。复制下面的除了 <code>session</code> 外的所有文件到服务器的 <code>Cluster_1/save</code> 。</li>
<li>自己存档中的 <code>Cluster_1/save/session</code> 需要删除，其他文件可以直接覆盖</li>
</ol>
<p>存档覆盖完毕后，启动容器</p>
<pre><code class="language-bash">docker start -a dst
# 如果最后输出了 Sim Pause 就代表 OK 了，按 ctrl + c 退出，容器继续后台运行
</code></pre>
<p>我第一次装Mod启动时发生了一个莫名其妙的 <strong>Segmentation fault</strong>，程序退出了，但是第二次启动就好了。搜了一下<a href="https://github.com/Jamesits/docker-dst-server/issues/48">相关issue</a>，完全相同的情况，也是CentOS，偶尔发生，难稳定复现。</p>
<h2>游玩</h2>
<p>之前自己的存档叫什么名字就搜什么名字，加入就完事，好好玩吧w</p>
<hr/>
<p>参考资料：</p>
<ul>
<li><a href="https://hub.docker.com/r/jamesits/dst-server">jamesits/dst-server</a></li>
<li><a href="https://github.com/Jamesits/docker-dst-server/issues">docker-dst-server issue</a></li>
<li><a href="https://www.roci.ltd/dstserver/">饥荒独立服务器入门级快速搭建</a></li>
<li><a href="https://dontstarve.fandom.com/wiki/Guides/Don%E2%80%99t_Starve_Together_Dedicated_Servers">Guides/Don&#x27;t Starve Together Dedicated Servers - Fandom</a></li>
</ul>]]></content:encoded>
            <category domain="https://sansui233.com/categories/摸鱼">摸鱼</category>
        </item>
        <item>
            <title><![CDATA[记一道题排列组合题解]]></title>
            <link>https://sansui233.com/posts/记一道题排列组合题解</link>
            <guid>https://sansui233.com/posts/记一道题排列组合题解</guid>
            <pubDate>Fri, 18 Nov 2022 03:25:07 GMT</pubDate>
            <description><![CDATA[难得在网上遇到有认真在做题的人，在此表示深深的感谢。]]></description>
            <content:encoded><![CDATA[<p>难得在网上遇到有认真在做题的人，在此表示深深的感谢。另外个人不太会写题解类的文，权当一个记事了。</p>
<h2>题目</h2>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/8B414946-F4D4-479C-9092-9AEA8EC26FA3.jpeg" alt="8B414946-F4D4-479C-9092-9AEA8EC26FA3.jpeg"/></p>
<p>题来自 tg 里玩 ai 的小水群，很多人第一眼是想全排列剪枝……阶乘的复杂度得瞎了。</p>
<p>不过看到求方案数，帮人面试时被动态规划虐过的直觉在告诉我，凡事让写方案数不枚举方案的，很可能能写动态规划。</p>
<p>于是从动态规划的方面想去了。</p>
<h2>关于素数</h2>
<p>这个题有一个非常奇怪的地方，就是要和为素数。我不禁想，和为素数是对解题方法有什么加成吗？</p>
<p>（其实因为我最初看走眼了，以为是子集里所有数为素数，且和为素数，还以为素数和有什么定理）</p>
<p>素数的特殊点在于乘法分解，至于加法上与一般数有什么不同，以凡人视角未曾听说。并且这题还并不限于子集中取用什么数。</p>
<p>综上，和为素数对解题方法不仅没有什么加成，反而是多了个如何判断一个数是不是素数的问题。</p>
<p>至于如何判断素数，在 Leetcode 204，略，也没什么很省时间的方法，就是筛，不算简单。</p>
<h2>子集动态规划</h2>
<p>既然素数对于解题思路没有加成，就按一般数处理，很快写出了下面的思路：</p>
<ol>
<li>一维dp中存下和为当前数的方案数</li>
<li>遍历更新dp，把新数n拆分成已有数+余数，按余数从大到小（已有数从小到大），把所有已有数的拆分方案加起来，再+1，即可得到当前数的子集数。
<ol>
<li>需要注意的是，为了保证不重复，也就是保证子集序列递增，已有数不会超过n/2（余数不会小于n/2）</li>
</ol>
</li>
<li>更新dp时，也要计算新数n是否为质数，是的话把其子集数加入最终结果（算质数见leetcode 204）</li>
<li>由于取值范围1-2000，最大和为1000^2，100w，也是dp要遍历的次数。</li>
</ol>
<p>下面的图是在解释什么叫“遍历但不用枚举子集”时写的，也是上述dp的步骤。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/2E06B8C3-1DF4-492D-A009-55F4D7A041CE.jpeg" alt=""/></p>
<p>发题人仔细看了，并且手动枚举了10个数后，指出，我这会漏掉10=1+2+3+4。（后面自己发现这样还漏了145和235，后面越漏越多）</p>
<p>仔细回顾了一下之前的思路，发现我的问题出在递增的判断上。我当时认为保证递增序列，只要保证已有数小于余数就行，所以余数&gt;2/n。</p>
<p>但不是的，比如n=10时，已有数为6，余数为4，6拆分为1+2+3就行，1234还是序列递增的。6拆分为2+4、1+5就不行。</p>
<p>归根结底就是我只把余数算了较大的一半，因为余数较大的一半肯定能保证序列递增。如果不想漏情况，余数要全部遍历，但怎么保证序列递增呢？比如6+4，如何只拆到1+2+3+4，不算1+5+4和2+4+4呢？</p>
<p>于是更新了一下递增的条件：</p>
<ul>
<li>已有数的拆分的子序列最大数小于余数，则拆分方案合法</li>
</ul>
<p>再更新dp时余数范围：</p>
<ul>
<li>余数从n取到1，分别计算子集数后再sum。</li>
</ul>
<p>这样可以保证思路没问题了，但这个“已有数的拆分的子序列最大数小于余数”，明显当前dp只统计了子集数，根本不知道各个子集中具体最大数的情况。因此，我改成了个二维dp，含义和过程如下图：</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/6D139DD5-A95F-4467-BA58-3B5E61D9207D.jpeg" alt=""/></p>
<p>简单总结一下，整个问题我简化到了求“和为 n 的子集数”，并利用二维动规从 1 求到 n。 n 是不是素数单独算的。</p>
<p>并且发现，其实更新每一行时，都是把上一行为止的方阵以“/”方向45度拆开，mask掉右边部分，按行求和后，从右往左地写进下一行，还能用gpu加个速（不是）。</p>
<h2>另一种解法</h2>
<p>发题人在看了我的新方案后，说在上面看到了类似杨辉三角之类的东西。并且得出了另一个方案：</p>
<blockquote>
<p>和为 n 的子集组合数，为多项式 (x^n+1)(x^(n-1)+1)(x^(n-2)+1)…(x+1) 的 x^n 项系数</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/IMG_5434.JPG" alt="多项式展开"/></p>
<p>（我本来没理解，是死缠烂打地问才知道他在说什么）</p>
<p>仔细一想真的是这个理， x^n 对应的多项式系数就是排列组合到 n 的所有方案数了，也天然没有重复用数的问题。怎么想到的，神。</p>
<p>所以现在问题是：怎么求 (x^n+1)(x^(n-1)+1)(x^(n-2)+1)…(x+1)的多项式系数。</p>
<p>（当时已经不想动脑了，又是死缠烂打地问）</p>
<p>其实迭代就能算，因为 F(n) = x^n • F(n-1) + F(n-1)，对应系数直接挪位置后复制粘贴再相加就好了。</p>
<h2>空间复杂度</h2>
<p>这里有点难以定义 n 具体指哪个，默认 n = 2000 。</p>
<p>我的解法是要 1000^4 的空间去存方案数，矩阵中有很多地方是空的，有点浪费。</p>
<p>后者的解法要1000^2 空间去存多项式系数。省很多。</p>
<h2>时间复杂度</h2>
<p>以我的动规方法，时间复杂度为在 O(n^6)，准确说是O(n^2(n^2+1)(2n^2+1)/6)，因为要算到 (n/2)^2，且内部还有已填矩阵按行遍历。</p>
<p>以后者的的解法，时间复杂度为 O(n^3)，因为多项式的 n 需要到 (n/2)^2。</p>
<p>线性筛到 (n/2)^2 的素数, 时间复杂度为 O(n^2)。</p>
<hr/>
<p>总得来说还是数学好的强啊。</p>
<p>另外还有一个人非让我看完一个 30 分钟的高斯素数判断法，结果我一直在想 dp，搞得他怨念深重 hh</p>]]></content:encoded>
            <category domain="https://sansui233.com/categories/学习">学习</category>
        </item>
        <item>
            <title><![CDATA[理解 Rust 闭包与环境变量所有权]]></title>
            <link>https://sansui233.com/posts/rust-closure-and-ownership</link>
            <guid>https://sansui233.com/posts/rust-closure-and-ownership</guid>
            <pubDate>Tue, 14 Jun 2022 01:51:30 GMT</pubDate>
            <description><![CDATA[本文将以最简单易懂的方式讲述 Rust 中的闭包与环境变量所有权的关系]]></description>
            <content:encoded><![CDATA[<p>本文将以（自认为）最简单易懂的方式讲述 Rust 中的闭包与环境变量所有权的关系。在现存的类似中文教程中，要么语言表述歧义太大，逻辑上难以理清；要么试图把事情总结得过于复杂。实际上闭包对于环境变量所有权的处理规则是非常简单的。</p>
<p>阅读本文需要的基础： Rust 变量的所有权、引用与借用、函数、traits。</p>
<h2>什么是 Rust 的闭包</h2>
<p>Rust 中的闭包是<strong>一种函数</strong>。与 Rust 普通函数不同，它可以<strong>捕获函数外部的变量并使用</strong>。</p>
<p>基本语法：<code>|参数列表| {函数体}</code></p>
<pre><code class="language-rust">fn main() {
    let x = 1;
    let sum = |y: i32| { x + y }; // 说明： 闭包 sum 接收一个参数 y，且捕获前面的 x = 1, 返回 x + y
    println!(&quot;{}&quot;, sum(99)); // 输出 100

    let sum2 = |y :i32| x + y + 1; // 也可以省略花括号
    println!(&quot;{}&quot;, sum2(99)); // 输出 101
}
</code></pre>
<blockquote>
<p>说明： 闭包 sum 接收一个参数 y，返回 x + y。其中 x 是第一行定义的 <code>let x = 1;</code> ，为闭包外部的变量。</p>
</blockquote>
<p>像 <code>x</code> 这样在定义在闭包外部、可被闭包直接访问的变量，我们称为“<strong>环境变量</strong>”。</p>
<h2>闭包中环境变量的所有权</h2>
<p>有 rust 基础的人应该知道，普通的 rust 函数的传入参数有三种形式</p>
<ol>
<li>所有权 move（默认行为）。</li>
<li>可变借用，形式为 <code>&amp;mut param</code></li>
<li>不可变借用 ，形式为 <code>&amp;param</code></li>
</ol>
<blockquote>
<p>上述为 rust 所有权基础知识，不再赘述。</p>
</blockquote>
<p>普通的 rust 函数可以使用参数，但无法使用环境变量。闭包则加上了 <strong>捕获当前环境变量</strong> 的功能。</p>
<p><strong>捕获当前环境变量</strong> 仅仅是指闭包 “知道有哪些环境变量”。闭包在使用环境变量时，依然可能会对环境变量执行三种操作：</p>
<ol>
<li>所有权 move</li>
<li>可变借用</li>
<li>不可变借用</li>
</ol>
<p>具体是执行了哪种操作呢？这个问题就比较复杂了，我们可以从上面的例子出发。</p>
<p>回顾上面的例子，对于环境变量 <code>x</code> ，首先排除了所有权 move。</p>
<pre><code class="language-rust">    let x = 1;
    let sum = |y: i32| { x + y }; // 使用了 x
    println!(&quot;{}&quot;, sum(99)); // 输出 100

    let sum2 = |y :i32| x + y + 1; // 再次使用了 x
    println!(&quot;{}&quot;, sum2(99)); // 输出 101
</code></pre>
<blockquote>
<p>说明： <code>x</code> 在 sum1 中使用后，还能在 sum2 中再次使用，说明 <code>x</code> 所有权没有 move。</p>
</blockquote>
<p>实际上，上述例子的 <code>x</code> 在闭包中是作为 <strong>不可变借用</strong> 使用的，<strong>因为这个闭包实现了 <code>Fn</code> trait</strong>。</p>
<h2>闭包的三种 traits</h2>
<p>闭包是一种函数，它的三种 traits 恰好对应了三种处理所有权的方式。</p>
<p>三种 traits 如下（划重点，请背下来）：</p>
<ol>
<li><code>FnOnce</code>：表示此闭包调用时会获取环境变量所有权（<strong>所有权 move</strong>)。因此取名 <code>FnOnce</code>，表示此闭包只能执行一次，因为再次执行时，环境变量可能由于之前所有权 move 过，已经没法用了。</li>
<li><code>FnMut</code>  ：表示此闭包调用时会对环境变量进行<strong>可变借用</strong>，可能会修改环境变量</li>
<li><code>Fn</code> ： 表示此闭包调用时会对环境变量进行<strong>不可变借用</strong>，不会修改环境变量</li>
</ol>
<p>并且，<strong>一个闭包可以同时实现多个 traits</strong>。比如实现了 <code>Fn</code> 的闭包也一定实现了 <code>FnOnce</code> （后续解释）。</p>
<p>上面是从“对环境变量如何处理所有权” 来解释三个 traits，大部分教程也是这么写，但个人并不推荐完全按这样去理解。因为上述表述中，三个 traits 看起来是互不重叠的（实际并非如此），导致可能会出现这样的疑问：</p>
<blockquote>
<p>“实现了 <code>Fn</code> 的闭包说是对环境变量进行了不可变借用，那怎么还能同时实现 <code>FnOnce</code> ，去获取环境变量的所有权呢？到底是仅仅进行不可变借用，还是获取了所有权呢？”</p>
</blockquote>
<p>但是看三个 traits 的源代码，可以直接回答上述问题：是不可变借用。虽然确实也实现了 <code>FnOnce</code>（所有权 move） ，但并没有调用 <code>FnOnce</code> 的 call 函数，而是调用了 <code>Fn</code>(不可变借用) 的 call 函数。</p>
<pre><code class="language-rust">pub trait Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt; : FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

pub trait FnOnce&lt;Args&gt; {
    type Output;

    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
</code></pre>
<blockquote>
<p>分析：如果 <code>FnOnce</code> 的 call 函数被调用，则直接传入了 <code>self</code> ，也就是获取了当前的环境变量的所有权，自然运行一次后回被销毁。而 <code>Fn</code> 的 call 函数传入的是不可变借用 <code>&amp;self</code>。</p>
</blockquote>
<p>并且会发现， <code>Fn</code> 的前提是实现了 <code>FnMut</code> ,  <code>FnMut</code> 的前提是实现了 <code>FnOnce</code> 。</p>
<ul>
<li>从继承关系来讲： <code>Fn</code> 继承 <code>FnMut</code> 继承 <code>FnOnce</code></li>
<li>从访问变量的权限范围来讲： <code>Fn</code> &lt; <code>FnMut</code> &lt; <code>FnOnce</code></li>
</ul>
<p>也可以说，<strong>闭包就算实现了 <code>FnOnce</code> 也不一定会用到所有权 move，因为可能还实现了 <code>Fn</code> ，那么环境变量的所有权会按 <code>Fn</code> 处理</strong>。</p>
<hr/>
<p>由于上述继承关系，如果定义一个普通函数，参数需要传入 <code>FnOnce</code> ，实际上也可以传入 <code>Fn</code> 。</p>
<pre><code class="language-rust">fn fn_once&lt;F&gt;(func: F)
where
    F: FnOnce(usize) -&gt; bool, // 传入闭包
{
    println!(&quot;{}&quot;, func(3));
}

fn main() {
    let x = vec![1, 2, 3];
    let closure = |z|{z == x.len()}; // 此闭包实现了 Fn、 FnMut 和 FnOnce
    fn_once(closure); // Fn 可传入标注为 FnOnce 的参数
    println!(&quot;{:?}&quot;, x); // x 还能用，所有权没转移

    let closure2 = move |z|{z == x.len()}; //  此闭包只实现了 FnOnce，因为 x 被强制转移所有权到闭包内部
    fn_once(closure2); // 传入 FnOnce
    println!(&quot;{:?}&quot;, x); // 报错，x 已经没了
}
</code></pre>
<blockquote>
<p>说明：fn_once 需要接收 <code>FnOnce</code> 的闭包作为参数，但传入 <code>Fn</code> 也是合理的，编译器也会按照 <code>Fn</code> 的调用方式处理为不可变借用，并不会因为标注着 <code>FnOnce</code> 而变成所有权 move。</p>
</blockquote>
<blockquote>
<p>闭包对所有权的处理并不会随着标注改变，标注仅仅是为了取悦编译器  ——鲁迅</p>
</blockquote>
<h2>闭包实现三种 traits</h2>
<p>上述例子中，直接标注了闭包实现了三种 traits，但并没有具体说明为什么这么写就是实现了三种 traits。这是本节需要说明的内容。</p>
<p>闭包实现 traits 是<strong>隐式</strong>的。也就是说，你不用（也没法）标注这个闭包是实现的哪个 traits。具体实现了哪些 traits 是根据你的闭包写法决定的。</p>
<p>1. 实现<code>FnOnce</code></p>
<p>所有的闭包都自动实现了 <code>FnOnce</code> 。不用特别做什么。</p>
<p>但更普遍的情况是，定义闭包时会顺带实现 <code>Fn</code> 或者 <code>FnMut</code> 。如果想要只实现 <code>FnOnce</code>，不要实现另外两个，需要用 <code>move</code> 。这个关键字会强制转移所有权，使闭包无法满足 <code>FnMut</code> 和 <code>Fn</code> 的条件。</p>
<ul>
<li>例：只实现了 <code>FnOnce</code> 的闭包</li>
</ul>
<pre><code class="language-rust">fn main() {
    let x = [1,2,3];
    
    let closure2 = move |z|{z == x.len()}; // 只实现了 FnOnce，所有权转移
    closure2(2);
    
    println!(&quot;{:?}&quot;, x); // 报错，x 所有权被转移
}
</code></pre>
<p>2. 实现<code>FnMut</code></p>
<p>在闭包中修改外部变量，即实现了 <code>FnMut</code> （自然也实现了 <code>FnOnce</code> ），同时没有实现 <code>Fn</code> 。</p>
<pre><code class="language-rust">fn main() {
    let mut x = vec![1,2,3];

    let mut closure = ||{x.push(4);}; // 修改了外部的 x, 实现了 FnMut， x 所有权没有转移
    closure();
    
    println!(&quot;{:?}&quot;, x);
}
</code></pre>
<p>3. 实现<code>Fn</code></p>
<p>在闭包中访问外部变量，不做任何修改，即实现了 <code>Fn</code> （自然也实现了 <code>FnMut</code>  和 <code>FnOnce</code>）。</p>
<pre><code class="language-rust">fn main() {
    let s = String::new();

    let update_string =  || println!(&quot;{}&quot;,s); // 访问外部的 s, 实现了 Fn

    exec(update_string);
    exec1(update_string);
    exec2(update_string);
}

fn exec&lt;F: FnOnce()&gt;(f: F)  { // Fn 也可以传到 FnOnce 类型
    f() // 调用的是 Fn，所有权不会转移
}

fn exec1&lt;F: FnMut()&gt;(mut f: F)  { // Fn 也可以传到 FnMut 类型
    f()
}

fn exec2&lt;F: Fn()&gt;(f: F)  {
    f()
}
</code></pre>
<h2>闭包自身的所有权</h2>
<p>上述讨论的是闭包对于环境变量的所有权处理。那闭包自己呢？当闭包自己作为变量被传来传去时，是 Copy 还是所有权 Move？</p>
<p>答案是，<code>Fn</code> 是 Copy，<code>FnMut</code> 和 <code>FnOnce</code> 是所有权 Move。</p>
<pre><code class="language-rust">fn main() {
    let x = vec![1,2,3];

    let closure = |z:usize|{ z == x.len()}; // 实现了 Fn
    outter(closure); // 通过
    outter(closure); // 通过

    let closure2 = |z:usize|{ x.push(4);z == x.len()}; // 实现了 FnMut
    outter(closure2); // 通过
    outter(closure2); // 报错, closure2 的所有权已被转移
}

fn outter&lt;T&gt;(mut func: T)
where T: FnMut(usize) -&gt; bool { // Fn 可以传到 FnMut 标注的参数上
    let a = func;
}
</code></pre>
<p>这是非常合理的，对应着 Rust 借用的规则</p>
<blockquote>
<p>在同一时间点，对于同一个变量，<strong>要么</strong>只能有一个可变借用(FnMut)，<strong>要么</strong>只能有<strong>多个不可变借用</strong>(Fn)。</p>
</blockquote>
<p>至于 <code>FnOnce</code>，对环境变量的访问权限这么大，还想 Copy？只能是所有权 move。</p>
<h2>一些建议</h2>
<p>如果遇到函数的参数也是一个函数，需要标注 trait 的场景，又不知道到底应该标注哪一个 trait，建议先标注 Fn ( 权限最小的 trait)，由编译器提示后再进行修改。</p>
<p>另外，闭包的所有权部分并不推荐背书，尤其不推荐总结为正交规则。三个 traits 的区别与联系在代码层面非常简单且容易分析，总结为正交规则反而是把简单的事情复杂化，而且难记。</p>
<p>如果仍然难懂，可评论提出，后续改进。</p>]]></content:encoded>
            <category domain="https://sansui233.com/categories/学习">学习</category>
        </item>
        <item>
            <title><![CDATA[PPT母版的制作与使用方法]]></title>
            <link>https://sansui233.com/posts/PPT母版的制作与使用方法</link>
            <guid>https://sansui233.com/posts/PPT母版的制作与使用方法</guid>
            <pubDate>Fri, 12 Nov 2021 00:08:55 GMT</pubDate>
            <content:encoded><![CDATA[<p>由于我需要批量编辑 PPT 的样式，但 PPT 没有组件化样式的概念，所以开始学习用母版。虽然之前也用过，但始终不明白 PPT 的迷之逻辑，有时候是调整了母版但不生效，或者调整了局部结果别的地方也被影响了……今天才大概明白了一点（还是 Figma 和 Sketch 的逻辑好懂……）所以从我的角度说一下对 PPT 的模版理解。</p>
<p>这个问题明显视频解释更好，但不太想做视频（躺）因为每次做视频前写大纲都要写好久……</p>
<p>图源 Github，图片不显示挂代理 Please。</p>
<h2>概念解释（母版/版式/主题）</h2>
<h3>打开母版</h3>
<p>母版的入口在“视图”→“幻灯片母版”。Mac 上的快捷键是 <code>command + alt + 1</code>。</p>
<h3>什么是母版和版式</h3>
<p>母版，是 PPT “主题” 的一部分，可以对多张幻灯片的排版进行统一的修改。</p>
<p>我们日常制作的 PPT，都会基于一个母版（虽然很多人不去用）。在后面的内容中，对于日常制作的 PPT，我会称为“PPT 内容”。</p>
<p>一个正常的母版包含着一个“<strong>幻灯片母版</strong>”和多个“<strong>版式</strong>”。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/Screen%20Shot%202021-11-11%20at%207.03.24%20PM.png" alt="母版结构"/></p>
<h3>样式继承</h3>
<p>“<strong>版式</strong>” 会继承 “<strong>幻灯片母版</strong>”（以下简称为 <strong>母版</strong> ）中的一些元素的样式（包括位置、字体、大小、颜色等）。也就是说，只要更改 <strong>母版</strong> 里的样式，<strong>版式</strong>也会自动更新。</p>
<p>所以是哪些元素可以被继承呢？在菜单栏里的“母版版式”中，有五个选项分别是</p>
<ul>
<li>标题</li>
<li>正文</li>
<li>日期和时间</li>
<li>页脚</li>
<li>页码</li>
</ul>
<p>以上就是所有样式可以被继承的元素。是的，你在母版上<strong>只有这五个元素的样式可以被继承</strong>。你可以尝试在“主题”选项中打开任何一个母版，会发现所有母版都是这五个元素。你无法擅自增加其他可以被继承的元素。</p>
<p>并且以上显示的每个元素在母版上都只能设置一种样式，**你无法同时给标题设置两种样式。**也就是说，如果你有设置 <strong>一级标题 + 二级标题</strong> 样式的需求，你无法通过设置 <strong>母版</strong> 上的样式实现二级标题。你只能通过 <strong>版式</strong> 去设置二级标题。</p>
<p>另外 <strong>背景</strong> 也可以被继承，但它属于在正式的 PPT 内容中不可编辑的元素。</p>
<h2>如何编辑元素样式</h2>
<p>选中元素，在“开始”选项里编辑即可。</p>
<p>通常情况下，母版的排版需要设置得尽可能通用，之后的每个版式都将以母版为基准进行编辑。母版本身并不能直接被 PPT 内容所使用，做 PPT 能选择使用的只有继承了母版样式的 <strong>版式</strong>。</p>
<h2>版式如何继承母版</h2>
<h3>继承标题样式</h3>
<p>选择一个版式（或点“插入版式”），给菜单里的“标题”打上勾。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/Screen%20Shot%202021-11-11%20at%207.35.09%20PM.png" alt="标题继承"/></p>
<p>需要注意的是，如果你在“开始”里添加一个文本框，移动到标题的位置，并不会被 PPT 识别成标题。从外面粘进来的文本框也一样，只会被识别为“一个普通的文本框”。之后批量更新标题的样式时，也并不会被更新。</p>
<p>所以在版式中设置正确设置标题的方法只有这一个——给标题打上勾。</p>
<p><strong>想设置二级标题怎么办？</strong></p>
<p>母版没有二级标题，只能用下面说的占位符实现。</p>
<h3>继承正文样式</h3>
<p>继承正文的正确方法，是点击上一节图中的“插入占位符” ，有好几个选项，一般选内容就可以了。</p>
<p>此占位符生成的文本框的样式和 <strong>母版</strong> 中完全一致。如果说 <strong>母版</strong> 的样式是全局变量，<strong>版式</strong> 中再次修改的样式就是局部变量。</p>
<p>对于<strong>修改过的部分</strong>，母版里对正文的更新不会导致版式中的正文更新。比如：</p>
<ul>
<li>母版中的正文字号是 20px</li>
<li>版式中的正文字号不变，但是给加粗了</li>
<li>修改母版中的正文字号为 22px</li>
<li>版式中的正文字号变成 22px，但仍然加粗。</li>
</ul>
<blockquote>
<p>❗️注意：不要从“开始”里新建文本框！也不要从母版界面外粘贴进来！</p>
<p>原因同上，非占位符生成的文本框，对其样式的修改并不会真正改到“正文”的样式。使用的时候就会发现了，更新版式了但 PPT 内容样式完全没更新……这种情况就是因为版式中的文本框不是占位符生成的</p>
</blockquote>
<p>所以如何实现二级标题？</p>
<ul>
<li>添加一个占位符</li>
<li>添加文本样式</li>
</ul>
<h3>继承日期和时间、页脚、页码</h3>
<p>在版式中，给“页脚”打上勾，以上三者的样式都会被继承。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/Screen%20Shot%202021-11-11%20at%2011.06.48%20PM.png" alt="其他继承"/></p>
<h2>使用版式</h2>
<p>退出“幻灯片母版”模式。在正常 PPT 内容的模式下，菜单栏“开始”中有个“版式”选项。在侧边栏选中一页（或多页） PPT，点击相应版式即可应用。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/image-20211111231429427.png" alt="使用版式"/></p>
<blockquote>
<p>如果你原来的 PPT 内容不是依靠版式中的“占位框”排版，而是靠手动创建的文本框，那直接应用版式是不会修改你原来的内容的。</p>
<p>换言之，如果想要达到批量、统一的排版效果，需要尽可能地应用版式给出的占位框，而不是手动创建的文本框。</p>
</blockquote>
<p>在“<strong>版式</strong>”选项下面一个“<strong>重置</strong>”，意思是重置到当前版式初始的样式。</p>
<p>比如，版式中的文字样式设置的是纯文本，而 PPT 内容里修改为列表。点击“<strong>重置</strong>”会使得列表项消失，再次成为纯文本。</p>
<h3>刷新修改后版式</h3>
<p>版式修改后，有时候并不会自动应用到 PPT 内容上去，这种情况通常发生于在 PPT 内容中对占位框的位置、大小等等进行了调整。</p>
<p>比如在 PPT 内容中调整过的占位框位置，将不再随着版式更新。如果需要复位（让占位框位置能随着版式更新），可以再应用一次版式。</p>
<h3>正在使用的版式</h3>
<p>对于被用到了 PPT 内容上的版式，只有一个建议：<strong>不要随便删除版式里的元素！</strong></p>
<p>这会导致已经被应用了版式的内容格式被清除……你需要去重新应用版式。</p>
<hr/>
<p>写在后面的吐槽：排版这种事情 <strong>Layout + 组件化</strong> 不香吗！PPT  的样式复用实在太局限了。看祖传的 PPT 排版看得我脑壳疼，每一页的小标题位置都不一样，字体也是用得乱七八糟的。排版的四原则，“亲密”“对齐”“对比”“重复”，每一项都很重要。但一项都不满足这是怎么做到的！强迫症（伪）哭晕在厕所。</p>
<p>其实还是祖传的习惯问题。比如 Word，小时候我也是有过一段时间空格排版居中……现在谁还空格排版居中，我见一个打一个（狗头）</p>]]></content:encoded>
            <category domain="https://sansui233.com/categories/摸鱼">摸鱼</category>
        </item>
        <item>
            <title><![CDATA[纯函数与算法]]></title>
            <link>https://sansui233.com/posts/pure-function</link>
            <guid>https://sansui233.com/posts/pure-function</guid>
            <pubDate>Sat, 25 Sep 2021 12:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>自从接触了纯函数，刷算法题刷得举步维艰。</p>
<blockquote>
<p>什么是纯函数：同样的传入参数，一定可以得到相同的输出</p>
</blockquote>
<p>纯函数又被称为无副作用的函数，不会改变外部的状态。</p>
<p>比如在 JS 中，array.slice()对数组的切片，返回的是一个新的数组，为纯函数。</p>
<p>相对的，array.splice()对数组的插入与删除是对于原数组操作，不是纯函数。</p>
<p>纯函数的意义，在于保证<strong>不会对函数外部的状态有隐式的修改</strong>。这在大型的、遍地都是状态的系统中非常重要。如果不保证纯函数，多个函数内部去修改了同一外部状态，容易出现意想不到的 Bug。</p>
<h2>图的邻接矩阵定义</h2>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/g61Yvh.jpg" alt=""/></p>
<pre><code class="language-ts">let map = {
  point: [&#x27;V0&#x27;, &#x27;V1&#x27;, &#x27;V2&#x27;, &#x27;V3&#x27;, &#x27;V4&#x27;, &#x27;V5&#x27;, &#x27;V6&#x27;, &#x27;V7&#x27;],
  side: [
    [0, 1, 0, 1, 1, 0, 0, 0],
    [1, 0, 1, 0, 1, 0, 0, 0],
    [0, 1, 0, 0, 0, 1, 0, 0],
    [1, 0, 0, 0, 0, 0, 1, 0],
    [1, 1, 0, 0, 0, 0, 1, 0],
    [0, 0, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 1, 0, 0, 1],
    [0, 0, 0, 0, 0, 0, 1, 0],
  ]
}
</code></pre>
<h2>图深度遍历的非纯函数实现</h2>
<pre><code class="language-ts">// DFS 深度优先遍历，从 第 index 个节点开始. visited 记录已访问的节点，全局共用一个 visited
function DFStraverse(index: number = 0, visited = [map.point[0]]) {
  if (visited.length === map.point.length) {
    console.log(visited.toString())
    return
  }

  map.side[index].forEach((isSide, targetv) =&gt; {
    if (isSide &amp;&amp; !visited.includes(map.point[targetv])) {
      visited.push(map.point[targetv])
      DFStraverse(targetv, visited)
    }
  })
}
</code></pre>
<p>以上代码的问题：</p>
<ul>
<li>map 定义在了外部，和别的函数共用</li>
<li>visited 是全局共用同一个，但却每次都要作为参数传入，逻辑上既不合也没有必要。并且作为函数参数（而不是全局变量），每次都对 visited 作了修改。这里还好，因为要的就是修改后的 visited（实际上是全局的 visited）。但如果题目是一个回溯问题，就需要管理 visited 的状态，在修改了之后，递归出栈时还得改回来。</li>
</ul>
<h2>图深度遍历的纯函数实现</h2>
<pre><code class="language-ts">// DFS 深度优先遍历，从 第 index 个节点开始. visited 记录已访问的节点，全局共用一个 visited
// 纯函数实现
function DFStraverse(index: number, map: { point: string[], side: number[][] }) {
  const visited = [map.point[index]]

  function traverse(index: number) {
    // 终止条件
    if (visited.length === map.point.length) {
      console.log(visited.toString())
      return
    }

    map.side[index].forEach((isSide, targetv) =&gt; {
      if (isSide &amp;&amp; !visited.includes(map.point[targetv])) {
        visited.push(map.point[targetv])
        traverse(targetv)
      }
    })
  }

  traverse(index)
}
</code></pre>
<p>使用闭包，把共用的 visited 固定为状态。内部再定义函数作递归。 map 也作为外层的参数传入，里面不去修改。</p>
<hr/>
<p>状态其实在各种算法里挺重要的。不少空间换时间的极限操作都要用到。</p>
<p>算法注定是“不纯”的，能做的也不过是用闭包来保存状态。有时候觉得，纯不纯的也没有这么重要。</p>]]></content:encoded>
            <category domain="https://sansui233.com/categories/学习">学习</category>
        </item>
        <item>
            <title><![CDATA[Github hosts 更新脚本(MAC)]]></title>
            <link>https://sansui233.com/posts/github-hosttools</link>
            <guid>https://sansui233.com/posts/github-hosttools</guid>
            <pubDate>Sat, 07 Aug 2021 04:08:55 GMT</pubDate>
            <content:encoded><![CDATA[<p>此工具已更新至 <a href="https://github.com/Sansui233/mac-githubhosts-autoupdate">Github</a>。</p>
<ul>
<li>安装卸载脚本</li>
<li>自动定时运行</li>
<li>平时不占内存，运行时几乎不占内存</li>
</ul>
<p>原文如下：</p>
<hr/>
<p>最近 Github 墙得越来越厉害了。写了个 Shell 工具，连不上的时候就更新一下。可以配合 Alfred 使用。</p>
<p>使用的 host 源来自<a href="https://github.com/JohyC/Hosts">这里</a>。其实用 SwitchHosts 更新也行，但我真的讨厌 Electron App……麻了，现在听个歌写个笔记 1个多 G 的内存就没了。</p>
<p>也可以用写成定时程序后台运行，加个 LaunchDaemon 文件就行，但，我不会打包 Mac App……文件这么散着分发也太 emmm，而且别人装起来也麻烦……</p>
<p>麻烦归麻烦还是要写的……</p>
<p>文件和说明已经上传到 <a href="https://github.com/Sansui233/mac-githubhosts-autoupdate">Github</a>。</p>
<ul>
<li>下面这个文件保存取名为 <code>hoststool</code></li>
<li>赋予执行权限 <code>chmod +x hoststool</code>。如果为了执行起来方便，可以放进环境变量的目录（比如/usr/local/bin）</li>
<li>然后就可以使用 <code>hoststool -u</code> 更新 host 了，运行结果会发系统通知。之前可以自己看看 hosts 内容有没有问题。这是有几率失败的，因为用的 gittee 的 host 源，经常会提示文件疑似违规……这种时候再请求一次就好了，第二次就不违规了。我也不知道为什么。</li>
</ul>
<p>（定时任务的部分在后面）</p>
<pre><code class="language-shell">#!/bin/bash
showHelp() {
	echo &quot;-u [source_url]	update github hosts. You can specify a custom host source&quot;
	echo &quot;-b	backup /etc/hosts to /etc/hosts.backup&quot;
	echo &quot;-r	recover hosts.backup to hosts&quot;
	echo &quot;-f	list files in /etc which contains \&quot;hosts\&quot;&quot;
}


# ====== Main =====
if [ $# -eq 0 ]; then showHelp;exit 0;fi

# CONF
download_dir=&quot;$HOME/etc/hoststool&quot;
github_hosts=&quot;https://gitee.com/yuchi-shentang/GithubHosts/raw/main/hosts.txt&quot;
if [ ! -d &quot;$download_dir&quot; ]; then
  mkdir -p $download_dir
fi

case &quot;$1&quot; in
	-f)
		ls /etc | grep hosts;
		exit 0;;
	-b) 
		sudo cp /etc/hosts /etc/hosts.backup;
		exit 0;;
	-r) 
		sudo cp /etc/hosts.backup /etc/hosts;
		exit 0;;
	-u) 
		if [ $2 ]; then github_hosts=$2;fi
		curl -o ${download_dir}/hosts ${github_hosts};
		if [ $? -ne 0 ]; then
			echo &quot;[ERROR] 获取远程 host 出错，请尝试更换 source 或检查 download_dir 读写权限&quot;
			osascript -e &#x27;display notification &quot;获取远程 host 出错，请尝试更换 source&quot; with title &quot;hoststool&quot;&#x27;
			exit 1
		fi
		
		# Validate host content length
		lines=$(awk &#x27;{print NR}&#x27; ${download_dir}/hosts | tail -n1)
		if [ $lines -lt 10 ]
		then
			echo &#x27;[ERRO] 远程 Github Hosts 无效（Gitee源不稳定），通常重试即可&#x27;
			osascript -e &#x27;display notification &quot;远程 Github Hosts 无效（Gitee源不稳定），通常重试即可&quot; with title &quot;hoststool&quot;&#x27;
			rm ${download_dir}/hosts
			exit 1
		fi

		# Remove old content
		begin=$(sed -n  &#x27;/# ==== Github Start ====/=&#x27; /etc/hosts | awk &#x27;NR==1{print}&#x27;)
		end=$(sed -n  &#x27;/# ==== Github End ====/=&#x27; /etc/hosts | awk &#x27;END{print}&#x27;)
		echo &quot;Removing old hosts. Start at line \&quot;${begin}\&quot;, End at line \&quot;${end}\&quot;&quot;
		cat /etc/hosts | sed &quot;${begin},${end}d&quot; &gt; ${download_dir}/hosts.tmp
		if [ $? -ne 0 ]; then
			## Trip Failed
			echo &quot;[INFO] 当前 Host中 无旧的 Github Host 标记可清除&quot;
		else
			## Trip Succeed, move result
			echo &quot;[INFO] 清除旧的 Github Host 标记&quot;
			sudo cp /etc/hosts /etc/hosts.backup &amp;&amp; sudo cp ${download_dir}/hosts.tmp /etc/hosts;
		fi

		# Add new hosts
		sudo bash -c &quot;echo &#x27;# ==== Github Start ====&#x27; &gt;&gt; /etc/hosts&quot; # Add github host
		if [ $? -ne 0 ]; then
			echo &quot;[ERROR] 无root权限，请尝试运行脚本手动输入密码&quot;
			osascript -e &#x27;display notification &quot;无root权限，请尝试运行脚本手动输入密码&quot; with title &quot;hoststool&quot;&#x27;
			rm ${download_dir}/hosts.tmp
			rm ${download_dir}/hosts
			exit 1;
		fi
		sudo bash -c &quot;echo \&quot;# Updated at $(date)\&quot; &gt;&gt; /etc/hosts&quot; # Add github host
		sudo bash -c &quot;cat ${download_dir}/hosts &gt;&gt; /etc/hosts&quot;;
		sudo bash -c &quot;echo &#x27;# ==== Github End ====&#x27; &gt;&gt; /etc/hosts&quot;
		rm ${download_dir}/hosts.tmp
		rm ${download_dir}/hosts

		echo &quot;[INFO] Github Hosts 块更新于 $(date)&quot;
		osascript -e &#x27;display notification &quot;Github Hosts 已更新&quot; with title &quot;hoststool&quot;&#x27;
		exit 0;;
	-h|--help)
		showHelp;
		exit 0;;
	*)
		echo &quot;Unknown command&quot;;
		showHelp;
		exit 1;;
esac

</code></pre>
<h2>定时</h2>
<p>保存以下文件为 <code>hoststool.plist</code>。</p>
<pre><code class="language-plist">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
&lt;key&gt;Label&lt;/key&gt;&lt;string&gt;hoststool&lt;/string&gt;

&lt;key&gt;ProgramArguments&lt;/key&gt;
&lt;array&gt;
  &lt;string&gt;/usr/local/bin/hoststool&lt;/string&gt;
  &lt;string&gt;-u&lt;/string&gt;
&lt;/array&gt;

&lt;key&gt;RunAtLoad&lt;/key&gt;
&lt;true/&gt;

&lt;key&gt;StartInterval&lt;/key&gt;
&lt;integer&gt;3600&lt;/integer&gt;

&lt;key&gt;StandardOutPath&lt;/key&gt;
&lt;string&gt;/Library/Logs/hoststool.log&lt;/string&gt;

&lt;key&gt;StandardErrorPath&lt;/key&gt;
&lt;string&gt;/Library/Logs/hoststool.log&lt;/string&gt;

&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>把 <code>/usr/local/bin</code> ，改成你存放脚本的路径。</p>
<p>时间间隔为 3600 秒，可以自己修改。</p>
<p>然后执行</p>
<pre><code class="language-shell">$ sudo cp hoststool.plist /Library/LaunchDaemons
$ sudo chown root:admin /Library/LaunchDaemons/hoststool.plist
$ sudo launchctl load -w /Library/LaunchDaemons/hoststool.plist
</code></pre>
<p>执行完就会立刻运行一次脚本。由于定时任务是 root 用户不是个人用户，不会有通知，可以去 Console 看 log。</p>]]></content:encoded>
            <category domain="https://sansui233.com/categories/摸鱼">摸鱼</category>
        </item>
        <item>
            <title><![CDATA[网盘目录程序比较]]></title>
            <link>https://sansui233.com/posts/网盘目录程序比较</link>
            <guid>https://sansui233.com/posts/网盘目录程序比较</guid>
            <pubDate>Wed, 26 May 2021 01:15:45 GMT</pubDate>
            <content:encoded><![CDATA[<p>比较一下私人网盘有关的程序</p>
<ul>
<li>cloudreve</li>
<li>onemanager</li>
<li>zfile</li>
<li>nextcloud</li>
</ul>
<h2>1. Cloudreve</h2>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/demo.cloudreve.org_home.png" alt="cloudreve"/></p>
<p>是个网盘程序，意思是在服务器上运行这个程序你就能成为了千度网盘的老板，可以拥有很多注册会员，还可以给他们收费，从此发家致富(bushi)。</p>
<ul>
<li>需要服务器和域名</li>
<li>文档不全，社区还行，使用方法社区找</li>
<li>是真的网盘，不是网盘列表程序，适合建站用，One Drive个人帐号不能用。</li>
<li>没事记得备份 (不知道换服务器时迁移数据麻不麻烦，反正可以用Docker)</li>
</ul>
<h2>2. One-manager</h2>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/herooneindex.herokuapp.com_Ali_.png" alt="one manager"/></p>
<p>网盘列表程序，阿里云或者 Onedrive 的网盘里的文件列出来，便于集中分享。单纯是个人分享站。</p>
<ul>
<li>serverless，不需要服务器和域名，可白嫖资本家的服务</li>
<li>README 即文档，issue 即社区。README写得像随便记的笔记，好在也不复杂都有引导</li>
<li>功能很多，除了基础的分享、预览、下载功能，可以上传重命名等进行管理(但是界面不好看导致体验并不好)。不依靠程序设定，而是把网盘里的文件作为功能性文件，挺方便的，再次部署时不用迁移任何数据</li>
<li>可以预览的文件格式很多，没什么bug</li>
<li>界面比较丑，前台可以换主题。但好看的功能不全，后台不能换主题(强行要换也是可以但可能功能不全)。</li>
</ul>
<h2>3. zfile</h2>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/zfile.jun6.net_.png" alt="zfile"/></p>
<p>是网盘列表程序，同 One Manager。</p>
<ul>
<li>需要服务器和域名。但看情况也许可以 Serverless ？不清楚Java</li>
<li>有文档，README说得很清楚，不用一脸懵逼找社区</li>
<li>功能不多，基础的分享、预览、下载功能，前端好，交互体验好</li>
<li>文件预览有Bug，OneDrive的视频流经常加载不出来，FLV会一直加载失败。但，好看是真的</li>
</ul>
<p>开发者是98年的(暴击)</p>
<h2>4. nextcloud</h2>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/top-homeimage@2x.png" alt="nextcloud"/></p>
<p>个人网盘程序，和Cloudreve一个性质的。很多插件，交互是最好的，也比较耗资源，适合家里获团队用。</p>
<p>external storage 装起来复杂，不好白嫖资本家。</p>]]></content:encoded>
            <category domain="https://sansui233.com/categories/摸鱼">摸鱼</category>
        </item>
        <item>
            <title><![CDATA[m3u8直播流实时录屏小记]]></title>
            <link>https://sansui233.com/posts/hslrecord</link>
            <guid>https://sansui233.com/posts/hslrecord</guid>
            <pubDate>Wed, 12 May 2021 15:16:44 GMT</pubDate>
            <content:encoded><![CDATA[<p>最近由于发现自己想回看的直播会被剪镜头，所以下定决心以后要学会录屏。但本人有强迫症，一般的录屏软件满足不了我的需要，主要是：</p>
<ol>
<li>会录出鼠标操作、网络卡顿、水印等影响观感的画面</li>
<li>由于显示器和录屏软件的和原视频帧数可能不同步的问题，非常容易造成画面卡顿</li>
<li>体积远大于原视频，二压后画质失真重</li>
</ol>
<p>通常来讲，能拿直播时的视频流就别真的屏幕录制。本来视频分段就都在缓存里，应该是有比较容易实现的办法做到实时保存的才对。</p>
<p>本文主要分为以下三个部分</p>
<ul>
<li>m3u8简介</li>
<li>保存视频分段与合并</li>
<li>DRM 版权保护问题</li>
</ul>
<h2>m3u8简介</h2>
<p>目前的各大流媒体平台视频（不管是直播还是回放）大多都会把视频切片为很小一段，长度可能10s左右，通常是.ts后缀的文件。而这一堆.ts文件的索引文件为m3u8文件。</p>
<p>一个通常的m3u8文件是如下格式</p>
<pre><code class="language-text">#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:10.000000,
#EXT-X-PRIVINF:FILESIZE=3192240
https://website/xxx-00001.ts
#EXTINF:10.000000,
#EXT-X-PRIVINF:FILESIZE=3206904
https://website/xxx-00002.ts
#EXTINF:10.000000,
#EXT-X-PRIVINF:FILESIZE=2576164
https://website/xxx-00003.ts
</code></pre>
<p>也就是说，如果我们实时保存流媒体平台的视频，正常情况下，会保存一个.m3u8索引文件，和一堆.ts文件。有了这些文件我们可以直接使用支持m3u8的播放器（如IINA、VLC）进行播放。</p>
<p>m3u8是 HLS(HTTP Live Stream) HTTP直播流格式的基础。</p>
<h2>保存视频分段与合并为MP4</h2>
<p>工具准备：</p>
<ul>
<li><a href="https://www.ffmpeg.org/">ffmpeg</a>：强大的命令行视频处理工具，网上有很多安装教程，这里不重复</li>
<li><a href="https://chrome.google.com/webstore/detail/%E7%8C%AB%E6%8A%93/jfedfbgedapdagkghmgibemcoggfppbb">Chrome插件-猫抓</a>：资源嗅探插件，下载需要科学上网</li>
<li>一个多线程的下载器（为了下载速度更快），如 aria2，网上有很多教程，这里不重复</li>
<li>一个支持<strong>使用正则表达式批量替换文字</strong>的txt编辑器，如sublime、vscode</li>
</ul>
<p>以上方法会比较硬核，傻瓜式的方法可只准备下面这一个</p>
<ul>
<li><a href="https://www.hlsloader.com/">Chrome插件-Stream Recorder</a>：傻瓜式HLS一键保存插件，下载需要科学上网</li>
</ul>
<h3>方法一：下载所有分段并合并（稍硬核）</h3>
<p>首先打开一个视频网站，这里以优酷的综艺为例。<br/>
打开后点击右上角的猫抓插件，会看到一个m3u8文件，和一堆ts文件。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/1240.png" alt="猫抓.png"/></p>
<p>首先我们可以先点下载按钮下载到本地 .m3u8 文件。</p>
<p>猫抓插件提供了对m3u8的解析，点击文件旁的放大镜就可以看见。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/1240-20210512174624858.png" alt="image.png"/></p>
<p>复制所有的内容，放到支持多线程的下载器里下载。</p>
<p>下载完成后，先整理一下本地的文件目录成如下</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/1240-20210512174641967.png" alt="本地文件"/></p>
<p>（为了看起来更清晰，以上各个文件名我已修改）</p>
<p>然后修改m3u8文件。我这里使用的编辑器是vs code。</p>
<p>m3u8文件里的原链接是这样的：</p>
<pre><code class="language-text">https://valipl-vip.cp31.ott.cibntv.net/67756D6080932713CF4E/0300609724C6163EBF1C35DAC076221D-4673-49D8-A932-70FA-00001.ts?ccode=0502&amp;duration=6237&amp;expire=18000&amp;psid=28ae2c9bf869cf6f9ae28c814098b5fe43346&amp;ups_client_netip=3b4081be&amp;ups_ts=1620641730&amp;ups_userid=300380294&amp;utid=Xd0WGHofZhACAXtwDp2%2BGj22&amp;vid=XNTE0MDg5MTgyOA&amp;sm=1&amp;operate_type=1&amp;dre=u38&amp;si=78&amp;eo=0&amp;dst=1&amp;iv=1&amp;s=cbcad844c5894d209b9f&amp;type=mp4hd3v3&amp;bc=2&amp;hotvt=1&amp;t=d91e686d230165f&amp;cug=1&amp;rid=20000000DC17B06335EBB96917703D4A6B2DA12102000000&amp;vkey=B84707ca23f9e5899f9b0b9d97e4d1851
</code></pre>
<p>非常的长。我们首先要做的，是去掉每一行 <code>?</code> 之后的所有字符。使用正则表达式批量替换，在查询里输入<code>\?.*?\n</code>，替换为 <code>\n</code> 。注意要勾选正则表达式的符号。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/1240-20210512174711034.png" alt="replace query"/></p>
<p>然后要替换的是<code>https://...</code>内容，替换为本地的文件路径，让最后的剩下文件名指向本地的文件。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/1240-20210512174718097.png" alt="替换本地文件.png"/></p>
<p>替换后的.m3u8文件是这样的</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/1240-20210512174727634.png" alt="m3u8文件"/></p>
<p>此时可以使用支持m3u8的播放器打开m3u8文件，观看是视频能否正常播放。</p>
<p>能正常播放后，使用ffmpeg合并为mp4，不用转码速度就很快</p>
<pre><code class="language-shell">ffmpeg -i index.m3u8 -vcodec copy -acodec copy output.mp4
</code></pre>
<p>完成</p>
<h4>缺点</h4>
<p>对于回放的完整视频文件，通常会提供m3u8索引文件，但对于直播通常是没有m3u8索引的。这时候依然可以按上述方法下载所有分段，用ffmpeg进行合并。</p>
<p>但是直播时无法一次获取到所有ts的链接，而是边播边给。就算猫抓能批量复制链接，但为了防止直播时出什么意外（比如浏览器无响应了、突然断电），看一会儿就得存，无法好好享受直播，最后上千个文件的列表，也变得很麻烦。</p>
<h3>使用 Stream-Recorder插件 傻瓜式保存</h3>
<p>上一个方法的所有步骤，其实都能用这个插件搞定</p>
<ul>
<li><a href="https://www.hlsloader.com/">Chrome插件-Stream Recorder</a>：傻瓜式HLS一键保存插件，下载需要科学上网</li>
</ul>
<p>使用上也很简单。视频播放开始后，点击这个按钮就行了，自动保存视频分段，同时合并为一个mp4。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/1240-20210512174735807.png" alt="Stream Recorder.png"/></p>
<p>简单介绍一下，这个插件主要有三个模式</p>
<ul>
<li>Live：实时获取直播时的ts分段，可以没有索引文件自动合并</li>
<li>HLS：看回放时获取ts分段，可以没有索引文件自动合并。但是像B站这种用m4s非标准HLS的似乎用不了。</li>
<li>Capture：实时获取正在播放的HLS，直播回放均可，大部分视频格式都能用，兼容性最好。缺点是真的要一直播着。</li>
</ul>
<p>也就是直播时使用Live抓取或Capture录屏，且可以自动合并视频音频，相当于直播时边看边存。</p>
<p>看回放时使用HLS或Capture保存视频。</p>
<h2>DRM 版权保护问题</h2>
<p>并不是所有的m3u8视频都能这么下载，有的经过了DRM(Digital rights management)的保护。这样的视频下载下来也是无法直接合并的。</p>
<p>有版权保护的视频，使用猫抓查看m3u8解析时，可以发现这么一行</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/1240-20210512174747126.png" alt="DRM m3u8.png"/></p>
<p>Stream Recorder 也不支持加密视频的下载。</p>
<p>解密不在讨论范围内（我也不会），总得来说还是尽量支持正版。</p>
<hr/>
<p>PS：目前风气真的太严了，如果不是发现片段被删减，也不会想到去研究怎么录屏。既然花了钱买了相应的单场直播，也说明了会提供回放，要求拥有一个和直播时相同的回放个人觉得并不过分。最终给一个删减版，感觉这服务有些不值得，即便直播和录屏混剪都得给剪出来一个完整的版本。</p>
<p>PPS：明白大环境，没有全指责流媒体平台的意思。</p>]]></content:encoded>
            <category domain="https://sansui233.com/categories/摸鱼">摸鱼</category>
        </item>
    </channel>
</rss>