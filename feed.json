{
    "version": "https://jsonfeed.org/version/1",
    "title": "Sansui's blog",
    "home_page_url": "https://sansui233.com",
    "feed_url": "https://sansui233.com/feed.json",
    "description": "记录学习和生活的个人博客",
    "author": {
        "name": "Sansui",
        "url": "https://sansui233.com/about.ico"
    },
    "items": [
        {
            "id": "https://sansui233.com/posts/2023-09-29-windows-system-chinese-fonts-adjustment",
            "content_html": "<blockquote>\n<p>以下仅适用于低于 4k 缩放 200% 的显示器</p>\n</blockquote>\n<p>微软雅黑作为随着 Windows7 出现的字体，加上遥遥领先（？）的 ClearType，在当时的 1080p 显示器上十分清晰易读。但如今的显示器分辨率越来越高，旧版微软雅黑的设计存在着明显的缺陷。一是其字形设计并不平衡，中宫过大，有的字形可以以难看来形容；二是微软雅黑字形只在4K屏上有着准确的显示。如果你不巧像我一样用着2.5K屏，在ClearType的加持下，仔细观察资源管理器侧边栏中，“桌面”二字短横的间距并不平衡。</p>\n<p>微软曾经设计过“另一版的微软雅黑”，即 Noble Scarlet，但不知出于何种原因并没有在正式的系统中使用。这一版字体设计依然中宫偏大，但相对老版收敛了不少，平衡了一些。据传言汉字部分是兰亭黑Pro。但这个字体在标点处理上很差，最直观的就是中文引号，太像西文的处理方式，很难看出前引号与后引号的区别。其实我在写这一篇文的时候，换了 Typora 的字体，才发现前后引号全打反了……</p>\n<p>个人推荐的配置和工具如下：</p>\n<ul>\n<li><strong>Noble Scarlet</strong>  替换系统的微软雅黑。由于版权原因无官方公开链接，需自行搜索</li>\n<li>系统字体替换工具：自行搜索 “字体替换工具 by 随风飘扬”。win7 时代的产物，太古老了找不到原作者出处。替换完后最好重启，否则可能有一些错误，比如字体大小错误。另外，github 上还有一个非侵入式的系统字体替换工具 <a href=\"https://github.com/Tatsu-syo/noMeiryoUI\">noMeiryoUI</a>，但是换不全，只是作为预览不同字体在系统上的效果倒是个很不错的工具。</li>\n<li><a href=\"https://www.mactype.net/\"><strong>MacType</strong></a> 改善 ClearType 丢细节带来的不平衡</li>\n<li>安装一个 <strong>苹方</strong>。有一些中文网站 Fallback Font 也是苹方在前。由于版权原因无官方公开链接，需自行搜索。浏览器对于字体的渲染不受 MacType 的影响，在PPI不足的情况下，浏览器的渲染是偏细的，默认设置还得是微软雅黑。</li>\n<li><strong><a href=\"https://source.typekit.com/source-han-serif/cn/\">思源宋体</a></strong>：推荐将浏览器的 Serif 字体设置为此字体。默认的宋体真的，不论中文英文，都很丑……只适合打印。</li>\n</ul>\n<p>苹方是一款设计上很优秀的字体，但它对于低 PPI 的显示器不友好，人话说，不是4K屏缩放200%都别用。首先苹方粗体相对其他黑体本身就较细，在ClearType下，苹方被削掉的细节使得其字重偏小，Bold 看起来像 Medium。另外，苹方在2.5K屏上表现非常糊，毕竟苹方问世时已经 Retina 屏已经出了好久了，人家压根没考虑过在低 PPI 屏幕上的表现。最后是版权问题，当然苹果大概不会因为这点事起诉个人用户。</p>\n<p>更纱黑体也非常适合作为 windows 的系统字体，在1080p 和 2.5k 下都能保证良好的清晰度。相比起微软的两款字体，更纱黑体可以称得上是秀气了，但汉字覆盖率不如系统级别的字体。自己看下来，更纱黑体与思源黑体设计的细节不太统一，比如“用”字明显矮了一截，使句子看起来不太稳定。但是在宋体设计上，“用”字矮的这一截反而让字体看起来平衡。一个系列的字体的统一感和比例关系又很大，个人理解为思源/更纱系列是优先考虑宋体的字形，但也不是传统的宋体字形，和黑体的比例有一定的结合。整体而言还是宋体的设计更加优秀。</p>\n<p>思源黑体作为更纱黑体的前辈，是不太适合低 ppi 屏的，它的 Regular 字重看起来像 Bold。</p>",
            "url": "https://sansui233.com/posts/2023-09-29-windows-system-chinese-fonts-adjustment",
            "title": "Windows调整之中文字体",
            "summary": "让 windows11 字体更好看的一些设置与字体浅谈",
            "date_modified": "2023-09-29T02:25:44.000Z",
            "date_published": "2023-09-29T02:25:44.000Z",
            "tags": [
                "工具"
            ]
        },
        {
            "id": "https://sansui233.com/posts/2023-09-26-minecraft-settings-for-v1-20",
            "content_html": "<p>在 Minecraft 1.20 版本光照引擎被大幅改写，使得帧数提升，模组的数量似乎又多了起来。另外在 fabric 发展起来以后，mod的社区生态有了很大的变化，有很多老牌模组有了更新的替代。现在记录一下实现常用的基本功能需要的模组与修改设置。</p>\n<p>我使用的 hmcl 启动器，在其中进行模组下载可显示模组间的依赖情况。以下内容在1.20.1中完全兼容，且项目均在维护中。</p>\n<h2>Mods</h2>\n<p>使用以 fabric-api 构建的模组。</p>\n<h3>渲染类</h3>\n<ul>\n<li>Sodium: 渲染优化之神，许多模组的前置</li>\n<li>Sodium-extra: 渲染优化之神的扩展，相应 GUI 为reeses sodium options</li>\n<li>Lithium: 原版机制的算法改进</li>\n<li>Iris: Sodium 加光影</li>\n<li>Custom Entity Models: 自定义实体模型，增强对 optifine 材质包的支持</li>\n<li>Continuity: 无缝纹理，安装后需要启用相应的材质包</li>\n<li>Indium: 许多模组的前置，提供 Fabric Rendering API的支持</li>\n</ul>\n<h3>功能类</h3>\n<ul>\n<li>modmenu: 显示所有模组和相应的设置页面（如果有的话）</li>\n<li>carpet: 单人生存必备，可使用命令放置假人以常加载区块刷红石</li>\n<li>tweakeroo: 一系列微调的小功能。主要使用 freecamera（灵魂出窍）以获得更好的摄影视角，zoom 开启类似 optifine 的按 c 视角放大，handrestock 可自动补货手里的工具、方块</li>\n<li>JourneyMap: 小地图，降肝度必备。Xae 的小地图也不错，两者都需要设置一下显示的东西，默认会非常多，我只开启了玩家、时间、坐标。关闭了各种网络显示和生物显示。</li>\n<li>Invertory Profile Next: 高版本的 R 键背包整理，强迫症必备。另有捡物品时默认扔到背包中，以及在打开箱子时使用滚轮移动物品，个人非常喜欢，更快，且减少食指的腱鞘炎。</li>\n<li>Roughly Enough Items: 物品搜索，查看合成配方、查看方块用途，ctrl点击后快速移动到合成台。尽管原版有合成书，但一页条目显示太少，且不支持拼音搜索，不支持模组物品。REI依旧方便很多。</li>\n<li>imblock: 输入法冲突修复</li>\n</ul>\n<h2>设置</h2>\n<ul>\n<li>画面尺寸: 1920*1080@60fps，窗口化</li>\n<li>视场角: 85</li>\n<li>鼠标灵敏度: 75</li>\n<li>模拟距离：8</li>\n<li>渲染距离：10</li>\n</ul>\n<h3>快捷键修改</h3>\n<p>首先把 ctrl 改到 capslock 键位，方便疾跑。系统全局 powertoys 改的（吐槽一万句control的键位）</p>\n<ul>\n<li>tab 长按: 快速显示背包中物品，在 tweakroo 中的 hotbarswapbase 设定</li>\n<li>tab+1/2/3: 快捷键切换到背包中下一行。 tweakroo 中的 hotbarswap 每一行单独设定</li>\n<li>j: 显示 jouneymap 小地图</li>\n<li>m: 显示 jouneymap 大地图和设定</li>\n<li>v: 切换第三人称视角，很常用的功能。原本是f5，实在太远了</li>\n<li>f5:  灵魂出窍，在 tweakroo 的 freecamera 中设定</li>\n<li>z: 望远镜，在 tweakroo 的 zoomactivate 中设定</li>\n</ul>\n<h4>合成台、箱子UI</h4>\n<ul>\n<li>y: REI 查看光标下物品的配方</li>\n<li>u: REI 查看光标下物品用途</li>\n<li>ctrl + 左键点击REI的物品，移动物品到合成台</li>\n<li>r: Invertory Profile Next 整理。按 r+c 在 IPN 的设置中修改</li>\n<li>使用滚轮以在背包和箱子间移动物品，按shift移动整组</li>\n</ul>\n<h2>光影</h2>\n<ul>\n<li>BSL v8.2.04，默认配置High，把 Camera 中的 Bloom 关闭，把 Atmosphere 中的 fog 调到 0.5，开启 lighting 中的handDynamicLight。抗锯齿的TAA随便开不开，取决于风扇响不响</li>\n<li>Complementary Reimagined，默认配置 medium，high 会开启镜面反射运算量明显变大</li>\n</ul>\n<h2>材质</h2>\n<ul>\n<li>任意矿物发光材质。比如 <a href=\"https://www.curseforge.com/minecraft/texture-packs/new-glowing-ores\">New Glowing Ores</a>。主要是因为 BSL 光影没有矿物发光，所以要加一个材质以确保有 fallback。</li>\n<li><a href=\"https://afdian.net/a/Nan2uu\">彩虹像素</a>，非常优秀的免费猛男材质包，原版风但更精致。有很多更可爱的附加包。</li>\n</ul>",
            "url": "https://sansui233.com/posts/2023-09-26-minecraft-settings-for-v1-20",
            "title": "Minecraft v1.20常用设置",
            "summary": "一些自用的Minecraft高版本常用设置",
            "date_modified": "2023-09-26T02:38:09.000Z",
            "date_published": "2023-09-26T02:38:09.000Z",
            "tags": [
                "游戏"
            ]
        },
        {
            "id": "https://sansui233.com/memos?id=2023-09-08",
            "content_html": "<h2>2023-10-02</h2>\n<p>这几天在画绿蓝的同人漫画。原作者笛子Ocarina一直是我非常喜欢的作者，第一次看到她的作品，五个字能够形容我对她的作品感受：“温暖而深刻”。即便之后看了她很多脑洞大开的、狠狠发刀的作品，依然是这样的印象（下面是长达两千字的笛吹）。</p>\n<p>绿蓝是火柴人漫画。笛子一直以内容为主，火柴人在相应内容下表演细腻而恰到好处。可能没看过的人无法理解，会说“火柴人怎么还能看出区别？”。但看了之后会知道，在这么极简的画风下，一个像素的改变都会改变火柴人的灵魂。而且虽然人火柴，但其实体积、透视、分镜、镜头内的人物场景关系、氛围情绪的渲染，这一套语言体系是非常全面的。笛子也很注重下拉式排版的节奏，能让人舒适阅读每一句话，即便有大段的文本读起来也非常轻松。很多东西也是自己去画的时候才观察到的，尽管有刻意模仿，但仍然很难做到她那样的程度。</p>\n<p>内容一直是她的优势（至少曾经是，因为她现在没灵感几乎不画了），绿蓝不是一个故事，短篇、中篇、长篇都有，对于三者我只能说，全都非常推荐。短篇大多是有趣的梗，偶尔看一看，人给笑死。中篇是一些独立故事，代表作是在介绍中写着的回忆篇。长篇就是机器人篇和魔王篇了，是加入了计算机元素的日常。机器人篇大概是讨论的人最多的，大概就是小蓝把暗恋的同事的模样，做成了一个带有半自主意识的机器人后发生的故事。目前剧情进展已经比较成熟了，成熟到笛子已经写不下去了（苦涩）。如果要做成单独的独立作品，其实机器人篇应该接近完结了，剩下的日常以番外发布就好。但绿蓝本身就是日常漫画，也没有专门声明某一系列完结的必要性。</p>\n<p>绿蓝部分已动画化，第一季的动画非常优秀，篇幅也够长。第二季是屎。第一季的片头是非常非常喜欢的片头，里面没有一个镜头是从正片剪辑的，而是一个短暂的mv，描述了小绿和小蓝是两位演员，在不同的故事中扮演着不同的角色，他们之间有无限的可能性。</p>\n<p>笛子早期的作品比较肝是《你瞎》（全名：你什么都没看见），脑洞非常非常大。也是最开始以中短篇为主，后面慢慢发展出了一个中长篇的故事（有点像卡片式笔记的创作思路，Ne人实锤）。中长篇的故事已经完结，个人感觉也还不错，更倾向于青少年时期的灵感大开。到画绿蓝时，对现实的映射多了很多，我特别喜欢这个时期的作品，是会让人感到“温暖而深刻”的作品。</p>\n<p>另外，笛子不是签约作者，她是自由的，也就是不会在没有灵感的时候去硬凹出一般的作品去交稿，也可以看出她是一个对自己作品要求很高的人，能保证她已有作品的质量。但同时缺点就是现在这种情况，容易开天坑…………她没有完结的IP，或者说，她在创作时并没有做让一个IP完结的准备。我并不是说她的长篇作品没有完成度，相反，其实长篇连载的部分完成度都已经到了一个小的完结点，主要矛盾已经解决了，只是让人感觉，“接下来还有故事可讲吧”。但是她也没想好，她是从无数小故事中抽离出了这么一两个中长篇的故事，但更长、更稳定的故事框架是无法用这种方式写的，需要找出故事的下一个矛盾点，然后围绕这个点讲故事，这对于画日常漫画来说是非常难的。类似的例子可以看罗小黑，罗小黑在做大电影前也是零散中出设定，但第二季讲故事开始就非常集中了，非常好看，也显得没有从前那么日常了。</p>\n<p>笛子从她几年不更突然冒出来更新一个魔王篇就能看出来，她很想补全设定，为魔王篇接下来的故事做准备。魔王篇是一个明显没讲完整的故事。但很也很明显，她没能想出来她满意的发展路线……中短篇在后期的缺失也表明灵感在渐渐消失。AI绘画火的那一阵她也有拿绿蓝出来画过，和从前一样也是对现实的映射，但总体没什么脑洞，有一种极力想画点什么但再也画不出的遗憾。这个东西就是想象力吧。当人对现实世界了解地越多，越会缺少一些想象。</p>\n<p>但我依然很羡慕她，因为我是一个从小就完全没有一点想象力的人，我写出的一切我都得知道我在哪里看过，我借鉴了什么东西，就好像我画画一定要按部就班掌握了所有的基础才会有自我创作的想法。我也不理解怎么有人在不知道要写什么的情况下，可以编出如此细节的非现实故事，简直就像是魔法。后来发现其实有一大部分剧作家还是在基于已有的参照写剧情，只不过代入经验与情感，在时间的磨炼也能写出很厉害的作品。但那些以年轻时的想象力与恣意姿态写的作品永远却有一种旁人无法的特殊，个人风格从一开始就注定，后续所做的只是让它变得更成熟。</p>\n<p>在想剧情时，我体会到了什么叫“写作就是把你整个人的一部分完整展现出来，逃都逃不掉”。画画相对是可以不需要自我的，但写作是一定受自我影响的。绿蓝中所有不以吐槽为目的故事都有一个特点——两个主角都不会做出令人讨厌的事，他们很可能完全没有矛盾，但故事依然精彩。即使他们有矛盾，但都不会让观众感到是其中一方有什么过错，是温柔且真实的。但我在处理二人关系时，为了对话有张力，会写出连自己都非常讨厌的人设，就类似于蹩脚的作家写不出剧情张力就强行安排人吵架一些，或者为了让剧情保持矛盾，观众在上帝视角，主角就没 眼睛没耳朵。我所看见的、经历的矛盾，全是一些连自己都厌恶的相处方式，没有两边都温柔的调和。我无法抽离出任何让两方都好的一面，始终觉得，只要任何一方是正常的，矛盾就消失了，故事性也随之消失。全员天使的发展，写不出来。不过其实对于描写爱情，倒是写单恋就很容易做到这一点，但我没有这种经历，看再多作品，也不能切身体会他们的心情。要么很快没感情，要么很快变双向……现实中真的没有去喜欢一个完全不喜欢自己的人的必要吧，类似于没有人会为了你直的硬掰弯，和性别无关，性格不适合的就是不适合。单恋人的受挫能力不得不说，好强的。</p>\n<p>我会有这样的天赋论，因为与写作、画画相对的，写歌就不是这样的感觉，能明显感觉在这方面会比较有天赋，好像从小学开始就知道怎么自创旋律，即便只听过那么一点点的歌，也能很好地衍生，学琴的是也是在同样时间条件下学得最快的那一个。在初二的时候，我从没有弹过钢琴，但是在音乐教室，课前和学到8级的同学轮流摸琴弹梦中的婚礼，有一个女生说觉得我弹得比较好，可能她已经忘了，但我记得。再后来，我刚开始接触电音时，并不能 Get，也不是很喜欢，我接触到纯粹是因为便宜，写出的东西我也不是很喜欢，现在看来也有很大的改进空间，但就当时的条件而言，倒也没有很烂，也是得益和群友交流（妈的怎么总在混只有我是女生的群）。后面喜欢日系了之后，弹琴更是喜欢随意弹不好好练（。技术不够会限制原创的水平，所幸技巧上对于绝大部分的流行歌，都足够了。但音乐总体而言是一个非常废钱的爱好，特别是纯器乐，编曲还废电脑。如果当时我不是为了屏幕买Mac，说不定不会画画，而是会一直编下去。</p>\n<p>还有很多时候，总觉得人真的会渐渐忘掉曾经的经历与情感。又或者说是，其实小时候大家对于阶级差一类的没什么感觉，但是当能体会到阶级感的一刻起，就会变得无法包容言论差异了。一般而言，受过更多教育的人看问题是更全面的，包容性也更强，但反而是这样的包容性，会被别人看成是一种 privilege，他们无法理解这是privilege，其实也正是一种privilege。举例而言，汉服圈，有的人会觉得“为什么复兴贵族汉服而不复兴平民汉服”，对汉服有研究基友说，古代汉服的形制不分“平民”还是“贵族”，只是用料、工艺、纹样上的不同，不会出现只有贵族能穿而平民不能穿的形制，也没有贵族绝对不会穿的形制，现代人穿的汉服通常看起来“很贵族”，只是因为大家喜欢看好看的。这是实话，毕竟我也买，我买的就看起来很穷酸，妈看了都说别穿了。但是翻一翻b站，就会发现，以“看起来贵不贵”来区分是贵族汉服还是平民汉服的人占了绝大多数很多。基友觉得这些人有毛病，不了解非要来她评论区横插一脚。但我看了一下其实能理解，我第一眼也没注意他们在说什么，但是语气上会觉得基友不太友善在原po下面抬杠，但实际情况是不太友善的基友是在给互关好友评论并赞同彼此的观点，这是属于她们的privilege，无法正确了解情况的人没有参与的资格。她们也许会知道别人不了解，但也只是觉得总是遇到智障来冲评论区并默默吐槽。另外她混汉服圈比较多，会关注到一些我没注意到的事情，比如，额，好多人认为“大唐文化在日本”？她觉得是，我觉得不是，我觉得至少任何一个学过中学历史的人都不会这么认为，不然得反思一下历史怎么教的了。但她说，她妈就是……我依然不信，我妈也不这么认为，可能这又是我的privilege了。还有什么，京城满遗太多，所以发展不起官方汉服宣传。嗯这个我还是挺赞同的，什么地方有阻力什么地方没有，在京这么久没有政治觉悟的也得逼出来一点，京圈在大城市中真的算得上是文化荒漠，大家能融入到一起靠的是淡化文化差异，而不是包容文化差异。不过，在国内，我也没见过什么地方非常包容文化差异的就是了，这样的地方是真的存在的吗。</p>\n<hr/>\n<p>风格不是硬生生的技法，而是技法的组合正给人的直观感受</p>\n<h2>2023-09-21</h2>\n<p>草，突然刷到 <a href=\"https://www.applegamingwiki.com/wiki/Game_Porting_Toolkit\">GPTK</a>，可以在mac上直接运行windows游戏，有 Steam 和Epic 的教程。总觉得有亿点点魔幻。</p>\n<p>然后b站搜了一圈，前几个月就已经有人拿来运行赛博朋克2077和原神了……7瓦的GPU玩高画质原神，嗯更魔幻了……</p>\n<p>翻译一下：<a href=\"https://www.applegamingwiki.com/wiki/Game_Porting_Toolkit\">Game Porting Toolkit(GPTK)</a> 在 Wine 兼容层的基础上结合了苹果自家的D3DMetal，支持了 DirectX11 和 DirectX12 的游戏。但是用了反作弊驱动或DRM（版权保护相关的技术）的游戏通常没法运行。</p>\n<p>D3DMetal具体是个什么东西没搜到介绍，果子特色闭源，只能从名字上看出来是微软D3D到苹果Metal的直接转译。</p>\n<h2>2023-09-20</h2>\n<p>感觉需要扩大圈子，以免赛博社死……很奇怪，被夸会让我感觉负担很重，因为总觉得期望越大，失望越大，特别是当我觉得其实我所做的一切好像还有很多改进的地方并不值得被夸的情况下。当会受到越来越多的关注时，我就不自觉地想把这件事情停止了。明明知道经营个人IP和流量是当今社会下至少可以用作副业的路，但性格和想法完全背道而驰（笑）。要担得起个人形象，要学的越多；要学的越多，越觉得真正厉害的人都不是经营出来的。经营出来的只会给人一种华而不实的印象，算了吧。</p>\n<hr/>\n<p>这是一个长达半年的几乎什么也没做的时期。我开始回想一些仿佛发生在上辈子的事情，虽然不过也只是过去了三四年。如果说人一辈子都是江山易改，本性难移，那这三四年已经让我进入了下辈子。</p>\n<p>我第一次感受到什么是PTSD是在2019年的1月，只用不到一个周，听到某个人的名字就会应激、看到和某个人相似的长相就很恶心，提也不想提一句。起因无非是新环境的价值观不合一类的惯谈。如今连找工作都是双向的，但上学不是的，没有实习，没有试错的机会，周期很长，选择主动退出就是异类。就好像18岁前禁止恋爱，一上大学开始要求擦亮双眼找对象结婚生娃一样。本科专业是自己选的，不然在本科期间读不感兴趣的东西可能会发疯，也不知道是幸运还是不幸。</p>\n<p>大学开学时，俞敏洪来开学演讲，顺带推荐了一本书，就是吴军的《浪潮之巅》第二版。这确实是一本对行业历史介绍不可多得的好书，但一定角度上也是对于如今的互联网感到悲观的来源。书中的预言现在来说失效了许多，充分映证了人其实没有办法用发展的眼光看问题，因为人无法准确预测未来，开放的架构在走向封闭，互联网精神终归只是程序群体的幻想，人还是得吃饭。</p>\n<p>第二次感受PTSD是现在，只要一听到类似于“迁移学习”“数据增强”“Loss优化”“面试xx”一类的词，就会感到一股油然而生的厌烦。这很矛盾，因为我自己平时也常常把专业名词挂嘴边，但听到别人闲聊时说到这些就会烦到突破天际，而当别人带着一腔对AI领域的热爱来交流这些时我更烦了，但又不得不交流，一种堪比坐牢的体验。我对AI的烦从专业本身开始蔓延到了生活中，在大家都在吹大模型大数据新风口时，我边用边骂。很少出现好用的产品不想了解原理只想骂的情况。是什么原理呢？Transformer + 钞能力……目前没有一家公司能复现 OpenAI 的效果，这个东西从出生的那一刻起就是充满随机性的黑盒。「哔~ 您的丹炉天赋不足，建议回炉重造」即便AI真的是很火，现在好好研究一定能吃上饭，我也不会想在这里多呆一分钟了。</p>\n<p>想转专业的人又得成绩好，成绩好的人又得是想在自己专业有所成就的人，考王除外。况且在一个本来就很卷的专业，努力考前几名就为了转去一个排名差很多的专业，大部分人看来都是脑子进水。我不是一个会考试的人，不管题难还是简单，我永远都是差不多的分数，因为没有人会像我一样在碰上极简单考题的情况下靠着算错丢掉 30 分，在题很难全年级挂一半人时又因为没算错太多考90分。考研的专业课也差不多，很简单的题，但差点不及格，排名远不如平时成绩排在我后面的室友，纯靠那一年运气好录取线低考上的。总体而言，考试、刷题对我来说是一件很无聊很枯燥的事，我之所以会做题因为题库无穷无尽总有一些不会的东西，我想能理解到全部。但精准套公式算结果，精准地记住每一个时间点，记一大堆三纲五常，非常不擅长。</p>\n<p>我曾经在毕业后做ACG，但现在感觉确实太天真了。我不了解二次元，比起混圈只想好好画画。朋友说你可以从头引流接单的，现在画哈基米就可以赚钱，但我无法商业起来。我难以想象为了赚钱而每天花时间在重复固定的风格和题材上，明明最开始画画是发展副业，但越到后来越挑，同一种风格和完成度的极限是三张图，后来不满意这种画法又开始补基础。有时候真觉得以现在能接触到的资源已经做到了极限，即便曼奇助教说你画得已经比我的很多学生好了，但是学生永远还是学生，之所以是学生而不是助教就是因为水平不够。再之后必须要花很多钱和时间抛弃现在的一切去进修，并做好三年纯支出没有一点收入的准备。那时候就三十岁了，已经没有这个时间让我去耗了。家里是很普通的工薪阶层，父母在他们各自的同期同学里都算是混得最差的。我能做的只有独自坚持，没法向他们要求什么，也无法乞求他们能理解我。至少我的父母都在世，已经是万幸了。</p>\n<p>不想打字了，现在很混乱，很久没看过文学作品，句子都老长老长的，还喜欢用英文句式。又草草了事了，有空再说吧的很开心没有人关注我。说实话真的有人告诉我他订阅了时我第一反应是吓一大跳。</p>\n<h2>2023-09-15</h2>\n<p>写 md 渲染时无数次考虑重构……封装好的轮子真是好难用，插件生态的版本不一致，光是处理接口一致性问题就要吐了。不管了先加再说。</p>\n<h2>2023-09-14</h2>\n<p>哇其实雨疏发招聘消息过来时真的会有想和雨疏一起工作的想法，但我不行啦，写不了论文啦。长久以来我都不觉得我是不适合工作，只是不适合瞎编。当然也没有很适合工作……但也就一般般啦</p>\n<h2>2023-09-08</h2>\n<p>想想距离我所熟悉的互联网的历史已经八年了。虽然也没有到跟不上时代的地步，但也有点不想继续了，倒也不是累，而是渐渐觉得没什么意思，起初报相关专业仅仅是自己的兴趣，还有作为一个懒人，觉得好的科技真的会造福人类。现在产品都做得差不多了，每年都有新的概念可以炒，但炒来炒去好像又都是那些。屎山没有因为概念而变得不屎，新的屎山也没有因此减少。八年前不说多好，也算是有个清楚的视野。现在已经看不清前面的路了。我不否认AI在一些场景下很有用，但你们真的觉得AI是风口吗？AI即便能成为成熟的行业，在未来也是垄断大户，倒不是分发便宜和兼容性的原因，而是高成本、闭源、加上随机性不可解释性。这绝不是什么独立开发者和小公司可以承担的东西，这是互联网行业的重工，小模型的水平又明显太差，真不适合炒。</p>\n<p>虽然不像炒币是纯粹的不靠谱，但如果真的可以训练到替代人类，或者说至少代替我这样水平的人没问题，现有的体制还不变革，依旧没有养闲人的能力，还是在为卷而卷（现在已经有这种趋势了），那社会真的会完蛋。三四年后再看吧。</p>\n<p>我是很乐意看世界一起毁灭的混乱中立派，但其实会精神崩溃的人不太多，比如七年前我是不可能会这样的。只能说有时候不要同时接触太多方面，接触的方向越多，似乎真的越来越感觉没意思。但明明是因为觉得有意思才接触的。反而不如看童话。</p>\n<p>我清楚地知道童话是童话，也能清楚地感受到童话对立面的悲惨。2005年的恶作剧之吻，收视很高的台偶，当时我对偶像剧不感冒也没有看，只觉得电视剧难道除了爱情就没得拍了吗。最近又刷到看了一下，发现是个过于美好的童话。童话不是没有波折，而是总能以现实不可能的方式将波折收尾成美好的结局。江家一家开开心心招待湘琴时我居然一直在哭，怎么说就是自己好没良心（？）我好像有他们拥有的一切，但我感觉又是什么也没有。我非常讨厌江直树的性格，网上也有很多人说，江家的环境不可能有江直树这样的孩子。但同时我又非常能体会到，他在老爸生日和家人撕破脸的那一段的真实。他妈这么嗑CP，骗他俩在家。他爸骗他去公司实习，这些情节都太熟悉了，真的在里面不会觉得有一点好笑和幸福，读书是为了能选择，不是为了没得选择。但到头来，发现读不读书其实都没得选择，反而可能读了书更没得选择。因为真的有主观选择的人，不会选择读这破书。在线好友一和我反而到现在非常佩服能选择不读研的人，但他说你显然不是这种人，他说得一点也没错。</p>\n<p>感觉写太多了。无所谓哈哈，趁着博客衰退没人知道我是谁多写点。可能等我死后扒出我的几百个账号会被认识的人看见吧。</p>\n<h2>2023-09-08</h2>\n<p>手动把之前的博客搬过来了。也没多少，写格式转换程序的时间都够我搬50篇了，不如 typora 粘贴，还补了一些新的字段。不过要是再来一次我不行了，我选择写脚本……现在来说会有点多了。</p>",
            "url": "https://sansui233.com/memos",
            "title": "碎碎念001",
            "date_modified": "2023-09-08T03:02:07.000Z",
            "date_published": "2023-09-08T03:02:07.000Z",
            "tags": [
                "Diary"
            ]
        },
        {
            "id": "https://sansui233.com/posts/2023-08-30-windows-tweak-and-enhancement",
            "content_html": "<p>自从感觉内存硬盘越来越不够用，以及对老黄的显卡需求，从 mac 换成了多年不见的 windows11 。做了非常多的调整，至现在基本稳定，记录下来以供参考。</p>\n<h2>基本调整与基础功能增强</h2>\n<ul>\n<li>\n<p><strong>右键菜单</strong></p>\n<p>使用 <a href=\"https://nilesoft.org/download\">shell</a>，恢复被藏到“更多选项”中的的右键菜单项，同时保持 win11 的设计风格。并且带有用 vscode 打开和用 windows Terminal 打开。虽然说 Windows Terminal 自己也有一个“用终端打开”，但那个有 Bug，打开的目录会被两个程序同时占用句柄，导致无法对目录本身进行操作。</p>\n</li>\n<li>\n<p><strong>批量重命名</strong></p>\n<p>使用 <a href=\"https://learn.microsoft.com/en-us/windows/powertoys/\">Powertoys</a> 中的 PowerRename，可选中多个文件后右键批量重命名，整理素材时太有用了。大致与 mac 的多文件重命名相同。缺点是不能改成 <code>同名称 + 编号</code> 。但系统自带的重命名恰好只能同名编号。Powertoys 有很多别的小工具，但都不够好用，按需关掉。</p>\n</li>\n<li>\n<p><strong>快速预览</strong></p>\n<p>使用 <a href=\"https://github.com/QL-Win/QuickLook\">QL-Win/QuickLook</a> ，选中文件后按空格直接预览，再按空格关闭。对于看各种后缀的文本文件、zip 压缩包目录结构非常有用。也用了 mac 后没法割舍的一个功能。前面说的 Powertoys 也有，但快捷键一定要加 ctrl（真的难按），功能更少，图片不能显示大小，无法定制。</p>\n</li>\n<li>\n<p><strong>文件快速搜索</strong></p>\n<p>使用 <a href=\"https://www.voidtools.com/\">Everything</a>，我大部分使用场景是在卸载程序后，清除残留的下载数据与用户数据。</p>\n</li>\n<li>\n<p><strong>快速启动/全局搜索</strong></p>\n<p><a href=\"https://fluentsearch.net/\">Fluent Search</a>，按 <code>alt+ 空格 </code> 快速在中央唤起搜索栏以快速进入目录、启动程序。相比于 windows 自带的 search，可以搜索到绿色程序。相比于 <a href=\"https://www.flowlauncher.com/\">Flow Launcher</a>，有好一万倍的排序。而更老的 <a href=\"https://www.listary.com/download\">Listary</a>，无法搜索绿色软件，排序也很拉。经过多次对比后，只有 Fluent Search 能在大量同名目录中快速定位到我要找的目录，而不会被一堆杂乱的东西包裹。</p>\n</li>\n<li>\n<p><strong>优化合集</strong></p>\n<p><a href=\"https://github.com/hellzerg/optimizer\">hellzerg/optimizer</a> 微调 windows 的合集程序，包括禁止系统更新、改 hosts 文件刷新 DNS、移除开机启动项、添加自定义右键菜单等。</p>\n</li>\n<li>\n<p><strong>历史剪贴板</strong>：在 <code>设置→系统→剪贴板</code> 中启用。</p>\n</li>\n<li>\n<p><strong>屏幕颜色配置文件(ICC Profile)</strong></p>\n<p>在 <code>设置→屏幕→显示配置文件</code> 中，换成对应屏幕的sRGB文件。否则对于广色域屏幕，某些不读 ICC Profile 的照片查看器会出现色彩过饱和的情况。</p>\n</li>\n<li>\n<p><strong>输入法</strong></p>\n<p>微软输入法需要改成回车时键入英文，否则会清空，不方便中英混输。不过作为一个五笔用户，我现在使用的是基于 Rime 的 <a href=\"http://98wb.ysepan.com/\">98五笔输入法</a> 和 <a href=\"https://github.com/Sansui233/98wubi\">我的配置</a>。<del>因为微软输入法 shift 加 空格会标点变全角，而这个功能在中英混输时非常容易触发，还不能改掉，实在太弱智了</del></p>\n</li>\n<li>\n<p><strong>关闭顶部自动布局</strong></p>\n<p>关闭 <code>系统→多任务处理→贴靠窗口</code>。此功能乍一看非常贴心，实则非常容易阻碍鼠标精准排列窗口，尤其是想把上沿拉到顶部时。不建议使用鼠标时开启，更适合手指操控设备。</p>\n</li>\n<li>\n<p><strong>多线程下载器</strong></p>\n<p>使用 <a href=\"https://aria2.github.io/\">aria2</a>，在网上抄了一个配置文件，并且让 chatgpt 写了一个开机自启脚本。面板使用的是 Chrome 插件 <a href=\"https://chrome.google.com/webstore/detail/mpkodccbngfoacfalldjimigbofkhgjn\">Aria2 Explorer</a>，考虑到都是在浏览器中下载，没必要使用独立的客户端 App。</p>\n</li>\n<li>\n<p><strong>与手机互传文件</strong>（折腾但稳定版）</p>\n<p>使用 <a href=\"https://github.com/alist-org/alist\">alist</a> 进行磁盘目录映射，并且使用 <a href=\"https://github.com/jeessy2/ddns-go/wiki\">DDNS-Go</a> 动态绑定本机的 ipv6 地址到公网。手机上将相应的 alist 页面添加到主屏幕，便可在该页面互传文件。好处是能走局域网，速度快，不同网络环境下可用，可远程传输等等。依然让 chatgpt 写脚本将两个程序加入开机启动。</p>\n</li>\n</ul>\n<h2>硬件调整</h2>\n<ul>\n<li>\n<p>硬件信息监测</p>\n<p>使用<a href=\"https://www.hwinfo.com/\">hwinfo</a>的实时监测数据作为硬件调整的基准</p>\n</li>\n<li>\n<p>功耗/风扇转速调整</p>\n<p>使用 <a href=\"https://github.com/seerge/g-helper\">g-helper</a> 调整日常使用的风扇曲线。我买的幻16，作为全能本，出厂的奥创调教特别垃，首发时还有bug。它的三种模式</p>\n<ol>\n<li>静音模式风扇完全不转，经常温度突然飙升很吵地转一会儿</li>\n<li>性能模式开什么都以游戏本的方式转，对我来说挺吵的</li>\n<li>增强模式的声音不是给人用的。</li>\n</ol>\n<p>如果用windows默认电源管理方案的话，似乎和程序资源占用有关，即使只有60度也给转上4000转。打个小游戏真的不配这么吵……</p>\n<p>后面用g-helper关闭睿频，功耗限制35w。测下来开原神默认高画质 1080p 稳定在CPU 65度，风扇3500转，不卡。这代 GPU 的散热反而问题不大，至少玩原神不会超过60度。然后测试了带光影的 Minecraft 1.20.1。MC 对 CPU 的要求更高，不过单机的话，不刻意刷红石，35w也够了，一般在25w左右，温度还是差不多的65度，全程电压没有超过1V，降压对于控温还是很有用的。奥创之所以动不动就吵就是因为一开性能模式，什么都不干电压给到1.8V……没必要，真的没必要。</p>\n<p>日常使用场景下，好像也就编译比较耗CPU，其他时候都用不到很好的CPU性能。图形处理还是占GPU更多。音乐制作一类的也是耗CPU但也还好，但更耗内存硬盘。</p>\n</li>\n</ul>\n<h2>音频调整</h2>\n<ul>\n<li>\n<p><strong><a href=\"https://sourceforge.net/projects/equalizerapo/files/\">Equalizer APO</a></strong></p>\n<p>调全局声音的均衡，需要搭配 <a href=\"https://github.com/jaakkopasanen/AutoEq\">Autoeq</a> 仓库中说的 peace 插件使用（现在好像直接叫autoeq.app）。耳机发烧友的必备。注意蓝牙耳机无法使用卷积eq。</p>\n</li>\n<li>\n<p><strong>内录用虚拟声卡：<a href=\"https://vb-audio.com/Cable/\">VBCABLE_Driver</a></strong></p>\n<p>网上有很多教程，为轻量级内录解决方案。另外如果系统带有 xbox，用 xbox 的录制视频是默认走的内录。</p>\n</li>\n<li>\n<p><strong>降低 Midi 键盘延迟</strong></p>\n<p>键盘连接电脑练琴，无独立声卡时，可用 <a href=\"https://asio4all.org/\">ASIO4ALL</a> 降低延迟。效果显著。缺点是 ASIO 是设备独占的，比如宿主软件使用 ASIO 到耳机，那看 b 站视频就只能外放（或者别的耳机/音响）。</p>\n</li>\n</ul>",
            "url": "https://sansui233.com/posts/2023-08-30-windows-tweak-and-enhancement",
            "title": "Windows调整之基础功能与常用插件",
            "summary": "让 windows11 变得更好用的一些自定义设置",
            "date_modified": "2023-08-30T09:42:20.000Z",
            "date_published": "2023-08-30T09:42:20.000Z",
            "tags": [
                "工具"
            ]
        },
        {
            "id": "https://sansui233.com/posts/20230822-Super_resolution_models_and_tools",
            "content_html": "<p><del>推特</del>，现在叫X.com，是我的桌面壁纸来源，但是推特的图压缩得非常糊，喜欢的动画人基本也只传 1080p 图，导致壁纸糊上加糊。因此需要使用 AI 放大模型进行图像处理。</p>\n<ul>\n<li>放大效果外链预览：<a href=\"https://imgsli.com/MjAwMDcx\">Comparison</a></li>\n<li>细节对比：<br/>\n<img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/picgo/comparison.jpg\" alt=\"\"/></li>\n</ul>\n<p>文章分为三个部分：</p>\n<ul>\n<li>图像处理工具</li>\n<li>AI 图像放大模型</li>\n<li>如何使用</li>\n</ul>\n<h2>图像处理工具</h2>\n<h3>1. <a href=\"https://github.com/chaiNNer-org/chaiNNer\">chaiNNer</a></h3>\n<p>一个无代码的图像处理自动化工具，可以实现批量改大小、调色、压缩、拼接等等等。同时也支持用 AI 对图像放大，也能接入 Stable Diffusion 的工作节点，上限非常高。缺点没有内置模板，即便是很小的功能（比如文件批量重命名）都需要自己创建。</p>\n<p>应用内置使用文档，不过不看文档也能一眼知道怎么用。</p>\n<p><strong>只有英文，没有中文。</strong></p>\n<ul>\n<li>传送门：<a href=\"https://chainner.app/\">chaiNNer</a></li>\n</ul>\n<h3>2. <a href=\"https://imagestool.com/zh_CN/\">imagestool</a></h3>\n<p>对于单张图和 gif 的常见处理小工具合集，网页打开即用，完全本地运行无隐私问题。特点是非常易用，支持小批量处理，支持 pipline，也就是说如果想在调整大小后转换格式再压缩，不需要每一步都上传下载图片，可以处理完每一步直接选下一步，只下载最终的处理结果。</p>\n<ul>\n<li>传送门：<a href=\"https://imagestool.com/zh_CN/\">imagestool</a></li>\n</ul>\n<h2>AI 图像放大模型</h2>\n<p>超分辨率成像(Super-Resolution，简称 SR) 是一种提高图像分辨率的技术，通俗的叫法就是图像放大。如果你曾经使用过 Photoshop 对小图进行放大，会发现放大后的边缘总是非常模糊，并且用锐化等操作无法弥补，这是传统方法的在图像放大上的缺陷。</p>\n<p>但是神经网络（Neural Networks，简称NN）的出现对图像放大的效果带来了极大的提升，几年前就已经有不少 AI 图像放大的应用，但最近两年的模型效果尤其好。下面介绍几个现阶段应用上比较火的模型。</p>\n<h3>1. <a href=\"https://github.com/JingyunLiang/SwinIR\">SwinIR</a></h3>\n<p>2021年基于 Transformer 的图像超分辨率模型，放大任何图片的效果都非常好。风格偏锐利且干净，且参数少，处理速度快。此模型分为 3 类，经典图像超分辨率（Classical image SR）、轻量级图像超分辨率（Lightweight image SR）、真实世界图像超分辨率（Real-world image SR）。</p>\n<ul>\n<li>下载链接： <a href=\"https://github.com/JingyunLiang/SwinIR/releases/tag/v0.0\">Release  · JingyunLiang/SwinIR</a></li>\n</ul>\n<p>可下载的版本很多，不知道选哪个的就选 <a href=\"https://github.com/JingyunLiang/SwinIR/releases/download/v0.0/001_classicalSR_DIV2K_s48w8_SwinIR-M_x4.pth\">001_classicalSR_DIV2K_s48w8_SwinIR-M_x4.pth</a> ，这个为4倍放大的模型，也是 Stable Diffusion 的 SwinIR 预置模型。</p>\n<h3>2. <a href=\"https://github.com/xinntao/Real-ESRGAN\">Real-ESRGAN</a></h3>\n<p>2021年的经典图像超分辨率模型，这论文出来后大家疯狂在它基础上卷，基于 ESRGAN 改进的模型和论文非常非常多。不过最初的版本也已经足够好用。</p>\n<p>下载链接：<a href=\"https://github.com/xinntao/Real-ESRGAN/releases\">Releases · xinntao/Real-ESRGAN</a></p>\n<p>依旧版本很多，不知道下哪个的下载 <a href=\"https://github.com/xinntao/Real-ESRGAN/releases/download/v0.1.1/RealESRNet_x4plus.pth\">RealESRNet_x4plus.pth</a> 即可。</p>\n<h3>3. 4x-AnimeSharp</h3>\n<p>基于 ESRGAN 架构的动漫类放大，<del>可能由于训练集选得好</del>，在众多动漫类放大中它可以很好地处理景深，其他的Anime模型多少在景深部分会有一些清晰过度的问题，包括著名的 <a href=\"https://github.com/xinntao/Real-ESRGAN/releases/download/v0.2.2.4/RealESRGAN_x4plus_anime_6B.pth\">RealESRGAN 动漫模型</a></p>\n<ul>\n<li>下载链接：<a href=\"https://openmodeldb.info/models/4x-AnimeSharp\">AnimeSharp - OpenModelDB</a></li>\n</ul>\n<p>OpenModelDB.info 上有更多的微调模型，可以试试。总体来说，AI 放大的图像质量目前来说还是乍一看可以，涉及商用美术的话质量仍然不过关。<del>如果商用美术能过关，岂不是能画糊图然后丢AI出高精图了。</del> 作为壁纸放大非常合适，即便是补充的细节不能推敲，但把像素精度补齐到屏幕分辨率带来的视觉提升也是非常大的。4k壁纸就是比1080p看起来舒服。</p>\n<h2>如何使用</h2>\n<p>使用 chaiNNer 时可照抄下图结构，使用 4x-AnimeSharp 模型放大原图、重命名图片并保存。</p>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/picgo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-22%20213633.jpg\" alt=\"chaiNNer\"/></p>\n<p>如果使用的是 <a href=\"https://github.com/AUTOMATIC1111/stable-diffusion-webui\">stable-diffusion-webui</a> ，Extra Network 选项卡中也有预置模型，可以使用 SwinIR 和 ESRGAN。</p>\n<hr/>\n<p>可能对您有用的资料：</p>\n<ul>\n<li><a href=\"https://openmodeldb.info/models/4x-AnimeSharp\">4x-AnimeSharp</a></li>\n<li><a href=\"https://phhofm.github.io/upscale/\">Interactive Visual Comparison of Upscaling Models</a></li>\n</ul>\n<hr/>\n<p>PS：我在尽力不要让语句变得不要和写论文一样啰嗦，但总是难以避免……以及我原本想写个内置的交互式组件来演示图像前后的区别，这也是我最初架构博客时选用 mdx 的原因，但真的开始写的时候……怎么还要多写一个东西？好麻烦！还要考虑 rss 兼容的问题，之后再补吧，现在写什么都像坐牢。</p>\n<p>PPS：强烈建议无代码应用都能开发个template market……</p>",
            "url": "https://sansui233.com/posts/20230822-Super_resolution_models_and_tools",
            "title": "图像超分辨率工具推荐",
            "summary": "AI图像放大模型+工具推荐",
            "date_modified": "2023-08-22T22:20:54.000Z",
            "date_published": "2023-08-22T22:20:54.000Z",
            "tags": [
                "工具"
            ]
        },
        {
            "id": "https://sansui233.com/posts/2023-02-20-stable-diffusion-AI-experience",
            "content_html": "<p>2023-03-03：待大量补充和修订。</p>\n<hr/>\n<p>进阶经验，非科普。分为五个部分：模型选择，分辨率调整，采样方法，ControlNet，Lora概述。</p>\n<p>此文章涉及多平台发布，由于生成类 AI 的争议，文中无外链推荐。</p>\n<h2>一、模型选择</h2>\n<p>模型影响构图和笔触和色彩，决定成图的平均水平。社区经常都在换流行的模型，还是根据需求定，huggingface 和 civitai 上很多。</p>\n<p>二次元目前主流三家 Anything Orange Counterfeit 。</p>\n<p>目前有不少混合了 2D 和 3D 的 2.5D 模型，用来出 cos 的，个人不喜欢。</p>\n<p>下图模型为 pastel-mix，图片画质已严重压缩（看不见则需要开代理，如果你用的 Innoreader 手机版阅读此文，大概率被放头图了）</p>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/00153-2596022983-masterpiece,%20best%20quality,%20ultra-detailed,%20illustration,%201boy,%20Link%20in%20Breath%20of%20the%20wild,%20sun%20shine,water,%20on%20back,%20lying%20in%20wa.jpg\" alt=\"pastel-mix\"/></p>\n<h3>模型精度选择</h3>\n<p>fp-16(2G)，fp-32(4G)，full(7G) 用于生产没有肉眼可见的区别。full 主要是训练用的。fp16 生产够用了，快，占用小。</p>\n<p>bf-16(2G) 相对 fp-16 会损失一小部分细节，不推荐，会发布 bf-16 版本的模型也较少。</p>\n<h3>VAE权重网络</h3>\n<p>影响色彩，主观效果是增加饱和度（比修图软件饱和度增强好太多）。目前流行的 VAE 就两个，一个 Waifu 的一个 Anything 的，很多带 vae 模型都是用的这两个改了个名字。</p>\n<p>下图为 mix-pro-v3-fp16 模型，叠加了其配套的 WD vae 的 效果。</p>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/00045-311454338-Original%20Characters,%201boy,%20sea%20shore,%20%20pastel-full.jpg\" alt=\"Mix-pro-v3\"/></p>\n<h3>Prompt</h3>\n<p>prompt（提示词）是玄学范围。不同模型的 prompt 词库不一，目前主流的词库有两个</p>\n<ul>\n<li>适用 SD v1.x 及其衍生模型的 lexica</li>\n<li>适用二次元模型的 Danbooru。</li>\n</ul>\n<p>对于二次元模型，Prompt 指定物体，调整动作、指定颜色比较容易。取决于模型的泛化能力。</p>\n<p>Prompt 难以精确控制画风，所以尽管上限非常高，但主流越来越不倾向于用大量 Prompt 叠 buf，转成微调模型以达成精确需求。</p>\n<p>在两个月前关于 Prompt 研究的文档就已经非常多了，这里不做推荐，因为不看文档，直接翻译成英文大概率是有效的。</p>\n<h3>文生图与图生图</h3>\n<p>文生图与图生图本质上没有什么不同，文生图只是将图片输入换成了一张随机的噪声图。</p>\n<h2>二、分辨率</h2>\n<p>不同模型在生成时有最佳的分辨率，大部分都在 512px 左右，不超过 1024px。</p>\n<p>提高分辨率不仅是单纯放大图片，AI 能够用模型细化图片。</p>\n<h3>图生图</h3>\n<p>img2img(图生图) 大部分时候被用来衍生，但是其效果最好的是将 txt2img 的低分辨率图放大（用同一个seed）。</p>\n<p>在 web-ui 中，仅缩放(just-resize)为无 AI 的放大算法处理。 AI 放大使用的 Latent 方法即将被归入 Upscaler，也就是下面说的 Hires fix。</p>\n<h3>Hires fix</h3>\n<p>Hires fix（高清修复）的作用是用 AI 从小图生成高分辨率图，处理用得好可以提高大幅提高图片上限。upscaler（放大器）可选几种放大方法，其中的 Latent 就是 SD 的画图方法，文生图与图生图均是这个方法。</p>\n<p>在 web-ui 中， 默认只有 txt2img 可用，因为 img2img 本身就可以做图片放大。另外，有专门的 upscaler 选项卡。</p>\n<p>使用 Latent upscaler (图生图) 放大到高分辨率图涉及局部重绘，部分模型支持较好，如 Pastel。但在 512 px 完成度就很高的模型上通常没有效果，或者更差（比如炫彩厚涂），这种用 GAN 类 Upscaler 直接放大比较好。</p>\n<p>值得注意的是 web-ui 的 Hires fix 有两版算法，目前 txt2img 是新版， img2img是旧版，效果有一些小差别，很难比较好坏。</p>\n<h2>三、采样方法</h2>\n<p>Sampler（采样方法） 决定笔触和结构的稳定性。常用的有：</p>\n<ul>\n<li>Euler a 是一个规整稳定的采样方法，出的图较平滑</li>\n<li>DDIM 是一个过程不算稳定的采样方法，通常看起来比 Euler a 细节更多</li>\n<li>DPM++ 2M Karas，最近在用的，过程稳定但有细节</li>\n</ul>\n<p>有部分 Sampler 对高分辨率（1024px 以上）支持不好。</p>\n<h2>四、 ControlNet</h2>\n<p>ControlNet 目前是一个需要额外安装的插件，可以用于给线稿上色并细化，或从草图细化。</p>\n<p>你的草图可以决定的是：</p>\n<ul>\n<li>60%-100% 的线条位置（构图）</li>\n<li>主要色块位置。需要搭配图生图，并且色块越碎越好，需要提前做好整体的光影效果。因为 大部分 AI 只会画整，会画碎的比较少（Pastel 会画碎）。</li>\n</ul>\n<p>细化风格（画风）由模型决定，不由你的草稿决定。模型风格对于画风影响非常关键。Prompt 也可以影响画风。</p>\n<p>细化内容（画的具体是什么）由 Prompt 、草稿、模型共同决定，调整 CFG、Denoise 、 ControlNet 的 Weight 可改变三者比例。</p>\n<p>下图为自己的较草的线稿使用 ControlNet 与 Anything V3.0 上色：</p>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/00275-3225619170-masterpiece,%20best%20quality,%20illustration,face,%20right%20hand,%20atomespheric,%20cold,%20sunshine,%20sky,,%20high%20detail,%20flowers%20and%20leafs.jpg\" alt=\"Control-Net\"/></p>\n<p>（这个东西出名是因为某博说 ControlNet 初衷是洗稿……之前 Pixiv 也出过线稿上色的 AI，只是效果好和不好的差别，怎么没人说是搭配 PS 的线稿提取功能洗稿）</p>\n<h2>五、Lora</h2>\n<p>Lora 是一种训练小模型的方法，可以在 15 张图以上生成稳定的单个角色图。</p>\n<p>已有大量角色图积累的流水线漫画苦力会比较省事，搭配 ControlNet 可生成固定姿势，或者使用线稿稳定地上色。但对于连续动作的细微差别不太行，细节演出表现依旧需要依赖线稿，或手动重绘</p>\n<p>训练过程分为裁剪、自动打标、训练，最终生成约 100M 左右的 Lora 网络。Web-ui 已自带。</p>\n<h2>写在后面</h2>\n<p>风格迁移渐渐成熟了，过拟合的问题在逐渐减少。减少过拟合的最终解决思路，还是把端到端的网络，按需求拆成了人为可控的 pipline。个人认为 AI 如果真的要作为工具，模块化的 pipline 是终点。</p>\n<p>直接出成图的是对已有作品的模拟，抽抽卡，融入不到创意的工作流。</p>\n<p>但是在发展好之前，地球可能已经枯竭了。</p>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/00162-1748765688-masterpiece,%20best%20quality,%20ultra-detailed,%20illustration,%201boy,%20Link%20in%20Breath%20of%20the%20wild,%20stronde%20hair,%20sun%20shine,water,%20emotio.jpg\" alt=\"pastel-mix\"/></p>",
            "url": "https://sansui233.com/posts/2023-02-20-stable-diffusion-AI-experience",
            "title": "Stable Diffusion AI 绘画的实用经验与总结",
            "summary": "AI 画画现状",
            "date_modified": "2023-02-21T00:00:00.000Z",
            "date_published": "2023-02-21T00:00:00.000Z",
            "tags": [
                "工具"
            ]
        },
        {
            "id": "https://sansui233.com/posts/dontstarvetogether-linux-server",
            "content_html": "<p>此文为 Docker 版饥荒联机版服务器在 CentOS 下的部署教程。</p>\n<blockquote>\n<p>为什么要部署Linux服务器？因为玩到后面，只要一联机连主机都卡，闲得想试</p>\n</blockquote>\n<p><a href=\"https://www.roci.ltd/dstserver/\">这个中文教程</a>讲了native steam版的安装方法，包括了Cent OS缺少的库，坑全踩了一遍写得十分详细。官方文档实在太拉，基本就是没有文档，像跨平台缺库这种事情也没有解决，没有脚本。不过教程中对于网络环境问题与mod的配置方法提得不多。</p>\n<p>我这里使用的是<a href=\"https://hub.docker.com/r/jamesits/dst-server\">Docker版本</a>。优点是</p>\n<ul>\n<li>国内的云平台对于Dockerhub的加速后走内网流量，不使用公网流量下载镜像。而且国内的服务器公网下载速度堪忧。</li>\n<li>Docker版本的文档写得对用户友好，易上手</li>\n<li>文件管理集中，比较方便。原版服务器的mod和存档是分开放的</li>\n</ul>\n<p>也有一些在国内环境下比较要命的缺点</p>\n<ul>\n<li>网络环境原因，无法下载创意工坊mod。最近靠改 hosts 也不行了。</li>\n<li>如果想开代理下载，docker容器开代理（设置环境变量）非常麻烦，具体来讲\n<ol>\n<li>如果每次开关代理都创建一个新的容器，Steam和游戏文件的更新都得再触发一次，又消耗流量又慢</li>\n<li>如果动态修改容器的配置文件，docker需要重启才能生效，所有docker服务都得宕机一会儿</li>\n</ol>\n</li>\n</ul>\n<h2>准备</h2>\n<ul>\n<li>一台至少2G内存的服务器</li>\n<li>使用ssh连接服务器、传输并管理文件的技能</li>\n</ul>\n<h2>Docker的安装</h2>\n<p>由于涉及到Docker镜像和Dockerhub加速的问题，具体安装步骤建议看docker的文档和各个云平台。</p>\n<p>我使用的腾讯云，见<a href=\"https://cloud.tencent.com/document/product/1207/45596\">安装 Docker 并配置镜像加速源</a>，大约花费2分钟。</p>\n<h2>服务器防火墙设置</h2>\n<p>需要放行 10999，11000，12346，12347 这四个端口的UDP流量。</p>\n<ul>\n<li>在国内云平台的控制台-防火墙中，放行服务器的这四个端口</li>\n<li>如果服务器上iptables有流量拦截，也需要放行</li>\n</ul>\n<h2>饥荒服务器镜像的启动</h2>\n<pre><code class=\"language-bash\">mkdir ${HOME}/Klei # 创建存放数据有文件夹\r\n\r\n# 拉取镜像并在前台启动\r\n# 由于Steam要更新，根据网络环境可能要等比较久的时间\r\n# 如果实在无法连接，再考虑给容器挂个代理下载。但总体不建议容器挂代理，因为我不清楚挂代理后steam是连接到服务器的游戏端口还是连到代理的端口上去了，取消容器的代理也非常麻烦。\r\ndocker run --name dst -v ${HOME}/Klei:/data -p 10999-11000:10999-11000/udp -p 12346-12347:12346-12347/udp -it jamesits/dst-server:latest\n</code></pre>\n<p>以上命令执行期间，可以去准备一下游戏存档和Mod相关文件。</p>\n<h2>准备游戏存档和Mod</h2>\n<p>我使用的Mac，饥荒的游戏文件相关目录位于</p>\n<pre><code class=\"language-bash\"># 游戏存档\r\nSAVE_DIR=&quot;~/Documents/Klei/DoNotStarveTogether/324927772/Cluster_1&quot;\r\n# mod下载目录\r\nMODS_DIR=&quot;~/Library/Application Support/Steam/steamapps/common/Don&#x27;t Starve Together/dontstarve_steam.app/Contents/mods&quot; #\r\n\r\ncd $SAVE_DIR # 进入存档目录\n</code></pre>\n<p>windows可以在饥荒游戏内点数据打开游戏存档，并在Steam中查看游戏的安装目录。</p>\n<h3>准备存档信息</h3>\n<p>点开<a href=\"https://accounts.klei.com/account/info\">饥荒的账号</a>，记下 <strong>Klei User ID</strong>。如果没有就注册一个。</p>\n<p>然后，新建<code>adminlist.txt</code>，并写入你的<strong>Klei User ID。</strong></p>\n<pre><code class=\"language-bash\">$ vim adminlist.txt\r\n# 写入以下内容\r\n你的Klei User ID\n</code></pre>\n<p>点开<a href=\"https://accounts.klei.com/account/game/servers?game=DontStarveTogether\">自建饥荒服务器的页面</a>，新建一个服务器，记下生成的Server Token，其他不用管。</p>\n<p>然后，新建 <code>cluster_token.txt</code>，并写入Server Token。</p>\n<pre><code class=\"language-bash\">$ vim cluster_token.txt\r\n# 写入以下内容\r\n你的Server Token\n</code></pre>\n<h3>准备mods</h3>\n<p>不开mod的可以跳过这一步。</p>\n<p>由于国内环境没法下载mod，需要把对应的mod文件复制过来。我为了方便就全复制了</p>\n<pre><code class=\"language-bash\">cp -r &quot;$MODS_DIR&quot; mods\n</code></pre>\n<p>先查看一下目前的存档开了哪些mod。</p>\n<pre><code class=\"language-bash\">$ cat Master/modoverrides.lua\r\n# 开启的mod\r\nreturn {\r\n  [&quot;workshop-1172839635&quot;]={ configuration_options={ icebox_freeze=&quot;0.5&quot; }, enabled=true },\r\n  [&quot;workshop-1294206358&quot;]={ configuration_options={  }, enabled=true },\r\n}\n</code></pre>\n<p>然后，编辑 <code>mods/dedicated_server_mods_setup.lua</code> 文件，写入上面的mod编号</p>\n<pre><code class=\"language-bash\">$ vim mods/dedicated_server_mods_setup.lua\r\n# 写入以下内容\r\nServerModSetup(&quot;workshop-1294206358&quot;)\r\nServerModSetup(&quot;workshop-1595631294&quot;)\n</code></pre>\n<p>至此，游戏存档和mods就准备好了。</p>\n<h2>转移游戏存档和Mods至服务器</h2>\n<p>上传游戏存档到服务器。打包和上传文件我一般使用GUI操作，用命令行的话是这样</p>\n<pre><code class=\"language-bash\">cd ~/Documents/Klei/DoNotStarveTogether/324927772/\r\ntar -cvf Cluster_1.tar.gz Cluster_1 \r\nscp Cluster_1.tar.gz root@myserver:/Klei/\n</code></pre>\n<p>如果之前的服务器连接还在，等无新日志输出后使用control+c退出容器。如果已断开连接，重新用ssh登录服务器。</p>\n<p>然后可以看到在服务器的 <code>~/Klei/DoNotStarveTogether</code> 中有了一个 <code>Cluster_1</code> 存档。</p>\n<p><strong>转移游戏存档时，需要注意有两种情况（来自<a href=\"https://hub.docker.com/r/jamesits/dst-server\">文档</a>）</strong></p>\n<p>第一种情况是，如果自己的存档开启了洞穴，把自己的存档覆盖过去即可。</p>\n<pre><code class=\"language-bash\">rm -rf Cluster_1\r\ntar -xvf Cluster_1.tar.gz\n</code></pre>\n<p>第二种情况是，自己的存档没有开启洞穴，需要</p>\n<ol>\n<li>在自己的电脑中，存档的上一级有个 <code>client_save</code> 。复制下面的除了 <code>session</code> 外的所有文件到服务器的 <code>Cluster_1/save</code> 。</li>\n<li>自己存档中的 <code>Cluster_1/save/session</code> 需要删除，其他文件可以直接覆盖</li>\n</ol>\n<p>存档覆盖完毕后，启动容器</p>\n<pre><code class=\"language-bash\">docker start -a dst\r\n# 如果最后输出了 Sim Pause 就代表 OK 了，按 ctrl + c 退出，容器继续后台运行\n</code></pre>\n<p>我第一次装Mod启动时发生了一个莫名其妙的 <strong>Segmentation fault</strong>，程序退出了，但是第二次启动就好了。搜了一下<a href=\"https://github.com/Jamesits/docker-dst-server/issues/48\">相关issue</a>，完全相同的情况，也是CentOS，偶尔发生，难稳定复现。</p>\n<h2>游玩</h2>\n<p>之前自己的存档叫什么名字就搜什么名字，加入就完事，好好玩吧w</p>\n<hr/>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://hub.docker.com/r/jamesits/dst-server\">jamesits/dst-server</a></li>\n<li><a href=\"https://github.com/Jamesits/docker-dst-server/issues\">docker-dst-server issue</a></li>\n<li><a href=\"https://www.roci.ltd/dstserver/\">饥荒独立服务器入门级快速搭建</a></li>\n<li><a href=\"https://dontstarve.fandom.com/wiki/Guides/Don%E2%80%99t_Starve_Together_Dedicated_Servers\">Guides/Don&#x27;t Starve Together Dedicated Servers - Fandom</a></li>\n</ul>",
            "url": "https://sansui233.com/posts/dontstarvetogether-linux-server",
            "title": "部署饥荒联机版Linux服务器",
            "summary": "此文为 Docker 版饥荒联机版服务器在 CentOS 下的部署教程。",
            "date_modified": "2022-12-28T00:00:00.000Z",
            "date_published": "2022-12-28T00:00:00.000Z",
            "tags": [
                "游戏"
            ]
        },
        {
            "id": "https://sansui233.com/posts/记一道题排列组合题解",
            "content_html": "<p>难得在网上遇到有认真在做题的人，在此表示深深的感谢。另外个人不太会写题解类的文，权当一个记事了。</p>\n<h2>题目</h2>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/8B414946-F4D4-479C-9092-9AEA8EC26FA3.jpeg\" alt=\"8B414946-F4D4-479C-9092-9AEA8EC26FA3.jpeg\"/></p>\n<p>题来自 tg 里玩 ai 的小水群，很多人第一眼是想全排列剪枝……阶乘的复杂度得瞎了。</p>\n<p>不过看到求方案数，帮人面试时被动态规划虐过的直觉在告诉我，凡事让写方案数不枚举方案的，很可能能写动态规划。</p>\n<p>于是从动态规划的方面想去了。</p>\n<h2>关于素数</h2>\n<p>这个题有一个非常奇怪的地方，就是要和为素数。我不禁想，和为素数是对解题方法有什么加成吗？</p>\n<p>（其实因为我最初看走眼了，以为是子集里所有数为素数，且和为素数，还以为素数和有什么定理）</p>\n<p>素数的特殊点在于乘法分解，至于加法上与一般数有什么不同，以凡人视角未曾听说。并且这题还并不限于子集中取用什么数。</p>\n<p>综上，和为素数对解题方法不仅没有什么加成，反而是多了个如何判断一个数是不是素数的问题。</p>\n<p>至于如何判断素数，在 Leetcode 204，略，也没什么很省时间的方法，就是筛，不算简单。</p>\n<h2>子集动态规划</h2>\n<p>既然素数对于解题思路没有加成，就按一般数处理，很快写出了下面的思路：</p>\n<ol>\n<li>一维dp中存下和为当前数的方案数</li>\n<li>遍历更新dp，把新数n拆分成已有数+余数，按余数从大到小（已有数从小到大），把所有已有数的拆分方案加起来，再+1，即可得到当前数的子集数。\n<ol>\n<li>需要注意的是，为了保证不重复，也就是保证子集序列递增，已有数不会超过n/2（余数不会小于n/2）</li>\n</ol>\n</li>\n<li>更新dp时，也要计算新数n是否为质数，是的话把其子集数加入最终结果（算质数见leetcode 204）</li>\n<li>由于取值范围1-2000，最大和为1000^2，100w，也是dp要遍历的次数。</li>\n</ol>\n<p>下面的图是在解释什么叫“遍历但不用枚举子集”时写的，也是上述dp的步骤。</p>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/2E06B8C3-1DF4-492D-A009-55F4D7A041CE.jpeg\" alt=\"img\"/></p>\n<p>发题人仔细看了，并且手动枚举了10个数后，指出，我这会漏掉10=1+2+3+4。（后面自己发现这样还漏了145和235，后面越漏越多）</p>\n<p>仔细回顾了一下之前的思路，发现我的问题出在递增的判断上。我当时认为保证递增序列，只要保证已有数小于余数就行，所以余数&gt;2/n。</p>\n<p>但不是的，比如n=10时，已有数为6，余数为4，6拆分为1+2+3就行，1234还是序列递增的。6拆分为2+4、1+5就不行。</p>\n<p>归根结底就是我只把余数算了较大的一半，因为余数较大的一半肯定能保证序列递增。如果不想漏情况，余数要全部遍历，但怎么保证序列递增呢？比如6+4，如何只拆到1+2+3+4，不算1+5+4和2+4+4呢？</p>\n<p>于是更新了一下递增的条件：</p>\n<ul>\n<li>已有数的拆分的子序列最大数小于余数，则拆分方案合法</li>\n</ul>\n<p>再更新dp时余数范围：</p>\n<ul>\n<li>余数从n取到1，分别计算子集数后再sum。</li>\n</ul>\n<p>这样可以保证思路没问题了，但这个“已有数的拆分的子序列最大数小于余数”，明显当前dp只统计了子集数，根本不知道各个子集中具体最大数的情况。因此，我改成了个二维dp，含义和过程如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/6D139DD5-A95F-4467-BA58-3B5E61D9207D.jpeg\" alt=\"img\"/></p>\n<p>简单总结一下，整个问题我简化到了求“和为 n 的子集数”，并利用二维动规从 1 求到 n。 n 是不是素数单独算的。</p>\n<p>并且发现，其实更新每一行时，都是把上一行为止的方阵以“/”方向45度拆开，mask掉右边部分，按行求和后，从右往左地写进下一行，还能用gpu加个速（不是）。</p>\n<h2>另一种解法</h2>\n<p>发题人在看了我的新方案后，说在上面看到了类似杨辉三角之类的东西。并且得出了另一个方案：</p>\n<blockquote>\n<p>和为 n 的子集组合数，为多项式 (x^n+1)(x^(n-1)+1)(x^(n-2)+1)…(x+1) 的 x^n 项系数</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/IMG_5434.JPG\" alt=\"多项式展开\"/></p>\n<p>（我本来没理解，是死缠烂打地问才知道他在说什么）</p>\n<p>仔细一想真的是这个理， x^n 对应的多项式系数就是排列组合到 n 的所有方案数了，也天然没有重复用数的问题。怎么想到的，神。</p>\n<p>所以现在问题是：怎么求 (x^n+1)(x^(n-1)+1)(x^(n-2)+1)…(x+1)的多项式系数。</p>\n<p>（当时已经不想动脑了，又是死缠烂打地问）</p>\n<p>其实迭代就能算，因为 F(n) = x^n • F(n-1) + F(n-1)，对应系数直接挪位置后复制粘贴再相加就好了。</p>\n<h2>空间复杂度</h2>\n<p>这里有点难以定义 n 具体指哪个，默认 n = 2000 。</p>\n<p>我的解法是要 1000^4 的空间去存方案数，矩阵中有很多地方是空的，有点浪费。</p>\n<p>后者的解法要1000^2 空间去存多项式系数。省很多。</p>\n<h2>时间复杂度</h2>\n<p>以我的动规方法，时间复杂度为在 O(n^6)，准确说是O(n^2(n^2+1)(2n^2+1)/6)，因为要算到 (n/2)^2，且内部还有已填矩阵按行遍历。</p>\n<p>以后者的的解法，时间复杂度为 O(n^3)，因为多项式的 n 需要到 (n/2)^2。</p>\n<p>线性筛到 (n/2)^2 的素数, 时间复杂度为 O(n^2)。</p>\n<hr/>\n<p>总得来说还是数学好的强啊。</p>\n<p>另外还有一个人非让我看完一个 30 分钟的高斯素数判断法，结果我一直在想 dp，搞得他怨念深重 hh</p>",
            "url": "https://sansui233.com/posts/记一道题排列组合题解",
            "title": "记一道题排列组合题解",
            "summary": "难得在网上遇到有认真在做题的人，在此表示深深的感谢。另外个人不太会写题解类的文，权当一个记事了。",
            "date_modified": "2022-11-18T00:00:00.000Z",
            "date_published": "2022-11-18T00:00:00.000Z",
            "tags": [
                "学习"
            ]
        },
        {
            "id": "https://sansui233.com/posts/rust-closure-and-ownership",
            "content_html": "<p>本文将以（自认为）最简单易懂的方式讲述 Rust 中的闭包与环境变量所有权的关系。在现存的类似中文教程中，要么语言表述歧义太大，逻辑上难以理清；要么试图把事情总结得过于复杂。实际上闭包对于环境变量所有权的处理规则是非常简单的。</p>\n<p>阅读本文需要的基础： Rust 变量的所有权、引用与借用、函数、traits。</p>\n<h2>什么是 Rust 的闭包</h2>\n<p>Rust 中的闭包是<strong>一种函数</strong>。与 Rust 普通函数不同，它可以<strong>捕获函数外部的变量并使用</strong>。</p>\n<p>基本语法：<code>|参数列表| {函数体}</code></p>\n<pre><code class=\"language-rust\">fn main() {\r\n    let x = 1;\r\n    let sum = |y: i32| { x + y }; // 说明： 闭包 sum 接收一个参数 y，且捕获前面的 x = 1, 返回 x + y\r\n    println!(&quot;{}&quot;, sum(99)); // 输出 100\r\n\r\n    let sum2 = |y :i32| x + y + 1; // 也可以省略花括号\r\n    println!(&quot;{}&quot;, sum2(99)); // 输出 101\r\n}\n</code></pre>\n<blockquote>\n<p>说明： 闭包 sum 接收一个参数 y，返回 x + y。其中 x 是第一行定义的 <code>let x = 1;</code> ，为闭包外部的变量。</p>\n</blockquote>\n<p>像 <code>x</code> 这样在定义在闭包外部、可被闭包直接访问的变量，我们称为“<strong>环境变量</strong>”。</p>\n<h2>闭包中环境变量的所有权</h2>\n<p>有 rust 基础的人应该知道，普通的 rust 函数的传入参数有三种形式</p>\n<ol>\n<li>所有权 move（默认行为）。</li>\n<li>可变借用，形式为 <code>&amp;mut param</code></li>\n<li>不可变借用 ，形式为 <code>&amp;param</code></li>\n</ol>\n<blockquote>\n<p>上述为 rust 所有权基础知识，不再赘述。</p>\n</blockquote>\n<p>普通的 rust 函数可以使用参数，但无法使用环境变量。闭包则加上了 <strong>捕获当前环境变量</strong> 的功能。</p>\n<p><strong>捕获当前环境变量</strong> 仅仅是指闭包 “知道有哪些环境变量”。闭包在使用环境变量时，依然可能会对环境变量执行三种操作：</p>\n<ol>\n<li>所有权 move</li>\n<li>可变借用</li>\n<li>不可变借用</li>\n</ol>\n<p>具体是执行了哪种操作呢？这个问题就比较复杂了，我们可以从上面的例子出发。</p>\n<p>回顾上面的例子，对于环境变量 <code>x</code> ，首先排除了所有权 move。</p>\n<pre><code class=\"language-rust\">    let x = 1;\r\n    let sum = |y: i32| { x + y }; // 使用了 x\r\n    println!(&quot;{}&quot;, sum(99)); // 输出 100\r\n\r\n    let sum2 = |y :i32| x + y + 1; // 再次使用了 x\r\n    println!(&quot;{}&quot;, sum2(99)); // 输出 101\n</code></pre>\n<blockquote>\n<p>说明： <code>x</code> 在 sum1 中使用后，还能在 sum2 中再次使用，说明 <code>x</code> 所有权没有 move。</p>\n</blockquote>\n<p>实际上，上述例子的 <code>x</code> 在闭包中是作为 <strong>不可变借用</strong> 使用的，<strong>因为这个闭包实现了 <code>Fn</code> trait</strong>。</p>\n<h2>闭包的三种 traits</h2>\n<p>闭包是一种函数，它的三种 traits 恰好对应了三种处理所有权的方式。</p>\n<p>三种 traits 如下（划重点，请背下来）：</p>\n<ol>\n<li><code>FnOnce</code>：表示此闭包调用时会获取环境变量所有权（<strong>所有权 move</strong>)。因此取名 <code>FnOnce</code>，表示此闭包只能执行一次，因为再次执行时，环境变量可能由于之前所有权 move 过，已经没法用了。</li>\n<li><code>FnMut</code> ：表示此闭包调用时会对环境变量进行<strong>可变借用</strong>，可能会修改环境变量</li>\n<li><code>Fn</code> ： 表示此闭包调用时会对环境变量进行<strong>不可变借用</strong>，不会修改环境变量</li>\n</ol>\n<p>并且，<strong>一个闭包可以同时实现多个 traits</strong>。比如实现了 <code>Fn</code> 的闭包也一定实现了 <code>FnOnce</code> （后续解释）。</p>\n<p>上面是从“对环境变量如何处理所有权” 来解释三个 traits，大部分教程也是这么写，但个人并不推荐完全按这样去理解。因为上述表述中，三个 traits 看起来是互不重叠的（实际并非如此），导致可能会出现这样的疑问：</p>\n<blockquote>\n<p>“实现了 <code>Fn</code> 的闭包说是对环境变量进行了不可变借用，那怎么还能同时实现 <code>FnOnce</code> ，去获取环境变量的所有权呢？到底是仅仅进行不可变借用，还是获取了所有权呢？”</p>\n</blockquote>\n<p>但是看三个 traits 的源代码，可以直接回答上述问题：是不可变借用。虽然确实也实现了 <code>FnOnce</code>（所有权 move） ，但并没有调用 <code>FnOnce</code> 的 call 函数，而是调用了 <code>Fn</code>(不可变借用) 的 call 函数。</p>\n<pre><code class=\"language-rust\">pub trait Fn&lt;Args&gt; : FnMut&lt;Args&gt; {\r\n    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;\r\n}\r\n\r\npub trait FnMut&lt;Args&gt; : FnOnce&lt;Args&gt; {\r\n    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;\r\n}\r\n\r\npub trait FnOnce&lt;Args&gt; {\r\n    type Output;\r\n\r\n    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;\r\n}\n</code></pre>\n<blockquote>\n<p>分析：如果 <code>FnOnce</code> 的 call 函数被调用，则直接传入了 <code>self</code> ，也就是获取了当前的环境变量的所有权，自然运行一次后回被销毁。而 <code>Fn</code> 的 call 函数传入的是不可变借用 <code>&amp;self</code>。</p>\n</blockquote>\n<p>并且会发现， <code>Fn</code> 的前提是实现了 <code>FnMut</code> , <code>FnMut</code> 的前提是实现了 <code>FnOnce</code> 。</p>\n<ul>\n<li>从继承关系来讲： <code>Fn</code> 继承 <code>FnMut</code> 继承 <code>FnOnce</code></li>\n<li>从访问变量的权限范围来讲： <code>Fn</code> &lt; <code>FnMut</code> &lt; <code>FnOnce</code></li>\n</ul>\n<p>也可以说，<strong>闭包就算实现了 <code>FnOnce</code> 也不一定会用到所有权 move，因为可能还实现了 <code>Fn</code> ，那么环境变量的所有权会按 <code>Fn</code> 处理</strong>。</p>\n<hr/>\n<p>由于上述继承关系，如果定义一个普通函数，参数需要传入 <code>FnOnce</code> ，实际上也可以传入 <code>Fn</code> 。</p>\n<pre><code class=\"language-rust\">fn fn_once&lt;F&gt;(func: F)\r\nwhere\r\n    F: FnOnce(usize) -&gt; bool, // 传入闭包\r\n{\r\n    println!(&quot;{}&quot;, func(3));\r\n}\r\n\r\nfn main() {\r\n    let x = vec![1, 2, 3];\r\n    let closure = |z|{z == x.len()}; // 此闭包实现了 Fn、 FnMut 和 FnOnce\r\n    fn_once(closure); // Fn 可传入标注为 FnOnce 的参数\r\n    println!(&quot;{:?}&quot;, x); // x 还能用，所有权没转移\r\n\r\n    let closure2 = move |z|{z == x.len()}; //  此闭包只实现了 FnOnce，因为 x 被强制转移所有权到闭包内部\r\n    fn_once(closure2); // 传入 FnOnce\r\n    println!(&quot;{:?}&quot;, x); // 报错，x 已经没了\r\n}\n</code></pre>\n<blockquote>\n<p>说明：fn_once 需要接收 <code>FnOnce</code> 的闭包作为参数，但传入 <code>Fn</code> 也是合理的，编译器也会按照 <code>Fn</code> 的调用方式处理为不可变借用，并不会因为标注着 <code>FnOnce</code> 而变成所有权 move。</p>\n</blockquote>\n<blockquote>\n<p>闭包对所有权的处理并不会随着标注改变，标注仅仅是为了取悦编译器 ——鲁迅</p>\n</blockquote>\n<h2>闭包实现三种 traits</h2>\n<p>上述例子中，直接标注了闭包实现了三种 traits，但并没有具体说明为什么这么写就是实现了三种 traits。这是本节需要说明的内容。</p>\n<p>闭包实现 traits 是<strong>隐式</strong>的。也就是说，你不用（也没法）标注这个闭包是实现的哪个 traits。具体实现了哪些 traits 是根据你的闭包写法决定的。</p>\n<ol>\n<li>实现<code>FnOnce</code></li>\n</ol>\n<p>所有的闭包都自动实现了 <code>FnOnce</code> 。不用特别做什么。</p>\n<p>但更普遍的情况是，定义闭包时会顺带实现 <code>Fn</code> 或者 <code>FnMut</code> 。如果想要只实现 <code>FnOnce</code>，不要实现另外两个，需要用 <code>move</code> 。这个关键字会强制转移所有权，使闭包无法满足 <code>FnMut</code> 和 <code>Fn</code> 的条件。</p>\n<ul>\n<li>例：只实现了 <code>FnOnce</code> 的闭包</li>\n</ul>\n<pre><code class=\"language-rust\">fn main() {\r\n    let x = [1,2,3];\r\n    \r\n    let closure2 = move |z|{z == x.len()}; // 只实现了 FnOnce，所有权转移\r\n    closure2(2);\r\n    \r\n    println!(&quot;{:?}&quot;, x); // 报错，x 所有权被转移\r\n}\n</code></pre>\n<ol start=\"2\">\n<li>实现<code>FnMut</code></li>\n</ol>\n<p>在闭包中修改外部变量，即实现了 <code>FnMut</code> （自然也实现了 <code>FnOnce</code> ），同时没有实现 <code>Fn</code> 。</p>\n<pre><code class=\"language-rust\">fn main() {\r\n    let mut x = vec![1,2,3];\r\n\r\n    let mut closure = ||{x.push(4);}; // 修改了外部的 x, 实现了 FnMut， x 所有权没有转移\r\n    closure();\r\n    \r\n    println!(&quot;{:?}&quot;, x);\r\n}\n</code></pre>\n<ol start=\"3\">\n<li>实现<code>Fn</code></li>\n</ol>\n<p>在闭包中访问外部变量，不做任何修改，即实现了 <code>Fn</code> （自然也实现了 <code>FnMut</code> 和 <code>FnOnce</code>）。</p>\n<pre><code class=\"language-rust\">fn main() {\r\n    let s = String::new();\r\n\r\n    let update_string =  || println!(&quot;{}&quot;,s); // 访问外部的 s, 实现了 Fn\r\n\r\n    exec(update_string);\r\n    exec1(update_string);\r\n    exec2(update_string);\r\n}\r\n\r\nfn exec&lt;F: FnOnce()&gt;(f: F)  { // Fn 也可以传到 FnOnce 类型\r\n    f() // 调用的是 Fn，所有权不会转移\r\n}\r\n\r\nfn exec1&lt;F: FnMut()&gt;(mut f: F)  { // Fn 也可以传到 FnMut 类型\r\n    f()\r\n}\r\n\r\nfn exec2&lt;F: Fn()&gt;(f: F)  {\r\n    f()\r\n}\n</code></pre>\n<h2>闭包自身的所有权</h2>\n<p>上述讨论的是闭包对于环境变量的所有权处理。那闭包自己呢？当闭包自己作为变量被传来传去时，是 Copy 还是所有权 Move？</p>\n<p>答案是，<code>Fn</code> 是 Copy，<code>FnMut</code> 和 <code>FnOnce</code> 是所有权 Move。</p>\n<pre><code class=\"language-rust\">fn main() {\r\n    let x = vec![1,2,3];\r\n\r\n    let closure = |z:usize|{ z == x.len()}; // 实现了 Fn\r\n    outter(closure); // 通过\r\n    outter(closure); // 通过\r\n\r\n    let closure2 = |z:usize|{ x.push(4);z == x.len()}; // 实现了 FnMut\r\n    outter(closure2); // 通过\r\n    outter(closure2); // 报错, closure2 的所有权已被转移\r\n}\r\n\r\nfn outter&lt;T&gt;(mut func: T)\r\nwhere T: FnMut(usize) -&gt; bool { // Fn 可以传到 FnMut 标注的参数上\r\n    let a = func;\r\n}\n</code></pre>\n<p>这是非常合理的，对应着 Rust 借用的规则</p>\n<blockquote>\n<p>在同一时间点，对于同一个变量，<strong>要么</strong>只能有一个可变借用(FnMut)，<strong>要么</strong>只能有<strong>多个不可变借用</strong>(Fn)。</p>\n</blockquote>\n<p>至于 <code>FnOnce</code>，对环境变量的访问权限这么大，还想 Copy？只能是所有权 move。</p>\n<h2>一些建议</h2>\n<p>如果遇到函数的参数也是一个函数，需要标注 trait 的场景，又不知道到底应该标注哪一个 trait，建议先标注 Fn ( 权限最小的 trait)，由编译器提示后再进行修改。</p>\n<p>另外，闭包的所有权部分并不推荐背书，尤其不推荐总结为正交规则。三个 traits 的区别与联系在代码层面非常简单且容易分析，总结为正交规则反而是把简单的事情复杂化，而且难记。</p>\n<p>如果仍然难懂，可评论提出，后续改进。</p>",
            "url": "https://sansui233.com/posts/rust-closure-and-ownership",
            "title": "理解 Rust 闭包与环境变量所有权",
            "summary": "B站反查用户弹幕小记",
            "date_modified": "2022-06-14T00:00:00.000Z",
            "date_published": "2022-06-14T00:00:00.000Z",
            "tags": [
                "学习"
            ]
        },
        {
            "id": "https://sansui233.com/posts/PPT母版的制作与使用方法",
            "content_html": "<p>由于我需要批量编辑 PPT 的样式，但 PPT 没有组件化样式的概念，所以开始学习用母版。虽然之前也用过，但始终不明白 PPT 的迷之逻辑，有时候是调整了母版但不生效，或者调整了局部结果别的地方也被影响了……今天才大概明白了一点（还是 Figma 和 Sketch 的逻辑好懂……）所以从我的角度说一下对 PPT 的模版理解。</p>\n<p>这个问题明显视频解释更好，但不太想做视频（躺）因为每次做视频前写大纲都要写好久……</p>\n<p>图源 Github，图片不显示挂代理 Please。</p>\n<h2>概念解释（母版/版式/主题）</h2>\n<h3>打开母版</h3>\n<p>母版的入口在“视图”→“幻灯片母版”。Mac 上的快捷键是 <code>command + alt + 1</code>。</p>\n<h3>什么是母版和版式</h3>\n<p>母版，是 PPT “主题” 的一部分，可以对多张幻灯片的排版进行统一的修改。</p>\n<p>我们日常制作的 PPT，都会基于一个母版（虽然很多人不去用）。在后面的内容中，对于日常制作的 PPT，我会称为“PPT 内容”。</p>\n<p>一个正常的母版包含着一个“<strong>幻灯片母版</strong>”和多个“<strong>版式</strong>”。</p>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/Screen%20Shot%202021-11-11%20at%207.03.24%20PM.png\" alt=\"母版结构\"/></p>\n<h3>样式继承</h3>\n<p>“<strong>版式</strong>” 会继承 “<strong>幻灯片母版</strong>”（以下简称为 <strong>母版</strong> ）中的一些元素的样式（包括位置、字体、大小、颜色等）。也就是说，只要更改 <strong>母版</strong> 里的样式，<strong>版式</strong>也会自动更新。</p>\n<p>所以是哪些元素可以被继承呢？在菜单栏里的“母版版式”中，有五个选项分别是</p>\n<ul>\n<li>标题</li>\n<li>正文</li>\n<li>日期和时间</li>\n<li>页脚</li>\n<li>页码</li>\n</ul>\n<p>以上就是所有样式可以被继承的元素。是的，你在母版上<strong>只有这五个元素的样式可以被继承</strong>。你可以尝试在“主题”选项中打开任何一个母版，会发现所有母版都是这五个元素。你无法擅自增加其他可以被继承的元素。</p>\n<p>并且以上显示的每个元素在母版上都只能设置一种样式，**你无法同时给标题设置两种样式。**也就是说，如果你有设置 <strong>一级标题 + 二级标题</strong> 样式的需求，你无法通过设置 <strong>母版</strong> 上的样式实现二级标题。你只能通过 <strong>版式</strong> 去设置二级标题。</p>\n<p>另外 <strong>背景</strong> 也可以被继承，但它属于在正式的 PPT 内容中不可编辑的元素。</p>\n<h2>如何编辑元素样式</h2>\n<p>选中元素，在“开始”选项里编辑即可。</p>\n<p>通常情况下，母版的排版需要设置得尽可能通用，之后的每个版式都将以母版为基准进行编辑。母版本身并不能直接被 PPT 内容所使用，做 PPT 能选择使用的只有继承了母版样式的 <strong>版式</strong>。</p>\n<h2>版式如何继承母版</h2>\n<h3>继承标题样式</h3>\n<p>选择一个版式（或点“插入版式”），给菜单里的“标题”打上勾。</p>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/Screen%20Shot%202021-11-11%20at%207.35.09%20PM.png\" alt=\"标题继承\"/></p>\n<p>需要注意的是，如果你在“开始”里添加一个文本框，移动到标题的位置，并不会被 PPT 识别成标题。从外面粘进来的文本框也一样，只会被识别为“一个普通的文本框”。之后批量更新标题的样式时，也并不会被更新。</p>\n<p>所以在版式中设置正确设置标题的方法只有这一个——给标题打上勾。</p>\n<p><strong>想设置二级标题怎么办？</strong></p>\n<p>母版没有二级标题，只能用下面说的占位符实现。</p>\n<h3>继承正文样式</h3>\n<p>继承正文的正确方法，是点击上一节图中的“插入占位符” ，有好几个选项，一般选内容就可以了。</p>\n<p>此占位符生成的文本框的样式和 <strong>母版</strong> 中完全一致。如果说 <strong>母版</strong> 的样式是全局变量，<strong>版式</strong> 中再次修改的样式就是局部变量。</p>\n<p>对于<strong>修改过的部分</strong>，母版里对正文的更新不会导致版式中的正文更新。比如：</p>\n<ul>\n<li>母版中的正文字号是 20px</li>\n<li>版式中的正文字号不变，但是给加粗了</li>\n<li>修改母版中的正文字号为 22px</li>\n<li>版式中的正文字号变成 22px，但仍然加粗。</li>\n</ul>\n<blockquote>\n<p>❗️注意：不要从“开始”里新建文本框！也不要从母版界面外粘贴进来！</p>\n<p>原因同上，非占位符生成的文本框，对其样式的修改并不会真正改到“正文”的样式。使用的时候就会发现了，更新版式了但 PPT 内容样式完全没更新……这种情况就是因为版式中的文本框不是占位符生成的</p>\n</blockquote>\n<p>所以如何实现二级标题？</p>\n<ul>\n<li>添加一个占位符</li>\n<li>添加文本样式</li>\n</ul>\n<h3>继承日期和时间、页脚、页码</h3>\n<p>在版式中，给“页脚”打上勾，以上三者的样式都会被继承。</p>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/Screen%20Shot%202021-11-11%20at%2011.06.48%20PM.png\" alt=\"其他继承\"/></p>\n<h2>使用版式</h2>\n<p>退出“幻灯片母版”模式。在正常 PPT 内容的模式下，菜单栏“开始”中有个“版式”选项。在侧边栏选中一页（或多页） PPT，点击相应版式即可应用。</p>\n<p><img src=\"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/image-20211111231429427.png\" alt=\"使用版式\"/></p>\n<blockquote>\n<p>如果你原来的 PPT 内容不是依靠版式中的“占位框”排版，而是靠手动创建的文本框，那直接应用版式是不会修改你原来的内容的。</p>\n<p>换言之，如果想要达到批量、统一的排版效果，需要尽可能地应用版式给出的占位框，而不是手动创建的文本框。</p>\n</blockquote>\n<p>在“<strong>版式</strong>”选项下面一个“<strong>重置</strong>”，意思是重置到当前版式初始的样式。</p>\n<p>比如，版式中的文字样式设置的是纯文本，而 PPT 内容里修改为列表。点击“<strong>重置</strong>”会使得列表项消失，再次成为纯文本。</p>\n<h3>刷新修改后版式</h3>\n<p>版式修改后，有时候并不会自动应用到 PPT 内容上去，这种情况通常发生于在 PPT 内容中对占位框的位置、大小等等进行了调整。</p>\n<p>比如在 PPT 内容中调整过的占位框位置，将不再随着版式更新。如果需要复位（让占位框位置能随着版式更新），可以再应用一次版式。</p>\n<h3>正在使用的版式</h3>\n<p>对于被用到了 PPT 内容上的版式，只有一个建议：<strong>不要随便删除版式里的元素！</strong></p>\n<p>这会导致已经被应用了版式的内容格式被清除……你需要去重新应用版式。</p>\n<hr/>\n<p>写在后面的吐槽：排版这种事情 <strong>Layout + 组件化</strong> 不香吗！PPT 的样式复用实在太局限了。看祖传的 PPT 排版看得我脑壳疼，每一页的小标题位置都不一样，字体也是用得乱七八糟的。排版的四原则，“亲密”“对齐”“对比”“重复”，每一项都很重要。但一项都不满足这是怎么做到的！强迫症（伪）哭晕在厕所。</p>\n<p>其实还是祖传的习惯问题。比如 Word，小时候我也是有过一段时间空格排版居中……现在谁还空格排版居中，我见一个打一个（狗头）</p>",
            "url": "https://sansui233.com/posts/PPT母版的制作与使用方法",
            "title": "PPT母版的制作与使用方法",
            "summary": "自从接触了纯函数，刷算法题刷得举步维艰。",
            "date_modified": "2021-11-12T00:00:00.000Z",
            "date_published": "2021-11-12T00:00:00.000Z",
            "tags": [
                "工具"
            ]
        }
    ]
}