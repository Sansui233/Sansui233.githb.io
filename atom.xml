<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sansui233.com</id>
    <title>Sansui's blog</title>
    <updated>2023-11-09T00:27:01.006Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <author>
        <name>Sansui</name>
        <email>sansuilnm@gmail.com</email>
        <uri>https://sansui233.com/about.ico</uri>
    </author>
    <link rel="alternate" href="https://sansui233.com"/>
    <link rel="self" href="https://sansui233.com/atom.xml"/>
    <subtitle>记录学习和生活的个人博客</subtitle>
    <icon>https://sansui233.com/favicon.ico</icon>
    <rights>All rights reserved 2022, Sansui</rights>
    <entry>
        <title type="html"><![CDATA[碎碎念001]]></title>
        <id>https://sansui233.com/memos?id=2023-11-04 06:49</id>
        <link href="https://sansui233.com/memos"/>
        <updated>2023-11-03T22:49:00.000Z</updated>
        <content type="html"><![CDATA[<h2>2023-11-09 08:04:19</h2>
<p>即便是用的 windows，写博客的流程还是没什么变化。<br/>
以前在 mac 上时，就是 typora 写，alfred 动作一键上传。<br/>
现在在 win 上，还是 typora 写，Listary 动作一键上传。<br/>
连上传脚本都还是 .sh。ps1 和 bat 都不熟，问 chatgpt 的结果也有权限问题，太难用了。<br/>
不同的是，自从把 memos 模块做起来，我的碎碎念变多了。终于不用往大眼和推特倒垃圾了。</p>
<h2>2023-11-08 21:54:39</h2>
<p>简单糊了一下图片浏览器移动端的交互，不是很有细节，但能用。实现方式也不是我满意的，要滑动不闪屏一定得要三个容器，现在只有一个。但 bug 终于修没了……</p>
<p>但是桌面端……emmm 加了 touchevent 就没了桌面端的交互啊……汗，真要做好的话，事件还要先看设备再绑定，touch 和 mouse 的实现逻辑不一样。</p>
<p>但但但又但是，你也不能说支持 touch 的设备就不绑定 click 事件了。因为有一种设备叫触屏笔记本。</p>
<p>有人会说绑 pointer 不就好了。耐思，我本来也是这么想的，因为我最开始绑的就是pointer。直到我发现 pointerUp 在 safari 上基本是不能用的状态，cancel 和 leave 也一样，pointer 事件的触发过程远远没有 touch 事件稳定……</p>
<h2>2023-11-08 01:30:55</h2>
<p><span class="tag">#react </span>想要自定义 hook，但里面有依赖怎么办？react 不能检测 custom hook 的 dep 嵌套问题。</p>
<p>看了 stackoverflow，发现确实可以解决，但写起来和有那个大病似的。</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// my hook</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useHotKey</span>(<span class="hljs-params">command, listener, options</span>){
  <span class="hljs-comment">/*do something, but how about listener contains extra deps?*/</span> 
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">useWrapper</span>(<span class="hljs-params">reactHookAsDep: <span class="hljs-built_in">any</span></span>){
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>{},[reactHookAsDep])
}

<span class="hljs-comment">// in your component</span>
<span class="hljs-title function_">useWrapper</span>(
  <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">useHotKey</span>(command, listener, options) <span class="hljs-comment">// execute your real custom hook</span>
  },[command, listener, option, extradep]) <span class="hljs-comment">// full check for all deps</span>
)
</code></pre>
<p>如果不想定义wrapper，那就在组件里直接 useEffect 再 usememo ……没想到吧，dep 参数还能这么用！但依然有 warning，说 dependency 太复杂了</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// in your component</span>
<span class="hljs-title function_">useEffect</span>(()={},[
  <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">()=&gt;</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">listener</span> = (<span class="hljs-params"></span>) =&gt; { <span class="hljs-comment">/*do something with extra deps*/</span> }
    <span class="hljs-title function_">useHotKey</span>(command, listener, options) <span class="hljs-comment">// execute your real custom hook</span>
  },[command, option, extradep])
])
</code></pre>
<p>我的评价还是有病，新人看不懂的写法类型。宁愿关 warning，发现有状态不刷新的 bug 再调都行……主要还是得靠理解和代码习惯，不然你 lint 倒是直接禁止在顶层调用参数有 function 的 usehook 啊……新人写那还不是直接用，谁会上来就知道套娃写……</p>
<h2>2023-11-06 21:20:06</h2>
<p>这是一条有关于 <span class="tag">#博客 </span>图片组件的交互测试。 #漫画</p>
<p>测试内容是多图条漫，两条的宽度还不一样哈哈。主要就是测一个极端的比例。已经不能开 typora 了，滑不到头简直要命。我的图上传前都有压缩过，先转 webp，然后压缩 80%。如果是尺寸大一点的图可以压 90%.</p>
<p>……safari，你可真是666，长按后图片二进制就无了……那么大一张图在那，标准的html元素，按了就无了，这要我怎么debug……还有底部占空间……我还是先以桌面端为主吧，移动端只是个顺便。</p>
<p>还有一些问题是如果工具要做的话，交互也要一块做。放大缩小拖动边界判定。移动端禁滚动。</p>
<p><img src="https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202311062132690.webp" alt="1"/>
<img src="https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202311062133783.webp" alt="2"/></p>
<h2>2023-11-06 19:18:22</h2>
<p>突然好喜欢可爱的字体哇~</p>
<p>好想用 consolas 做 UI font，这个有点可爱气质的打字机字体竟然意外适合，找不到任何一个替代品。可惜 mono font 因为等宽空格的关系，中英混排不行。我又是一个非常喜欢在中英文之间打空格的人。最后还是折中用了万能的 IBM Plex Sans。IBM Plex Sans 正文无敌强，和中文搭配也非常好。但是写 UI 的话就显得有点挤了。</p>
<p>UI 字体要和 正文搭起来挺难的。英文字体的搭配主要看几个基线，还有宽度和间距。基本比例一样的都行。但在不同字体间，要找比例一致字体的是一件极其困难的事，因为很容易没特色。IBM Plex Sans 和 arial 的比例就非常接近，只有宽度和风格区别。</p>
<h2>2023-11-05 21:04:56</h2>
<p>以一个极其复杂的方式解决了 <span class="tag">#mdx </span>渲染后的标签点击事件绑定问题。因为这不是 html 原生标签的替换，就有一点点麻烦。最后是从自定义 remark 的 AST 入手，直接解析后转换标签为对应的 estree 节点，再加上三次传 clickhandler，闭包持有 clickhandler，进行元素替换，终于绑上了……不愿再来一次，有这种需求应该直接写一个替换的框架。</p>
<p>所以我终于可以进行下一步了吗，写 img 相关的组件。但是其实 memo 后端 parse 还有bug，突然到某一条就停了。重构了之后 bug 真的多……search组件还没统一拆出来呢，可以说是因为不会……但主要还是设计问题，没有想好移动端和桌面端怎么做才能统一，不要渲染两遍……还有目录，目录又应该放哪。目录和导航，选一个没吧……</p>
<h2>2023-11-05 02:51:44</h2>
<p>scroll bar 好烦！！！还没有一个好的思路来处理 scroll bar 时隐时现导致样式shift的问题。</p>]]></content>
        <category label="Diary"/>
        <published>2023-11-03T22:49:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[重读《小王子》]]></title>
        <id>https://sansui233.com/posts/2023-10-09-the-little-prince-review</id>
        <link href="https://sansui233.com/posts/2023-10-09-the-little-prince-review"/>
        <updated>2023-10-09T13:56:00.000Z</updated>
        <summary type="html"><![CDATA[以故事写作的角度重读世界名著《小王子》]]></summary>
        <content type="html"><![CDATA[<p>《小王子》在不同年龄阶段都看过，中译和原著也都读过，当时只是觉得有趣。但尝试自己写故事后，才惊觉其实所有的有趣都是是作者的刻意表达。</p>
<p>仅仅以生活中的“有趣”与“想象力”写出的故事远远不够，别人看起来并没有你认为的那么有趣，内核是空洞的。</p>
<p>人在成年人后，所经历的一切容易让笔下故事的发展陷入自身所见所闻，很难写出孩子般质朴的想象，无法逃离现实的束缚。</p>
<p>举个例子，如果你的故事需要一个超现实的“天体引力”进行推动，你会用怎样的方式让这样的力产生？</p>
<p>我搜集了很多宇宙的资料，试图从中找到什么想法。但事实上我并不是想写硬科幻，也没人想在简短的剧情中读一大堆物理考据。</p>
<p>我对此一筹莫展，觉得怎样都编不出一个合理的解释……最后决定拉出上帝作为隐喻，上帝按自己心意去裁定天体引力。听起来很离谱吧，就好像是小孩子的瞎想，仅仅是“上帝裁定天体引力”不也是一具无意义空壳吗？但如果将这个设定赋予别的象征，就不再是无意义的。或者说，我其实是想象征什么，才拉出一个离谱的上帝。不过这个处理我也并不满意，但一时想不到更好的方法。</p>
<p>幻想的意义不在于幻想本身，而是幻想对故事带来的推动。感到有趣的事在深入思考后也不仅是罕见、超现实的表象，它会带来的新体验，又或者：“喜剧的内核是悲剧”。</p>
<p>今天复看《小王子》，试图从写故事的角度去理解，作者在下笔时是带着怎样的想法与心情呢？或是单纯是觉得有趣吗？怎么想出这些光怪陆离的可爱小故事？我是一个强逻辑性的Ne人，这样的思考也许能提高一下Ni的水平，带来一些不一样的启发。</p>
<h2>第1章</h2>
<p>介绍“我”与“大人”之间的区别。</p>
<p>“我”在成为大人后 ，依然有着孩子般的心灵。如果不是这样，后文的“我”将是一个很难理解小王子的大人。体现这一点是“蛇吞象”与“帽子”的故事（作者真的很会想）。大人看东西只关注现实，不现实的事情对于大人毫无意义。</p>
<h2>第2-7章</h2>
<p>介绍小王子的由来。</p>
<p>“我”困在沙漠中时遇到来自另一个星球的小王子，一个礼貌的、有点忧伤的小王子。小王子想要我画一只绵羊给他，但挑三拣四，最后对一只藏在箱子里看不见的小绵羊表示满意，还觉得小羊在箱子里睡着了。</p>
<p>为什么想到在这里安排这么一只奇怪的绵羊，如果仅仅想有趣，那安排一只会走钢丝的山羊不行吗？读到最后才隐隐有了答案——美丽的事物往往是不被看见的，这也许是“箱子里的羊”的动机。</p>
<p>第6章的写小王子星球上的猴面包树。从编剧的角度，不描写羊吃什么食物也无伤故事发展，但写了，还写的是特别具体也不常见的猴面包树，大概是有什么想法在里面的。猴面包树是会无限扩张的、不好的东西，但这和小王子的生活有什么关系呢，也就是多了一些并不让人开心的日常打扫。</p>
<p>我不认为这里是象征自私的欲望、野心，小王子的星球上没有出现这类元素的必要性，含义也并不太深刻，在后续别的星球遇到更合理。后来看知乎上感觉有一个（我认为）挺靠谱的说法：</p>
<blockquote>
<p>作者发表时正值二战期间，作者是一名法国人，国土沦丧旅居纽约。旅居纽约的法国人又分成戴高乐派和维希派，他想劝告两派捐弃前嫌共同对敌，却遭到两派的夹攻，非常无奈，这三棵灌木正是代表法西斯的德国、意大利和日本。</p>
</blockquote>
<p>破坏这份宁静的、疯长的、夺取人生存空间的猴面包树。</p>
<p>然后引出了对于小王子最重要的玫瑰花。作者是先想到绵羊再编出的玫瑰花，还是本来就想写玫瑰花与小王子的故事、再编出绵羊？如果以先写大纲让剧情先行的角度，我偏向于后者。无论以何种方式开始，绵羊和玫瑰花的情节是精妙契合的。情节的前后衔接一向不是一个简单的事情，如果先写剧情可能人物 ooc，如果先写人物可能会想不出后续，好多长篇就是这么坑掉的……</p>
<p>这部分里还有一些别的情节，比如说谈到小王子的星球叫做行星 B612 时，讽刺了大人们喜欢以衣冠取人，关注外在与代号，不关注人的本质。</p>
<p>小王子的星球上还有两座活火山一座死火山，非常有趣的脑洞，对剧情发展没什么用但并不觉得无聊，气质很符合小王子的星球（氛围渲染也是有必要的？）。小王子有一天最多看了43次日落，后文对不同星球的日落次数描写对比起来也非常有趣。至此基本表现出了小王子日常生活。</p>
<h2>第8-9章</h2>
<p>玫瑰花与小王子的相处这两章浪漫温柔，明显以人物情感先行，对话自然发生。剧情上没有太多刻意安排。有刻意安排的剧情是小王子最后一时冲动生了玫瑰花的气，离星出走。虽说是生气了，但看起来还是十分的文艺……整个文笔的基调就是这样的，very童话。</p>
<h2>第10-15章</h2>
<p>离星出走章节。不同星球上住着不同的奇怪大人，写得非常直白。后面有许多章节都会显得较为独立且直白，是娓娓道来的日常故事。</p>
<p>第10章：有理性但放不下权威架子的大人。</p>
<p>第11章：爱慕虚荣的大人。</p>
<p>第12章：永远在犯同样错误的酒鬼。非常短，像四格漫画一样，但闭环的对白好有趣。</p>
<p>第13章：除了钱和财产再脑子也容不下别的东西的商人。一些人看到什么东西就觉得是自己的，什么也不做就想据为己有，像是在讽刺资本主义的起源嗯……</p>
<p>第14章：守规矩的、不知变通的打工人。观看一千多次日落这个吐槽也很有趣，像是人物先行写出来的。</p>
<p>第15章：不出门的地理学家。看到好多模板的影子：不深入基层的高高在上的 leader、掉书袋不实践的人、把别人的成果据为己有的人、不切实际的甲方。地理学家知道地球，但连自己的星球上有没有大洋和火山都不知道，却觉得理所当然。</p>
<h2>第16-19章</h2>
<p>小王子来地球的见闻。</p>
<p>第16章介绍地球。</p>
<p>第17章小王子来到地球寻找人类，第一个遇见的毒蛇是为以后小王子回家埋下的伏笔（好残忍）。</p>
<p>第18章向花问路的写作视角很有趣。以花的视角，人没有根，所以被风送走了。</p>
<p>第19章的回声有点类似空镜的作用？我不理解，但隐约觉得好像是有用的，好可爱。</p>
<h2>第20-21章</h2>
<p>算是主线章节（？）很多玫瑰的花圃，小王子最初知道自己的玫瑰在外形上不是独一无二的后，很伤心。但小狐狸的出现又让他明白了</p>
<blockquote>
<p><strong>正是因为小王子在玫瑰身上花费的时间，才使得玫瑰变得如此珍贵。因此单她一朵，就胜过了这世间所有。</strong></p>
</blockquote>
<p>此外小狐狸还教会了他仪式感。</p>
<h2>第22-23章</h2>
<p>永远在向往别处，行色匆匆，忽视脚下风景的人。</p>
<p>永远在节省时间，追求效率的现代人。</p>
<h2>第24-25章</h2>
<p>沙漠里的井水，突出主题的两章，和星星上的玫瑰花一样。这个情节的设置和作者的自身经历有关，对于没有经历过的人而言难以复刻。</p>
<blockquote>
<p>“沙漠美丽，因为沙漠的某处隐藏着一口井。”</p>
</blockquote>
<blockquote>
<p>“房子也好，星星、沙漠也好，美化他们的东西，是肉眼看不见的。”</p>
</blockquote>
<h2>第26-27章</h2>
<p>小王子通过死亡回去了，“我”不舍。这两章人物先行，对白比较重要。</p>
<p>总体感想是，这是一本给成年人读的童话。我清楚记得我小学时看到第一章，只觉得这是一个有点可爱的怪孩子。到高中时，可以感受到文笔有童话的美好，但并不太理解作者要表达什么。大学时看原著也没有懂，纯学英文去了。直到现在才对里面的情节有所体会。小王子的“童真”是人在成长过程中需要慢慢获得的，是成年人的反思，在小时候的记忆中类似的想法我从未存在过。小时候反而会现实得多，真正的小孩子有着更原始更本能的残酷。</p>
<p>语文考试总是在问“作者在这一段想要表达什么”，小时候总觉得有时候是出题想太多。现在觉得，不是的，但也不应该有标准答案。刻意设计的剧作可以解释，很多人带着心情自然而然书写而成的东西，自己也是无法准确剖析的。剖析自己对每个人都是困难的，何况是一纸之隔的他人呢。</p>]]></content>
        <category label="书评"/>
        <published>2023-10-09T13:56:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows 调整之中文字体]]></title>
        <id>https://sansui233.com/posts/2023-09-29-windows-system-chinese-fonts-adjustment</id>
        <link href="https://sansui233.com/posts/2023-09-29-windows-system-chinese-fonts-adjustment"/>
        <updated>2023-09-29T02:25:00.000Z</updated>
        <summary type="html"><![CDATA[让 windows11 字体更好看的一些设置与字体浅谈]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>以下仅适用于低于 4k 缩放 200% 的显示器</p>
</blockquote>
<p>微软雅黑作为随着 Windows7 出现的字体，加上遥遥领先（？）的 ClearType，在当时的 1080p 显示器上十分清晰易读。</p>
<p>但如今的显示器分辨率越来越高，旧版微软雅黑的设计存在着明显的缺陷。</p>
<p>一是其字形设计并不平衡，中宫过大，有的字形可以以难看来形容；二是微软雅黑字形只在 4K 屏上有着准确的显示。如果你不巧像我一样用着 2.5K 屏，在 ClearType 的加持下，仔细观察资源管理器侧边栏中，“桌面”二字短横的间距并不平衡。</p>
<p>微软曾经设计过“另一版的微软雅黑”，即 Noble Scarlet，但不知出于何种原因并没有在正式的系统中使用。这一版字体设计依然中宫偏大，但相对老版收敛了不少，平衡了一些。据传言汉字部分是兰亭黑 Pro。</p>
<p>但这个字体在标点处理上很差，最直观的就是中文引号，太像西文的处理方式，很难看出前引号与后引号的区别。其实我在写这一篇文的时候，换了 Typora 的字体，才发现前后引号全打反了……</p>
<p>个人推荐的配置和工具如下：</p>
<ul>
<li><strong>Noble Scarlet</strong>  替换系统的微软雅黑。由于版权原因无官方公开链接，需自行搜索</li>
<li>系统字体替换工具：自行搜索 “字体替换工具 by 随风飘扬”。win7 时代的产物，太古老了找不到原作者出处。替换完后最好重启，否则可能有一些错误，比如字体大小错误。另外，github 上还有一个非侵入式的系统字体替换工具 <a href="https://github.com/Tatsu-syo/noMeiryoUI">noMeiryoUI</a>，但是换不全，只是作为预览不同字体在系统上的效果倒是个很不错的工具。</li>
<li><a href="https://www.mactype.net/"><strong>MacType</strong></a> 改善 ClearType 丢细节带来的不平衡</li>
<li>安装一个 <strong>苹方</strong>。有一些中文网站 Fallback Font 也是苹方在前。由于版权原因无官方公开链接，需自行搜索。浏览器对于字体的渲染不受 MacType 的影响，在PPI不足的情况下，浏览器的渲染是偏细的，默认设置还得是微软雅黑。</li>
<li><strong><a href="https://source.typekit.com/source-han-serif/cn/">思源宋体</a></strong>：推荐将浏览器的 Serif 字体设置为此字体。默认的宋体真的，不论中文英文，都很丑……只适合打印。</li>
</ul>
<p>苹方是一款设计上很优秀的字体，但它对于低 PPI 的显示器不友好，人话说，不是4K屏缩放200%都别用。首先苹方粗体相对其他黑体本身就较细，在 ClearType 下，苹方被削掉的细节使得其字重偏小，Bold 看起来像 Medium。另外，苹方在 2.5K 屏上表现非常糊，毕竟苹方问世时已经 Retina 屏已经出了好久了，人家压根没考虑过在低 PPI 屏幕上的表现。最后是版权问题，当然苹果大概不会因为这点事起诉个人用户。</p>
<p>更纱黑体也非常适合作为 windows 的系统字体，在 1080p 和 2.5k 下都能保证良好的清晰度。相比起微软的两款字体，更纱黑体可以称得上是秀气了，但汉字覆盖率不如系统级别的字体。自己看下来，更纱黑体与思源黑体设计的细节不太统一，比如“用”字明显矮了一截，使句子看起来不太稳定。但是在宋体设计上，“用”字矮的这一截反而让字体看起来平衡。一个系列的字体的统一感和比例关系又很大，个人理解为思源/更纱系列是优先考虑宋体的字形，但也不是传统的宋体字形，和黑体的比例有一定的结合。整体而言还是宋体的设计更加优秀。</p>
<p>思源黑体作为更纱黑体的前辈，是不太适合低 ppi 屏的，它的 Regular 字重看起来像 Bold。</p>]]></content>
        <category label="工具"/>
        <published>2023-09-29T02:25:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[Minecraft v1.20常用设置]]></title>
        <id>https://sansui233.com/posts/2023-09-26-minecraft-settings-for-v1-20</id>
        <link href="https://sansui233.com/posts/2023-09-26-minecraft-settings-for-v1-20"/>
        <updated>2023-09-26T02:38:00.000Z</updated>
        <summary type="html"><![CDATA[一些自用的Minecraft高版本常用设置]]></summary>
        <content type="html"><![CDATA[<p>在 Minecraft 1.20 版本光照引擎被大幅改写，使得帧数提升，模组的数量似乎又多了起来。另外在 fabric 发展起来以后，mod的社区生态有了很大的变化，有很多老牌模组有了更新的替代。现在记录一下实现常用的基本功能需要的模组与修改设置。</p>
<p>我使用的 hmcl 启动器，在其中进行模组下载可显示模组间的依赖情况。以下内容在1.20.1中完全兼容，且项目均在维护中。</p>
<h2>Mods</h2>
<p>使用以 fabric-api 构建的模组。</p>
<h3>渲染类</h3>
<ul>
<li>Sodium: 渲染优化之神，许多模组的前置</li>
<li>Sodium-extra: 渲染优化之神的扩展，相应 GUI 为reeses sodium options</li>
<li>Lithium: 原版机制的算法改进</li>
<li>Iris: Sodium 加光影</li>
<li>Custom Entity Models: 自定义实体模型，增强对 optifine 材质包的支持</li>
<li>Continuity: 无缝纹理，安装后需要启用相应的材质包</li>
<li>Indium: 许多模组的前置，提供 Fabric Rendering API的支持</li>
</ul>
<h3>功能类</h3>
<ul>
<li>modmenu: 显示所有模组和相应的设置页面（如果有的话）</li>
<li>carpet: 单人生存必备，可使用命令放置假人以常加载区块刷红石</li>
<li>tweakeroo: 一系列微调的小功能。主要使用 freecamera（灵魂出窍）以获得更好的摄影视角，zoom 开启类似 optifine 的按 c 视角放大，handrestock 可自动补货手里的工具、方块</li>
<li>JourneyMap: 小地图，降肝度必备。Xae 的小地图也不错，两者都需要设置一下显示的东西，默认会非常多，我只开启了玩家、时间、坐标。关闭了各种网络显示和生物显示。</li>
<li>Invertory Profile Next: 高版本的 R 键背包整理，强迫症必备。另有捡物品时默认扔到背包中，以及在打开箱子时使用滚轮移动物品，个人非常喜欢，更快，且减少食指的腱鞘炎。</li>
<li>Roughly Enough Items: 物品搜索，查看合成配方、查看方块用途，ctrl点击后快速移动到合成台。尽管原版有合成书，但一页条目显示太少，且不支持拼音搜索，不支持模组物品。REI依旧方便很多。</li>
<li>imblock: 输入法冲突修复</li>
</ul>
<h2>设置</h2>
<ul>
<li>画面尺寸: 1920*1080@60fps，窗口化</li>
<li>视场角: 85</li>
<li>鼠标灵敏度: 75</li>
<li>模拟距离：8</li>
<li>渲染距离：10</li>
</ul>
<h3>快捷键修改</h3>
<p>首先把 ctrl 改到 capslock 键位，方便疾跑。系统全局 powertoys 改的（吐槽一万句control的键位）</p>
<ul>
<li>tab 长按: 快速显示背包中物品，在 tweakroo 中的 hotbarswapbase 设定</li>
<li>tab+1/2/3: 快捷键切换到背包中下一行。 tweakroo 中的 hotbarswap 每一行单独设定</li>
<li>j: 显示 jouneymap 小地图</li>
<li>m: 显示 jouneymap 大地图和设定</li>
<li>v: 切换第三人称视角，很常用的功能。原本是f5，实在太远了</li>
<li>f5:  灵魂出窍，在 tweakroo 的 freecamera 中设定</li>
<li>z: 望远镜，在 tweakroo 的 zoomactivate 中设定</li>
</ul>
<h4>合成台、箱子UI</h4>
<ul>
<li>y: REI 查看光标下物品的配方</li>
<li>u: REI 查看光标下物品用途</li>
<li>ctrl + 左键点击REI的物品，移动物品到合成台</li>
<li>r: Invertory Profile Next 整理。按 r+c 在 IPN 的设置中修改</li>
<li>使用滚轮以在背包和箱子间移动物品，按shift移动整组</li>
</ul>
<h2>光影</h2>
<ul>
<li>BSL v8.2.04，默认配置High，把 Camera 中的 Bloom 关闭，把 Atmosphere 中的 fog 调到 0.5，开启 lighting 中的handDynamicLight。抗锯齿的TAA随便开不开，取决于风扇响不响</li>
<li>Complementary Reimagined，默认配置 medium，high 会开启镜面反射运算量明显变大</li>
</ul>
<h2>材质</h2>
<ul>
<li>任意矿物发光材质。比如 <a href="https://www.curseforge.com/minecraft/texture-packs/new-glowing-ores">New Glowing Ores</a>。主要是因为 BSL 光影没有矿物发光，所以要加一个材质以确保有 fallback。</li>
<li><a href="https://afdian.net/a/Nan2uu">彩虹像素</a>，非常优秀的免费猛男材质包，原版风但更精致。有很多更可爱的附加包。</li>
</ul>]]></content>
        <category label="游戏"/>
        <published>2023-09-26T02:38:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows 调整之基础功能与常用插件]]></title>
        <id>https://sansui233.com/posts/2023-08-30-windows-tweak-and-enhancement</id>
        <link href="https://sansui233.com/posts/2023-08-30-windows-tweak-and-enhancement"/>
        <updated>2023-08-30T09:42:00.000Z</updated>
        <summary type="html"><![CDATA[让 windows11 变得更好用的一些自定义设置]]></summary>
        <content type="html"><![CDATA[<p>自从感觉内存硬盘越来越不够用，以及对老黄的显卡需求，从 mac 换成了多年不见的 windows11 。做了非常多的调整，至现在基本稳定，记录下来以供参考。</p>
<h2>基本调整与基础功能增强</h2>
<ul>
<li>
<p><strong>右键菜单</strong></p>
<p>使用 <a href="https://nilesoft.org/download">shell</a>，恢复被藏到“更多选项”中的的右键菜单项，同时保持 win11 的设计风格。并且带有用 vscode 打开和用 windows Terminal 打开。虽然说 Windows Terminal 自己也有一个“用终端打开”，但那个有 Bug，打开的目录会被两个程序同时占用句柄，导致无法对目录本身进行操作。</p>
</li>
<li>
<p><strong>批量重命名</strong></p>
<p>使用 <a href="https://learn.microsoft.com/en-us/windows/powertoys/">Powertoys</a> 中的 PowerRename，可选中多个文件后右键批量重命名，整理素材时太有用了。大致与 mac 的多文件重命名相同。缺点是不能改成 <code>同名称 + 编号</code> 。但系统自带的重命名恰好只能同名编号。Powertoys 有很多别的小工具，但都不够好用，按需关掉。</p>
</li>
<li>
<p><strong>快速预览</strong></p>
<p>使用 <a href="https://github.com/QL-Win/QuickLook">QL-Win/QuickLook</a> ，选中文件后按空格直接预览，再按空格关闭。对于看各种后缀的文本文件、zip 压缩包目录结构非常有用。也用了 mac 后没法割舍的一个功能。前面说的 Powertoys 也有，但快捷键一定要加 ctrl（真的难按），功能更少，图片不能显示大小，无法定制。</p>
</li>
<li>
<p><strong>文件快速搜索</strong></p>
<p>使用 <a href="https://www.voidtools.com/">Everything</a>，我大部分使用场景是在卸载程序后，清除残留的下载数据与用户数据。</p>
</li>
<li>
<p><strong>快速启动/全局搜索</strong></p>
<p><a href="https://fluentsearch.net/">Fluent Search</a>，按 <code>alt+ 空格 </code> 快速在中央唤起搜索栏以快速进入目录、启动程序。相比于 windows 自带的 search，可以搜索到绿色程序。相比于 <a href="https://www.flowlauncher.com/">Flow Launcher</a>，有好一万倍的排序。而更老的 <a href="https://www.listary.com/download">Listary</a>，无法搜索绿色软件，排序也很拉。经过多次对比后，只有 Fluent Search 能在大量同名目录中快速定位到我要找的目录，而不会被一堆杂乱的东西包裹。</p>
</li>
<li>
<p><strong>优化合集</strong></p>
<p><a href="https://github.com/hellzerg/optimizer">hellzerg/optimizer</a> 微调 windows 的合集程序，包括禁止系统更新、改 hosts 文件刷新 DNS、移除开机启动项、添加自定义右键菜单等。</p>
</li>
<li>
<p><strong>历史剪贴板</strong>：在 <code>设置→系统→剪贴板</code> 中启用。</p>
</li>
<li>
<p><strong>屏幕颜色配置文件(ICC Profile)</strong></p>
<p>在 <code>设置→屏幕→显示配置文件</code> 中，换成对应屏幕的sRGB文件。否则对于广色域屏幕，某些不读 ICC Profile 的照片查看器会出现色彩过饱和的情况。</p>
</li>
<li>
<p><strong>输入法</strong></p>
<p>微软输入法需要改成回车时键入英文，否则会清空，不方便中英混输。不过作为一个五笔用户，我现在使用的是基于 Rime 的 <a href="http://98wb.ysepan.com/">98五笔输入法</a> 和 <a href="https://github.com/Sansui233/98wubi">我的配置</a>。<del>因为微软输入法 shift 加 空格会标点变全角，而这个功能在中英混输时非常容易触发，还不能改掉，实在太弱智了</del></p>
</li>
<li>
<p><strong>关闭顶部自动布局</strong></p>
<p>关闭 <code>系统→多任务处理→贴靠窗口</code>。此功能乍一看非常贴心，实则非常容易阻碍鼠标精准排列窗口，尤其是想把上沿拉到顶部时。不建议使用鼠标时开启，更适合手指操控设备。</p>
</li>
<li>
<p><strong>多线程下载器</strong></p>
<p>使用 <a href="https://aria2.github.io/">aria2</a>，在网上抄了一个配置文件，并且让 chatgpt 写了一个开机自启脚本。面板使用的是 Chrome 插件 <a href="https://chrome.google.com/webstore/detail/mpkodccbngfoacfalldjimigbofkhgjn">Aria2 Explorer</a>，考虑到都是在浏览器中下载，没必要使用独立的客户端 App。</p>
</li>
<li>
<p><strong>与手机互传文件</strong>（折腾但稳定版）</p>
<p>使用 <a href="https://github.com/alist-org/alist">alist</a> 进行磁盘目录映射，并且使用 <a href="https://github.com/jeessy2/ddns-go/wiki">DDNS-Go</a> 动态绑定本机的 ipv6 地址到公网。手机上将相应的 alist 页面添加到主屏幕，便可在该页面互传文件。好处是能走局域网，速度快，不同网络环境下可用，可远程传输等等。依然让 chatgpt 写脚本将两个程序加入开机启动。</p>
</li>
</ul>
<h2>硬件调整</h2>
<ul>
<li>
<p>硬件信息监测</p>
<p>使用<a href="https://www.hwinfo.com/">hwinfo</a>的实时监测数据作为硬件调整的基准</p>
</li>
<li>
<p>功耗/风扇转速调整</p>
<p>使用 <a href="https://github.com/seerge/g-helper">g-helper</a> 调整日常使用的风扇曲线。我买的幻16，作为全能本，出厂的奥创调教特别垃，首发时还有bug。它的三种模式</p>
<ol>
<li>静音模式风扇完全不转，经常温度突然飙升很吵地转一会儿</li>
<li>性能模式开什么都以游戏本的方式转，对我来说挺吵的</li>
<li>增强模式的声音不是给人用的。</li>
</ol>
<p>如果用windows默认电源管理方案的话，似乎和程序资源占用有关，即使只有60度也给转上4000转。打个小游戏真的不配这么吵……</p>
<p>后面用g-helper关闭睿频，功耗限制35w。测下来开原神默认高画质 1080p 稳定在CPU 65度，风扇3500转，不卡。这代 GPU 的散热反而问题不大，至少玩原神不会超过60度。然后测试了带光影的 Minecraft 1.20.1。MC 对 CPU 的要求更高，不过单机的话，不刻意刷红石，35w也够了，一般在25w左右，温度还是差不多的65度，全程电压没有超过1V，降压对于控温还是很有用的。奥创之所以动不动就吵就是因为一开性能模式，什么都不干电压给到1.8V……没必要，真的没必要。</p>
<p>日常使用场景下，好像也就编译比较耗CPU，其他时候都用不到很好的CPU性能。图形处理还是占GPU更多。音乐制作一类的也是耗CPU但也还好，但更耗内存硬盘。</p>
</li>
</ul>
<h2>音频调整</h2>
<ul>
<li>
<p><strong><a href="https://sourceforge.net/projects/equalizerapo/files/">Equalizer APO</a></strong></p>
<p>调全局声音的均衡，需要搭配 <a href="https://github.com/jaakkopasanen/AutoEq">Autoeq</a> 仓库中说的 peace 插件使用（现在好像直接叫autoeq.app）。耳机发烧友的必备。注意蓝牙耳机无法使用卷积eq。</p>
</li>
<li>
<p><strong>内录用虚拟声卡：<a href="https://vb-audio.com/Cable/">VBCABLE_Driver</a></strong></p>
<p>网上有很多教程，为轻量级内录解决方案。另外如果系统带有 xbox，用 xbox 的录制视频是默认走的内录。</p>
</li>
<li>
<p><strong>降低 Midi 键盘延迟</strong></p>
<p>键盘连接电脑练琴，无独立声卡时，可用 <a href="https://asio4all.org/">ASIO4ALL</a> 降低延迟。效果显著。缺点是 ASIO 是设备独占的，比如宿主软件使用 ASIO 到耳机，那看 b 站视频就只能外放（或者别的耳机/音响）。</p>
</li>
</ul>]]></content>
        <category label="工具"/>
        <published>2023-08-30T09:42:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[图像超分辨率工具推荐]]></title>
        <id>https://sansui233.com/posts/20230822-Super_resolution_models_and_tools</id>
        <link href="https://sansui233.com/posts/20230822-Super_resolution_models_and_tools"/>
        <updated>2023-08-22T22:20:00.000Z</updated>
        <summary type="html"><![CDATA[AI图像放大模型+工具推荐]]></summary>
        <content type="html"><![CDATA[<p><del>推特</del>，现在叫 X.com，是我的桌面壁纸来源，但是推特的图压缩得非常糊，喜欢的动画人基本也只传 1080p 图，导致壁纸糊上加糊。因此需要使用 AI 放大模型进行图像处理。</p>
<ul>
<li>放大效果外链预览：<a href="https://imgsli.com/MjAwMDcx">Comparison</a></li>
<li>细节对比：<br/>
<img src="https://raw.githubusercontent.com/NamiLing/upic/master/picgo/comparison.jpg" alt=""/></li>
</ul>
<p>文章分为三个部分：</p>
<ul>
<li>图像处理工具</li>
<li>AI 图像放大模型</li>
<li>如何使用</li>
</ul>
<h2>图像处理工具</h2>
<h3>1. <a href="https://github.com/chaiNNer-org/chaiNNer">chaiNNer</a></h3>
<p>一个无代码的图像处理自动化工具，可以实现批量改大小、调色、压缩、拼接等等等。同时也支持用 AI 对图像放大，也能接入 Stable Diffusion 的工作节点，上限非常高。缺点没有内置模板，即便是很小的功能（比如文件批量重命名）都需要自己创建。</p>
<p>应用内置使用文档，不过不看文档也能一眼知道怎么用。</p>
<p><strong>只有英文，没有中文。</strong></p>
<ul>
<li>传送门：<a href="https://chainner.app/">chaiNNer</a></li>
</ul>
<h3>2. <a href="https://imagestool.com/zh_CN/">imagestool</a></h3>
<p>对于单张图和 gif 的常见处理小工具合集，网页打开即用，完全本地运行无隐私问题。特点是非常易用，支持小批量处理，支持 pipline，也就是说如果想在调整大小后转换格式再压缩，不需要每一步都上传下载图片，可以处理完每一步直接选下一步，只下载最终的处理结果。</p>
<ul>
<li>传送门：<a href="https://imagestool.com/zh_CN/">imagestool</a></li>
</ul>
<h2>AI 图像放大模型</h2>
<p>超分辨率成像(Super-Resolution，简称 SR) 是一种提高图像分辨率的技术，通俗的叫法就是图像放大。如果你曾经使用过 Photoshop 对小图进行放大，会发现放大后的边缘总是非常模糊，并且用锐化等操作无法弥补，这是传统方法的在图像放大上的缺陷。</p>
<p>但是神经网络（Neural Networks，简称NN）的出现对图像放大的效果带来了极大的提升，几年前就已经有不少 AI 图像放大的应用，但最近两年的模型效果尤其好。下面介绍几个现阶段应用上比较火的模型。</p>
<h3>1. <a href="https://github.com/JingyunLiang/SwinIR">SwinIR</a></h3>
<p>2021年基于 Transformer 的图像超分辨率模型，放大任何图片的效果都非常好。风格偏锐利且干净，且参数少，处理速度快。此模型分为 3 类，经典图像超分辨率（Classical image SR）、轻量级图像超分辨率（Lightweight image SR）、真实世界图像超分辨率（Real-world image SR）。</p>
<ul>
<li>下载链接： <a href="https://github.com/JingyunLiang/SwinIR/releases/tag/v0.0">Release  · JingyunLiang/SwinIR</a></li>
</ul>
<p>可下载的版本很多，不知道选哪个的就选 <a href="https://github.com/JingyunLiang/SwinIR/releases/download/v0.0/001_classicalSR_DIV2K_s48w8_SwinIR-M_x4.pth">001_classicalSR_DIV2K_s48w8_SwinIR-M_x4.pth</a> ，这个为4倍放大的模型，也是 Stable Diffusion 的 SwinIR 预置模型。</p>
<h3>2. <a href="https://github.com/xinntao/Real-ESRGAN">Real-ESRGAN</a></h3>
<p>2021年的经典图像超分辨率模型，这论文出来后大家疯狂在它基础上卷，基于 ESRGAN 改进的模型和论文非常非常多。不过最初的版本也已经足够好用。</p>
<p>下载链接：<a href="https://github.com/xinntao/Real-ESRGAN/releases">Releases · xinntao/Real-ESRGAN</a></p>
<p>依旧版本很多，不知道下哪个的下载 <a href="https://github.com/xinntao/Real-ESRGAN/releases/download/v0.1.1/RealESRNet_x4plus.pth">RealESRNet_x4plus.pth</a> 即可。</p>
<h3>3. 4x-AnimeSharp</h3>
<p>基于 ESRGAN 架构的动漫类放大，<del>可能由于训练集选得好</del>，在众多动漫类放大中它可以很好地处理景深，其他的Anime模型多少在景深部分会有一些清晰过度的问题，包括著名的 <a href="https://github.com/xinntao/Real-ESRGAN/releases/download/v0.2.2.4/RealESRGAN_x4plus_anime_6B.pth">RealESRGAN 动漫模型</a></p>
<ul>
<li>下载链接：<a href="https://openmodeldb.info/models/4x-AnimeSharp">AnimeSharp - OpenModelDB</a></li>
</ul>
<p>OpenModelDB.info 上有更多的微调模型，可以试试。总体来说，AI 放大的图像质量目前来说还是乍一看可以，涉及商用美术的话质量仍然不过关。<del>如果商用美术能过关，岂不是能画糊图然后丢AI出高精图了。</del> 作为壁纸放大非常合适，即便是补充的细节不能推敲，但把像素精度补齐到屏幕分辨率带来的视觉提升也是非常大的。4k 壁纸就是比 1080p 看起来舒服。</p>
<h2>如何使用</h2>
<p>使用 chaiNNer 时可照抄下图结构，使用 4x-AnimeSharp 模型放大原图、重命名图片并保存。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/picgo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-22%20213633.jpg" alt="chaiNNer"/></p>
<p>如果使用的是 <a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">stable-diffusion-webui</a> ，Extra Network 选项卡中也有预置模型，可以使用 SwinIR 和 ESRGAN。</p>
<hr/>
<p>可能对您有用的资料：</p>
<ul>
<li><a href="https://openmodeldb.info/models/4x-AnimeSharp">4x-AnimeSharp</a></li>
<li><a href="https://phhofm.github.io/upscale/">Interactive Visual Comparison of Upscaling Models</a></li>
</ul>
<hr/>
<p>PS：我在尽力不要让语句变得不要和写论文一样啰嗦，但总是难以避免……以及我原本想写个内置的交互式组件来演示图像前后的区别，这也是我最初架构博客时选用 mdx 的原因，但真的开始写的时候……怎么还要多写一个东西？好麻烦！还要考虑 rss 兼容的问题，之后再补吧，现在写什么都像坐牢。</p>
<p>PPS：强烈建议无代码应用都能开发个template market……</p>]]></content>
        <category label="工具"/>
        <published>2023-08-22T22:20:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stable Diffusion AI 绘画的实用经验与总结]]></title>
        <id>https://sansui233.com/posts/2023-02-20-stable-diffusion-AI-experience</id>
        <link href="https://sansui233.com/posts/2023-02-20-stable-diffusion-AI-experience"/>
        <updated>2023-02-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[AI 画画现状]]></summary>
        <content type="html"><![CDATA[<p>2023-03-03：待大量补充和修订。</p>
<hr/>
<p>进阶经验，非科普。分为五个部分：模型选择，分辨率调整，采样方法，ControlNet，Lora概述。</p>
<p>此文章涉及多平台发布，由于生成类 AI 的争议，文中无外链推荐。</p>
<h2>一、模型选择</h2>
<p>模型影响构图和笔触和色彩，决定成图的平均水平。社区经常都在换流行的模型，还是根据需求定，huggingface 和 civitai 上很多。</p>
<p>二次元目前主流三家 Anything Orange Counterfeit 。</p>
<p>目前有不少混合了 2D 和 3D 的 2.5D 模型，用来出 cos 的，个人不喜欢。</p>
<p>下图模型为 pastel-mix，图片画质已严重压缩（看不见则需要开代理，如果你用的 Innoreader 手机版阅读此文，大概率被放头图了）</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/00153-2596022983-masterpiece,%20best%20quality,%20ultra-detailed,%20illustration,%201boy,%20Link%20in%20Breath%20of%20the%20wild,%20sun%20shine,water,%20on%20back,%20lying%20in%20wa.jpg" alt="pastel-mix"/></p>
<h3>模型精度选择</h3>
<p>fp-16(2G)，fp-32(4G)，full(7G) 用于生产没有肉眼可见的区别。full 主要是训练用的。fp16 生产够用了，快，占用小。</p>
<p>bf-16(2G) 相对 fp-16 会损失一小部分细节，不推荐，会发布 bf-16 版本的模型也较少。</p>
<h3>VAE权重网络</h3>
<p>影响色彩，主观效果是增加饱和度（比修图软件饱和度增强好太多）。目前流行的 VAE 就两个，一个 Waifu 的一个 Anything 的，很多带 vae 模型都是用的这两个改了个名字。</p>
<p>下图为 mix-pro-v3-fp16 模型，叠加了其配套的 WD vae 的 效果。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/00045-311454338-Original%20Characters,%201boy,%20sea%20shore,%20%20pastel-full.jpg" alt="Mix-pro-v3"/></p>
<h3>Prompt</h3>
<p>prompt（提示词）是玄学范围。不同模型的 prompt 词库不一，目前主流的词库有两个</p>
<ul>
<li>适用 SD v1.x 及其衍生模型的 lexica</li>
<li>适用二次元模型的 Danbooru。</li>
</ul>
<p>对于二次元模型，Prompt 指定物体，调整动作、指定颜色比较容易。取决于模型的泛化能力。</p>
<p>Prompt 难以精确控制画风，所以尽管上限非常高，但主流越来越不倾向于用大量 Prompt 叠 buf，转成微调模型以达成精确需求。</p>
<p>在两个月前关于 Prompt 研究的文档就已经非常多了，这里不做推荐，因为不看文档，直接翻译成英文大概率是有效的。</p>
<h3>文生图与图生图</h3>
<p>文生图与图生图本质上没有什么不同，文生图只是将图片输入换成了一张随机的噪声图。</p>
<h2>二、分辨率</h2>
<p>不同模型在生成时有最佳的分辨率，大部分都在 512px 左右，不超过 1024px。</p>
<p>提高分辨率不仅是单纯放大图片，AI 能够用模型细化图片。</p>
<h3>图生图</h3>
<p>img2img(图生图) 大部分时候被用来衍生，但是其效果最好的是将 txt2img 的低分辨率图放大（用同一个seed）。</p>
<p>在 web-ui 中，仅缩放(just-resize)为无 AI 的放大算法处理。 AI 放大使用的 Latent 方法即将被归入 Upscaler，也就是下面说的 Hires fix。</p>
<h3>Hires fix</h3>
<p>Hires fix（高清修复）的作用是用 AI 从小图生成高分辨率图，处理用得好可以提高大幅提高图片上限。upscaler（放大器）可选几种放大方法，其中的 Latent 就是 SD 的画图方法，文生图与图生图均是这个方法。</p>
<p>在 web-ui 中， 默认只有 txt2img 可用，因为 img2img 本身就可以做图片放大。另外，有专门的 upscaler 选项卡。</p>
<p>使用 Latent upscaler (图生图) 放大到高分辨率图涉及局部重绘，部分模型支持较好，如 Pastel。但在 512 px 完成度就很高的模型上通常没有效果，或者更差（比如炫彩厚涂），这种用 GAN 类 Upscaler 直接放大比较好。</p>
<p>值得注意的是 web-ui 的 Hires fix 有两版算法，目前 txt2img 是新版， img2img是旧版，效果有一些小差别，很难比较好坏。</p>
<h2>三、采样方法</h2>
<p>Sampler（采样方法） 决定笔触和结构的稳定性。常用的有：</p>
<ul>
<li>Euler a 是一个规整稳定的采样方法，出的图较平滑</li>
<li>DDIM 是一个过程不算稳定的采样方法，通常看起来比 Euler a 细节更多</li>
<li>DPM++ 2M Karas，最近在用的，过程稳定但有细节</li>
</ul>
<p>有部分 Sampler 对高分辨率（1024px 以上）支持不好。</p>
<h2>四、 ControlNet</h2>
<p>ControlNet 目前是一个需要额外安装的插件，可以用于给线稿上色并细化，或从草图细化。</p>
<p>你的草图可以决定的是：</p>
<ul>
<li>60%-100% 的线条位置（构图）</li>
<li>主要色块位置。需要搭配图生图，并且色块越碎越好，需要提前做好整体的光影效果。因为 大部分 AI 只会画整，会画碎的比较少（Pastel 会画碎）。</li>
</ul>
<p>细化风格（画风）由模型决定，不由你的草稿决定。模型风格对于画风影响非常关键。Prompt 也可以影响画风。</p>
<p>细化内容（画的具体是什么）由 Prompt 、草稿、模型共同决定，调整 CFG、Denoise 、 ControlNet 的 Weight 可改变三者比例。</p>
<p>下图为自己的较草的线稿使用 ControlNet 与 Anything V3.0 上色：</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/00275-3225619170-masterpiece,%20best%20quality,%20illustration,face,%20right%20hand,%20atomespheric,%20cold,%20sunshine,%20sky,,%20high%20detail,%20flowers%20and%20leafs.jpg" alt="Control-Net"/></p>
<p>（这个东西出名是因为某博说 ControlNet 初衷是洗稿……之前 Pixiv 也出过线稿上色的 AI，只是效果好和不好的差别，怎么没人说是搭配 PS 的线稿提取功能洗稿）</p>
<h2>五、Lora</h2>
<p>Lora 是一种训练小模型的方法，可以在 15 张图以上生成稳定的单个角色图。</p>
<p>已有大量角色图积累的流水线漫画苦力会比较省事，搭配 ControlNet 可生成固定姿势，或者使用线稿稳定地上色。但对于连续动作的细微差别不太行，细节演出表现依旧需要依赖线稿，或手动重绘</p>
<p>训练过程分为裁剪、自动打标、训练，最终生成约 100M 左右的 Lora 网络。Web-ui 已自带。</p>
<h2>写在后面</h2>
<p>风格迁移渐渐成熟了，过拟合的问题在逐渐减少。减少过拟合的最终解决思路，还是把端到端的网络，按需求拆成了人为可控的 pipline。个人认为 AI 如果真的要作为工具，模块化的 pipline 是终点。</p>
<p>直接出成图的是对已有作品的模拟，抽抽卡，融入不到创意的工作流。</p>
<p>但是在发展好之前，地球可能已经枯竭了。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/00162-1748765688-masterpiece,%20best%20quality,%20ultra-detailed,%20illustration,%201boy,%20Link%20in%20Breath%20of%20the%20wild,%20stronde%20hair,%20sun%20shine,water,%20emotio.jpg" alt="pastel-mix"/></p>]]></content>
        <category label="工具"/>
        <published>2023-02-21T00:00:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[部署饥荒联机版Linux服务器]]></title>
        <id>https://sansui233.com/posts/dontstarvetogether-linux-server</id>
        <link href="https://sansui233.com/posts/dontstarvetogether-linux-server"/>
        <updated>2022-12-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[此文为 Docker 版饥荒联机版服务器在 CentOS 下的部署教程。]]></summary>
        <content type="html"><![CDATA[<p>此文为 Docker 版饥荒联机版服务器在 CentOS 下的部署教程。</p>
<blockquote>
<p>为什么要部署Linux服务器？因为玩到后面，只要一联机连主机都卡，闲得想试</p>
</blockquote>
<p><a href="https://www.roci.ltd/dstserver/">这个中文教程</a>讲了native steam版的安装方法，包括了Cent OS缺少的库，坑全踩了一遍写得十分详细。官方文档实在太拉，基本就是没有文档，像跨平台缺库这种事情也没有解决，没有脚本。不过教程中对于网络环境问题与mod的配置方法提得不多。</p>
<p>我这里使用的是<a href="https://hub.docker.com/r/jamesits/dst-server">Docker版本</a>。优点是</p>
<ul>
<li>国内的云平台对于Dockerhub的加速后走内网流量，不使用公网流量下载镜像。而且国内的服务器公网下载速度堪忧。</li>
<li>Docker版本的文档写得对用户友好，易上手</li>
<li>文件管理集中，比较方便。原版服务器的mod和存档是分开放的</li>
</ul>
<p>也有一些在国内环境下比较要命的缺点</p>
<ul>
<li>网络环境原因，无法下载创意工坊mod。最近靠改 hosts 也不行了。</li>
<li>如果想开代理下载，docker容器开代理（设置环境变量）非常麻烦，具体来讲
<ol>
<li>如果每次开关代理都创建一个新的容器，Steam和游戏文件的更新都得再触发一次，又消耗流量又慢</li>
<li>如果动态修改容器的配置文件，docker需要重启才能生效，所有docker服务都得宕机一会儿</li>
</ol>
</li>
</ul>
<h2>准备</h2>
<ul>
<li>一台至少2G内存的服务器</li>
<li>使用ssh连接服务器、传输并管理文件的技能</li>
</ul>
<h2>Docker的安装</h2>
<p>由于涉及到Docker镜像和Dockerhub加速的问题，具体安装步骤建议看docker的文档和各个云平台。</p>
<p>我使用的腾讯云，见<a href="https://cloud.tencent.com/document/product/1207/45596">安装 Docker 并配置镜像加速源</a>，大约花费2分钟。</p>
<h2>服务器防火墙设置</h2>
<p>需要放行 10999，11000，12346，12347 这四个端口的UDP流量。</p>
<ul>
<li>在国内云平台的控制台-防火墙中，放行服务器的这四个端口</li>
<li>如果服务器上iptables有流量拦截，也需要放行</li>
</ul>
<h2>饥荒服务器镜像的启动</h2>
<pre><code class="hljs language-bash"><span class="hljs-built_in">mkdir</span> <span class="hljs-variable">${HOME}</span>/Klei <span class="hljs-comment"># 创建存放数据有文件夹</span>

<span class="hljs-comment"># 拉取镜像并在前台启动</span>
<span class="hljs-comment"># 由于Steam要更新，根据网络环境可能要等比较久的时间</span>
<span class="hljs-comment"># 如果实在无法连接，再考虑给容器挂个代理下载。但总体不建议容器挂代理，因为我不清楚挂代理后steam是连接到服务器的游戏端口还是连到代理的端口上去了，取消容器的代理也非常麻烦。</span>
docker run --name dst -v <span class="hljs-variable">${HOME}</span>/Klei:/data -p 10999-11000:10999-11000/udp -p 12346-12347:12346-12347/udp -it jamesits/dst-server:latest
</code></pre>
<p>以上命令执行期间，可以去准备一下游戏存档和Mod相关文件。</p>
<h2>准备游戏存档和Mod</h2>
<p>我使用的Mac，饥荒的游戏文件相关目录位于</p>
<pre><code class="hljs language-bash"><span class="hljs-comment"># 游戏存档</span>
SAVE_DIR=<span class="hljs-string">&quot;~/Documents/Klei/DoNotStarveTogether/324927772/Cluster_1&quot;</span>
<span class="hljs-comment"># mod下载目录</span>
MODS_DIR=<span class="hljs-string">&quot;~/Library/Application Support/Steam/steamapps/common/Don&#x27;t Starve Together/dontstarve_steam.app/Contents/mods&quot;</span> <span class="hljs-comment">#</span>

<span class="hljs-built_in">cd</span> <span class="hljs-variable">$SAVE_DIR</span> <span class="hljs-comment"># 进入存档目录</span>
</code></pre>
<p>windows可以在饥荒游戏内点数据打开游戏存档，并在Steam中查看游戏的安装目录。</p>
<h3>准备存档信息</h3>
<p>点开<a href="https://accounts.klei.com/account/info">饥荒的账号</a>，记下 <strong>Klei User ID</strong>。如果没有就注册一个。</p>
<p>然后，新建<code>adminlist.txt</code>，并写入你的<strong>Klei User ID。</strong></p>
<pre><code class="hljs language-bash">$ vim adminlist.txt
<span class="hljs-comment"># 写入以下内容</span>
你的Klei User ID
</code></pre>
<p>点开<a href="https://accounts.klei.com/account/game/servers?game=DontStarveTogether">自建饥荒服务器的页面</a>，新建一个服务器，记下生成的Server Token，其他不用管。</p>
<p>然后，新建 <code>cluster_token.txt</code>，并写入Server Token。</p>
<pre><code class="hljs language-bash">$ vim cluster_token.txt
<span class="hljs-comment"># 写入以下内容</span>
你的Server Token
</code></pre>
<h3>准备mods</h3>
<p>不开mod的可以跳过这一步。</p>
<p>由于国内环境没法下载mod，需要把对应的mod文件复制过来。我为了方便就全复制了</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">cp</span> -r <span class="hljs-string">&quot;<span class="hljs-variable">$MODS_DIR</span>&quot;</span> mods
</code></pre>
<p>先查看一下目前的存档开了哪些mod。</p>
<pre><code class="hljs language-bash">$ <span class="hljs-built_in">cat</span> Master/modoverrides.lua
<span class="hljs-comment"># 开启的mod</span>
<span class="hljs-built_in">return</span> {
  [<span class="hljs-string">&quot;workshop-1172839635&quot;</span>]={ configuration_options={ icebox_freeze=<span class="hljs-string">&quot;0.5&quot;</span> }, enabled=<span class="hljs-literal">true</span> },
  [<span class="hljs-string">&quot;workshop-1294206358&quot;</span>]={ configuration_options={  }, enabled=<span class="hljs-literal">true</span> },
}
</code></pre>
<p>然后，编辑 <code>mods/dedicated_server_mods_setup.lua</code> 文件，写入上面的mod编号</p>
<pre><code class="hljs language-bash">$ vim mods/dedicated_server_mods_setup.lua
<span class="hljs-comment"># 写入以下内容</span>
ServerModSetup(<span class="hljs-string">&quot;workshop-1294206358&quot;</span>)
ServerModSetup(<span class="hljs-string">&quot;workshop-1595631294&quot;</span>)
</code></pre>
<p>至此，游戏存档和mods就准备好了。</p>
<h2>转移游戏存档和Mods至服务器</h2>
<p>上传游戏存档到服务器。打包和上传文件我一般使用GUI操作，用命令行的话是这样</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">cd</span> ~/Documents/Klei/DoNotStarveTogether/324927772/
tar -cvf Cluster_1.tar.gz Cluster_1 
scp Cluster_1.tar.gz root@myserver:/Klei/
</code></pre>
<p>如果之前的服务器连接还在，等无新日志输出后使用control+c退出容器。如果已断开连接，重新用ssh登录服务器。</p>
<p>然后可以看到在服务器的 <code>~/Klei/DoNotStarveTogether</code> 中有了一个 <code>Cluster_1</code> 存档。</p>
<p><strong>转移游戏存档时，需要注意有两种情况（来自<a href="https://hub.docker.com/r/jamesits/dst-server">文档</a>）</strong></p>
<p>第一种情况是，如果自己的存档开启了洞穴，把自己的存档覆盖过去即可。</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">rm</span> -rf Cluster_1
tar -xvf Cluster_1.tar.gz
</code></pre>
<p>第二种情况是，自己的存档没有开启洞穴，需要</p>
<ol>
<li>在自己的电脑中，存档的上一级有个 <code>client_save</code> 。复制下面的除了 <code>session</code> 外的所有文件到服务器的 <code>Cluster_1/save</code> 。</li>
<li>自己存档中的 <code>Cluster_1/save/session</code> 需要删除，其他文件可以直接覆盖</li>
</ol>
<p>存档覆盖完毕后，启动容器</p>
<pre><code class="hljs language-bash">docker start -a dst
<span class="hljs-comment"># 如果最后输出了 Sim Pause 就代表 OK 了，按 ctrl + c 退出，容器继续后台运行</span>
</code></pre>
<p>我第一次装Mod启动时发生了一个莫名其妙的 <strong>Segmentation fault</strong>，程序退出了，但是第二次启动就好了。搜了一下<a href="https://github.com/Jamesits/docker-dst-server/issues/48">相关issue</a>，完全相同的情况，也是CentOS，偶尔发生，难稳定复现。</p>
<h2>游玩</h2>
<p>之前自己的存档叫什么名字就搜什么名字，加入就完事，好好玩吧w</p>
<hr/>
<p>参考资料：</p>
<ul>
<li><a href="https://hub.docker.com/r/jamesits/dst-server">jamesits/dst-server</a></li>
<li><a href="https://github.com/Jamesits/docker-dst-server/issues">docker-dst-server issue</a></li>
<li><a href="https://www.roci.ltd/dstserver/">饥荒独立服务器入门级快速搭建</a></li>
<li><a href="https://dontstarve.fandom.com/wiki/Guides/Don%E2%80%99t_Starve_Together_Dedicated_Servers">Guides/Don&#x27;t Starve Together Dedicated Servers - Fandom</a></li>
</ul>]]></content>
        <category label="游戏"/>
        <published>2022-12-28T00:00:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一道题排列组合题解]]></title>
        <id>https://sansui233.com/posts/记一道题排列组合题解</id>
        <link href="https://sansui233.com/posts/记一道题排列组合题解"/>
        <updated>2022-11-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[难得在网上遇到有认真在做题的人，在此表示深深的感谢。另外个人不太会写题解类的文，权当一个记事了。]]></summary>
        <content type="html"><![CDATA[<p>难得在网上遇到有认真在做题的人，在此表示深深的感谢。另外个人不太会写题解类的文，权当一个记事了。</p>
<h2>题目</h2>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/8B414946-F4D4-479C-9092-9AEA8EC26FA3.jpeg" alt="8B414946-F4D4-479C-9092-9AEA8EC26FA3.jpeg"/></p>
<p>题来自 tg 里玩 ai 的小水群，很多人第一眼是想全排列剪枝……阶乘的复杂度得瞎了。</p>
<p>不过看到求方案数，帮人面试时被动态规划虐过的直觉在告诉我，凡事让写方案数不枚举方案的，很可能能写动态规划。</p>
<p>于是从动态规划的方面想去了。</p>
<h2>关于素数</h2>
<p>这个题有一个非常奇怪的地方，就是要和为素数。我不禁想，和为素数是对解题方法有什么加成吗？</p>
<p>（其实因为我最初看走眼了，以为是子集里所有数为素数，且和为素数，还以为素数和有什么定理）</p>
<p>素数的特殊点在于乘法分解，至于加法上与一般数有什么不同，以凡人视角未曾听说。并且这题还并不限于子集中取用什么数。</p>
<p>综上，和为素数对解题方法不仅没有什么加成，反而是多了个如何判断一个数是不是素数的问题。</p>
<p>至于如何判断素数，在 Leetcode 204，略，也没什么很省时间的方法，就是筛，不算简单。</p>
<h2>子集动态规划</h2>
<p>既然素数对于解题思路没有加成，就按一般数处理，很快写出了下面的思路：</p>
<ol>
<li>一维dp中存下和为当前数的方案数</li>
<li>遍历更新dp，把新数n拆分成已有数+余数，按余数从大到小（已有数从小到大），把所有已有数的拆分方案加起来，再+1，即可得到当前数的子集数。
<ol>
<li>需要注意的是，为了保证不重复，也就是保证子集序列递增，已有数不会超过n/2（余数不会小于n/2）</li>
</ol>
</li>
<li>更新dp时，也要计算新数n是否为质数，是的话把其子集数加入最终结果（算质数见leetcode 204）</li>
<li>由于取值范围1-2000，最大和为1000^2，100w，也是dp要遍历的次数。</li>
</ol>
<p>下面的图是在解释什么叫“遍历但不用枚举子集”时写的，也是上述dp的步骤。</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/2E06B8C3-1DF4-492D-A009-55F4D7A041CE.jpeg" alt="img"/></p>
<p>发题人仔细看了，并且手动枚举了10个数后，指出，我这会漏掉10=1+2+3+4。（后面自己发现这样还漏了145和235，后面越漏越多）</p>
<p>仔细回顾了一下之前的思路，发现我的问题出在递增的判断上。我当时认为保证递增序列，只要保证已有数小于余数就行，所以余数&gt;2/n。</p>
<p>但不是的，比如n=10时，已有数为6，余数为4，6拆分为1+2+3就行，1234还是序列递增的。6拆分为2+4、1+5就不行。</p>
<p>归根结底就是我只把余数算了较大的一半，因为余数较大的一半肯定能保证序列递增。如果不想漏情况，余数要全部遍历，但怎么保证序列递增呢？比如6+4，如何只拆到1+2+3+4，不算1+5+4和2+4+4呢？</p>
<p>于是更新了一下递增的条件：</p>
<ul>
<li>已有数的拆分的子序列最大数小于余数，则拆分方案合法</li>
</ul>
<p>再更新dp时余数范围：</p>
<ul>
<li>余数从n取到1，分别计算子集数后再sum。</li>
</ul>
<p>这样可以保证思路没问题了，但这个“已有数的拆分的子序列最大数小于余数”，明显当前dp只统计了子集数，根本不知道各个子集中具体最大数的情况。因此，我改成了个二维dp，含义和过程如下图：</p>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/6D139DD5-A95F-4467-BA58-3B5E61D9207D.jpeg" alt="img"/></p>
<p>简单总结一下，整个问题我简化到了求“和为 n 的子集数”，并利用二维动规从 1 求到 n。 n 是不是素数单独算的。</p>
<p>并且发现，其实更新每一行时，都是把上一行为止的方阵以“/”方向45度拆开，mask掉右边部分，按行求和后，从右往左地写进下一行，还能用gpu加个速（不是）。</p>
<h2>另一种解法</h2>
<p>发题人在看了我的新方案后，说在上面看到了类似杨辉三角之类的东西。并且得出了另一个方案：</p>
<blockquote>
<p>和为 n 的子集组合数，为多项式 (x^n+1)(x^(n-1)+1)(x^(n-2)+1)…(x+1) 的 x^n 项系数</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/NamiLing/upic/master/uPic/IMG_5434.JPG" alt="多项式展开"/></p>
<p>（我本来没理解，是死缠烂打地问才知道他在说什么）</p>
<p>仔细一想真的是这个理， x^n 对应的多项式系数就是排列组合到 n 的所有方案数了，也天然没有重复用数的问题。怎么想到的，神。</p>
<p>所以现在问题是：怎么求 (x^n+1)(x^(n-1)+1)(x^(n-2)+1)…(x+1)的多项式系数。</p>
<p>（当时已经不想动脑了，又是死缠烂打地问）</p>
<p>其实迭代就能算，因为 F(n) = x^n • F(n-1) + F(n-1)，对应系数直接挪位置后复制粘贴再相加就好了。</p>
<h2>空间复杂度</h2>
<p>这里有点难以定义 n 具体指哪个，默认 n = 2000 。</p>
<p>我的解法是要 1000^4 的空间去存方案数，矩阵中有很多地方是空的，有点浪费。</p>
<p>后者的解法要1000^2 空间去存多项式系数。省很多。</p>
<h2>时间复杂度</h2>
<p>以我的动规方法，时间复杂度为在 O(n^6)，准确说是O(n^2(n^2+1)(2n^2+1)/6)，因为要算到 (n/2)^2，且内部还有已填矩阵按行遍历。</p>
<p>以后者的的解法，时间复杂度为 O(n^3)，因为多项式的 n 需要到 (n/2)^2。</p>
<p>线性筛到 (n/2)^2 的素数, 时间复杂度为 O(n^2)。</p>
<hr/>
<p>总得来说还是数学好的强啊。</p>
<p>另外还有一个人非让我看完一个 30 分钟的高斯素数判断法，结果我一直在想 dp，搞得他怨念深重 hh</p>]]></content>
        <category label="学习"/>
        <published>2022-11-18T00:00:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解 Rust 闭包与环境变量所有权]]></title>
        <id>https://sansui233.com/posts/rust-closure-and-ownership</id>
        <link href="https://sansui233.com/posts/rust-closure-and-ownership"/>
        <updated>2022-06-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[B站反查用户弹幕小记]]></summary>
        <content type="html"><![CDATA[<p>本文将以（自认为）最简单易懂的方式讲述 Rust 中的闭包与环境变量所有权的关系。在现存的类似中文教程中，要么语言表述歧义太大，逻辑上难以理清；要么试图把事情总结得过于复杂。实际上闭包对于环境变量所有权的处理规则是非常简单的。</p>
<p>阅读本文需要的基础： Rust 变量的所有权、引用与借用、函数、traits。</p>
<h2>什么是 Rust 的闭包</h2>
<p>Rust 中的闭包是<strong>一种函数</strong>。与 Rust 普通函数不同，它可以<strong>捕获函数外部的变量并使用</strong>。</p>
<p>基本语法：<code>|参数列表| {函数体}</code></p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = |y: <span class="hljs-type">i32</span>| { x + y }; <span class="hljs-comment">// 说明： 闭包 sum 接收一个参数 y，且捕获前面的 x = 1, 返回 x + y</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, <span class="hljs-title function_ invoke__">sum</span>(<span class="hljs-number">99</span>)); <span class="hljs-comment">// 输出 100</span>

    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum2</span> = |y :<span class="hljs-type">i32</span>| x + y + <span class="hljs-number">1</span>; <span class="hljs-comment">// 也可以省略花括号</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, <span class="hljs-title function_ invoke__">sum2</span>(<span class="hljs-number">99</span>)); <span class="hljs-comment">// 输出 101</span>
}
</code></pre>
<blockquote>
<p>说明： 闭包 sum 接收一个参数 y，返回 x + y。其中 x 是第一行定义的 <code>let x = 1;</code> ，为闭包外部的变量。</p>
</blockquote>
<p>像 <code>x</code> 这样在定义在闭包外部、可被闭包直接访问的变量，我们称为“<strong>环境变量</strong>”。</p>
<h2>闭包中环境变量的所有权</h2>
<p>有 rust 基础的人应该知道，普通的 rust 函数的传入参数有三种形式</p>
<ol>
<li>所有权 move（默认行为）。</li>
<li>可变借用，形式为 <code>&amp;mut param</code></li>
<li>不可变借用 ，形式为 <code>&amp;param</code></li>
</ol>
<blockquote>
<p>上述为 rust 所有权基础知识，不再赘述。</p>
</blockquote>
<p>普通的 rust 函数可以使用参数，但无法使用环境变量。闭包则加上了 <strong>捕获当前环境变量</strong> 的功能。</p>
<p><strong>捕获当前环境变量</strong> 仅仅是指闭包 “知道有哪些环境变量”。闭包在使用环境变量时，依然可能会对环境变量执行三种操作：</p>
<ol>
<li>所有权 move</li>
<li>可变借用</li>
<li>不可变借用</li>
</ol>
<p>具体是执行了哪种操作呢？这个问题就比较复杂了，我们可以从上面的例子出发。</p>
<p>回顾上面的例子，对于环境变量 <code>x</code> ，首先排除了所有权 move。</p>
<pre><code class="hljs language-rust">    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = |y: <span class="hljs-type">i32</span>| { x + y }; <span class="hljs-comment">// 使用了 x</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, <span class="hljs-title function_ invoke__">sum</span>(<span class="hljs-number">99</span>)); <span class="hljs-comment">// 输出 100</span>

    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum2</span> = |y :<span class="hljs-type">i32</span>| x + y + <span class="hljs-number">1</span>; <span class="hljs-comment">// 再次使用了 x</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, <span class="hljs-title function_ invoke__">sum2</span>(<span class="hljs-number">99</span>)); <span class="hljs-comment">// 输出 101</span>
</code></pre>
<blockquote>
<p>说明： <code>x</code> 在 sum1 中使用后，还能在 sum2 中再次使用，说明 <code>x</code> 所有权没有 move。</p>
</blockquote>
<p>实际上，上述例子的 <code>x</code> 在闭包中是作为 <strong>不可变借用</strong> 使用的，<strong>因为这个闭包实现了 <code>Fn</code> trait</strong>。</p>
<h2>闭包的三种 traits</h2>
<p>闭包是一种函数，它的三种 traits 恰好对应了三种处理所有权的方式。</p>
<p>三种 traits 如下（划重点，请背下来）：</p>
<ol>
<li><code>FnOnce</code>：表示此闭包调用时会获取环境变量所有权（<strong>所有权 move</strong>)。因此取名 <code>FnOnce</code>，表示此闭包只能执行一次，因为再次执行时，环境变量可能由于之前所有权 move 过，已经没法用了。</li>
<li><code>FnMut</code> ：表示此闭包调用时会对环境变量进行<strong>可变借用</strong>，可能会修改环境变量</li>
<li><code>Fn</code> ： 表示此闭包调用时会对环境变量进行<strong>不可变借用</strong>，不会修改环境变量</li>
</ol>
<p>并且，<strong>一个闭包可以同时实现多个 traits</strong>。比如实现了 <code>Fn</code> 的闭包也一定实现了 <code>FnOnce</code> （后续解释）。</p>
<p>上面是从“对环境变量如何处理所有权” 来解释三个 traits，大部分教程也是这么写，但个人并不推荐完全按这样去理解。因为上述表述中，三个 traits 看起来是互不重叠的（实际并非如此），导致可能会出现这样的疑问：</p>
<blockquote>
<p>“实现了 <code>Fn</code> 的闭包说是对环境变量进行了不可变借用，那怎么还能同时实现 <code>FnOnce</code> ，去获取环境变量的所有权呢？到底是仅仅进行不可变借用，还是获取了所有权呢？”</p>
</blockquote>
<p>但是看三个 traits 的源代码，可以直接回答上述问题：是不可变借用。虽然确实也实现了 <code>FnOnce</code>（所有权 move） ，但并没有调用 <code>FnOnce</code> 的 call 函数，而是调用了 <code>Fn</code>(不可变借用) 的 call 函数。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Fn</span>&lt;Args&gt; : <span class="hljs-built_in">FnMut</span>&lt;Args&gt; {
    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;rust-call&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call</span>(&amp;<span class="hljs-keyword">self</span>, args: Args) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>::Output;
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">FnMut</span>&lt;Args&gt; : <span class="hljs-built_in">FnOnce</span>&lt;Args&gt; {
    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;rust-call&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_mut</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, args: Args) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>::Output;
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">FnOnce</span>&lt;Args&gt; {
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;

    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;rust-call&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_once</span>(<span class="hljs-keyword">self</span>, args: Args) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>::Output;
}
</code></pre>
<blockquote>
<p>分析：如果 <code>FnOnce</code> 的 call 函数被调用，则直接传入了 <code>self</code> ，也就是获取了当前的环境变量的所有权，自然运行一次后回被销毁。而 <code>Fn</code> 的 call 函数传入的是不可变借用 <code>&amp;self</code>。</p>
</blockquote>
<p>并且会发现， <code>Fn</code> 的前提是实现了 <code>FnMut</code> , <code>FnMut</code> 的前提是实现了 <code>FnOnce</code> 。</p>
<ul>
<li>从继承关系来讲： <code>Fn</code> 继承 <code>FnMut</code> 继承 <code>FnOnce</code></li>
<li>从访问变量的权限范围来讲： <code>Fn</code> &lt; <code>FnMut</code> &lt; <code>FnOnce</code></li>
</ul>
<p>也可以说，<strong>闭包就算实现了 <code>FnOnce</code> 也不一定会用到所有权 move，因为可能还实现了 <code>Fn</code> ，那么环境变量的所有权会按 <code>Fn</code> 处理</strong>。</p>
<hr/>
<p>由于上述继承关系，如果定义一个普通函数，参数需要传入 <code>FnOnce</code> ，实际上也可以传入 <code>Fn</code> 。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fn_once</span>&lt;F&gt;(func: F)
<span class="hljs-keyword">where</span>
    F: <span class="hljs-title function_ invoke__">FnOnce</span>(<span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>, <span class="hljs-comment">// 传入闭包</span>
{
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, <span class="hljs-title function_ invoke__">func</span>(<span class="hljs-number">3</span>));
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    <span class="hljs-keyword">let</span> <span class="hljs-variable">closure</span> = |z|{z == x.<span class="hljs-title function_ invoke__">len</span>()}; <span class="hljs-comment">// 此闭包实现了 Fn、 FnMut 和 FnOnce</span>
    <span class="hljs-title function_ invoke__">fn_once</span>(closure); <span class="hljs-comment">// Fn 可传入标注为 FnOnce 的参数</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, x); <span class="hljs-comment">// x 还能用，所有权没转移</span>

    <span class="hljs-keyword">let</span> <span class="hljs-variable">closure2</span> = <span class="hljs-keyword">move</span> |z|{z == x.<span class="hljs-title function_ invoke__">len</span>()}; <span class="hljs-comment">//  此闭包只实现了 FnOnce，因为 x 被强制转移所有权到闭包内部</span>
    <span class="hljs-title function_ invoke__">fn_once</span>(closure2); <span class="hljs-comment">// 传入 FnOnce</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, x); <span class="hljs-comment">// 报错，x 已经没了</span>
}
</code></pre>
<blockquote>
<p>说明：fn_once 需要接收 <code>FnOnce</code> 的闭包作为参数，但传入 <code>Fn</code> 也是合理的，编译器也会按照 <code>Fn</code> 的调用方式处理为不可变借用，并不会因为标注着 <code>FnOnce</code> 而变成所有权 move。</p>
</blockquote>
<blockquote>
<p>闭包对所有权的处理并不会随着标注改变，标注仅仅是为了取悦编译器 ——鲁迅</p>
</blockquote>
<h2>闭包实现三种 traits</h2>
<p>上述例子中，直接标注了闭包实现了三种 traits，但并没有具体说明为什么这么写就是实现了三种 traits。这是本节需要说明的内容。</p>
<p>闭包实现 traits 是<strong>隐式</strong>的。也就是说，你不用（也没法）标注这个闭包是实现的哪个 traits。具体实现了哪些 traits 是根据你的闭包写法决定的。</p>
<ol>
<li>实现<code>FnOnce</code></li>
</ol>
<p>所有的闭包都自动实现了 <code>FnOnce</code> 。不用特别做什么。</p>
<p>但更普遍的情况是，定义闭包时会顺带实现 <code>Fn</code> 或者 <code>FnMut</code> 。如果想要只实现 <code>FnOnce</code>，不要实现另外两个，需要用 <code>move</code> 。这个关键字会强制转移所有权，使闭包无法满足 <code>FnMut</code> 和 <code>Fn</code> 的条件。</p>
<ul>
<li>例：只实现了 <code>FnOnce</code> 的闭包</li>
</ul>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
    
    <span class="hljs-keyword">let</span> <span class="hljs-variable">closure2</span> = <span class="hljs-keyword">move</span> |z|{z == x.<span class="hljs-title function_ invoke__">len</span>()}; <span class="hljs-comment">// 只实现了 FnOnce，所有权转移</span>
    <span class="hljs-title function_ invoke__">closure2</span>(<span class="hljs-number">2</span>);
    
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, x); <span class="hljs-comment">// 报错，x 所有权被转移</span>
}
</code></pre>
<ol start="2">
<li>实现<code>FnMut</code></li>
</ol>
<p>在闭包中修改外部变量，即实现了 <code>FnMut</code> （自然也实现了 <code>FnOnce</code> ），同时没有实现 <code>Fn</code> 。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">closure</span> = ||{x.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">4</span>);}; <span class="hljs-comment">// 修改了外部的 x, 实现了 FnMut， x 所有权没有转移</span>
    <span class="hljs-title function_ invoke__">closure</span>();
    
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, x);
}
</code></pre>
<ol start="3">
<li>实现<code>Fn</code></li>
</ol>
<p>在闭包中访问外部变量，不做任何修改，即实现了 <code>Fn</code> （自然也实现了 <code>FnMut</code> 和 <code>FnOnce</code>）。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-variable">update_string</span> =  || <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>,s); <span class="hljs-comment">// 访问外部的 s, 实现了 Fn</span>

    <span class="hljs-title function_ invoke__">exec</span>(update_string);
    <span class="hljs-title function_ invoke__">exec1</span>(update_string);
    <span class="hljs-title function_ invoke__">exec2</span>(update_string);
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">exec</span>&lt;F: <span class="hljs-title function_ invoke__">FnOnce</span>()&gt;(f: F)  { <span class="hljs-comment">// Fn 也可以传到 FnOnce 类型</span>
    <span class="hljs-title function_ invoke__">f</span>() <span class="hljs-comment">// 调用的是 Fn，所有权不会转移</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">exec1</span>&lt;F: <span class="hljs-title function_ invoke__">FnMut</span>()&gt;(<span class="hljs-keyword">mut</span> f: F)  { <span class="hljs-comment">// Fn 也可以传到 FnMut 类型</span>
    <span class="hljs-title function_ invoke__">f</span>()
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">exec2</span>&lt;F: <span class="hljs-title function_ invoke__">Fn</span>()&gt;(f: F)  {
    <span class="hljs-title function_ invoke__">f</span>()
}
</code></pre>
<h2>闭包自身的所有权</h2>
<p>上述讨论的是闭包对于环境变量的所有权处理。那闭包自己呢？当闭包自己作为变量被传来传去时，是 Copy 还是所有权 Move？</p>
<p>答案是，<code>Fn</code> 是 Copy，<code>FnMut</code> 和 <code>FnOnce</code> 是所有权 Move。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];

    <span class="hljs-keyword">let</span> <span class="hljs-variable">closure</span> = |z:<span class="hljs-type">usize</span>|{ z == x.<span class="hljs-title function_ invoke__">len</span>()}; <span class="hljs-comment">// 实现了 Fn</span>
    <span class="hljs-title function_ invoke__">outter</span>(closure); <span class="hljs-comment">// 通过</span>
    <span class="hljs-title function_ invoke__">outter</span>(closure); <span class="hljs-comment">// 通过</span>

    <span class="hljs-keyword">let</span> <span class="hljs-variable">closure2</span> = |z:<span class="hljs-type">usize</span>|{ x.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">4</span>);z == x.<span class="hljs-title function_ invoke__">len</span>()}; <span class="hljs-comment">// 实现了 FnMut</span>
    <span class="hljs-title function_ invoke__">outter</span>(closure2); <span class="hljs-comment">// 通过</span>
    <span class="hljs-title function_ invoke__">outter</span>(closure2); <span class="hljs-comment">// 报错, closure2 的所有权已被转移</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">outter</span>&lt;T&gt;(<span class="hljs-keyword">mut</span> func: T)
<span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">FnMut</span>(<span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> { <span class="hljs-comment">// Fn 可以传到 FnMut 标注的参数上</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = func;
}
</code></pre>
<p>这是非常合理的，对应着 Rust 借用的规则</p>
<blockquote>
<p>在同一时间点，对于同一个变量，<strong>要么</strong>只能有一个可变借用(FnMut)，<strong>要么</strong>只能有<strong>多个不可变借用</strong>(Fn)。</p>
</blockquote>
<p>至于 <code>FnOnce</code>，对环境变量的访问权限这么大，还想 Copy？只能是所有权 move。</p>
<h2>一些建议</h2>
<p>如果遇到函数的参数也是一个函数，需要标注 trait 的场景，又不知道到底应该标注哪一个 trait，建议先标注 Fn ( 权限最小的 trait)，由编译器提示后再进行修改。</p>
<p>另外，闭包的所有权部分并不推荐背书，尤其不推荐总结为正交规则。三个 traits 的区别与联系在代码层面非常简单且容易分析，总结为正交规则反而是把简单的事情复杂化，而且难记。</p>
<p>如果仍然难懂，可评论提出，后续改进。</p>]]></content>
        <category label="学习"/>
        <published>2022-06-14T00:00:00.000Z</published>
    </entry>
</feed>