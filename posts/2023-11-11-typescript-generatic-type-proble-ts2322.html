<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>关于 typescript 泛型中返回值类型约束的问题</title><meta name="description" content="关于 typescript 泛型中返回值类型约束的问题 最近遇到这么一个需求。  &gt; 定义一个函数接口，要求其返回值类型是 type A 的任意超集。  于是我按直觉写下了：   ```typescript type A  = { a: string } type FuncA  = &lt;T extends A&gt;() =&gt; T const f:"/><meta name="keywords" content="typescript, typescript, ts, generaic type, ts2322, 泛型约束"/><meta name="description" content="A personal blog about work and life"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="6"/><script id="jsdelivr" data-nscript="beforeInteractive">(n=>{"use strict";let s,r,e;const l=["cdn.jsdelivr.net","fastly.jsdelivr.net","gcore.jsdelivr.net","cdn.zenless.top","testingcf.jsdelivr.net","test1.jsdelivr.net"],t="//",i=l[0],o=Date.now(),a=2e3,c="jsdelivr-auto-fallback",f="/gh/PipecraftNet/jsdelivr-auto-fallback@main/empty.css?",d=e=>e&&e.includes(t+i),m=e=>e.replace(t+i,t+s),u=window.setTimeout,v=n.querySelectorAll.bind(n),b=()=>{let e,t;for(e of v('link[rel="stylesheet"]'))t=e.href,d(t)&&!t.includes(f)&&(e.href=m(t));for(e of v("script"))if(t=e.src,d(t)){const s=n.createElement("script");s.src=m(t),e.defer=!0,e.src="",e.before(s),e.remove()}for(e of v("img"))t=e.src,d(t)&&(e.src="",e.src=m(t));for(e of v("*[style]"))t=e.getAttribute("style"),d(t)&&e.setAttribute("style",m(t));for(e of v("style"))t=e.innerHTML,d(t)&&(e.innerHTML=m(t))},h=()=>{!e&&r&&s&&(console.warn(i+" is not available. Use "+s),e=!0,u(b,0),u(b,20),setInterval(b,500))},g=(()=>{try{return Object.assign({},JSON.parse(localStorage.getItem(c)||"{}"))}catch{return{}}})(),y=()=>{g.time=o,g.failed=!1,g.fastNode=null;for(const t of l)((e,t)=>{let s;const r=n.createElement("link"),l=e=>{s&&(clearTimeout(s),s=0,e||(r.href="data:text/css;base64,"),r.remove(),t(e))};s=u(l,a),r.addEventListener("error",()=>l(!1)),r.addEventListener("load",()=>l(!0)),r.rel="stylesheet",r.text="text/css",r.href=e+f+o,n.head.insertAdjacentElement("afterbegin",r)})("https://"+t,e=>{e||t!==i||(r=!0,g.failed=!0),e&&!s&&(s=t),e&&!g.fastNode&&(g.fastNode=t),h()});u(()=>{r&&!s&&(s=l[1],h()),localStorage.setItem(c,JSON.stringify(g))},a+100)};if(g.time&&o-g.time<36e5&&g.failed&&g.fastNode)r=!0,s=g.fastNode,h(),u(y,1e3);else if(n.head)y();else{const j=new MutationObserver(()=>{n.head&&(j.disconnect(),y())});j.observe(n,{childList:!0,subtree:!0})}})(document);</script><link rel="preload" href="/_next/static/css/7fc0f4864478c2a3.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/7fc0f4864478c2a3.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/dff1bccf68b12a76.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/dff1bccf68b12a76.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-21c828b96ad33382.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-3c98a2613ac05b51.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-183a10cdd1d803af.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-b9407f36906beade.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/ab88915f-01db70d6c7d8d9ce.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/f32efb27-e8074619ac888612.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/965-180c0dacbb388d4d.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/758-8bc4140e7967cb65.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/108-a52cf393cf03882d.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-a90876e0178be156.js" defer="" crossorigin=""></script><script src="/_next/static/faKqQSdtEJqw5xxFStspi/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/faKqQSdtEJqw5xxFStspi/_ssgManifest.js" defer="" crossorigin=""></script><style data-styled="" data-styled-version="6.0.7">body{background:white;color:#262626;}/*!sc*/
data-styled.g1[id="sc-global-PuglZ1"]{content:"sc-global-PuglZ1,"}/*!sc*/
.keCPoa{padding:24px 0 10px 0;text-align:center;font-size:0.625rem;}/*!sc*/
.keCPoa div{margin:1rem auto;}/*!sc*/
.keCPoa a{transition:color .5s;}/*!sc*/
.keCPoa a:hover{color:#e0c56e;}/*!sc*/
.keCPoa i{font-size:1.5rem;margin:0 0.5rem;}/*!sc*/
data-styled.g2[id="sc-94026e7d-0"]{content:"keCPoa,"}/*!sc*/
.kMfdvS{position:relative;font-weight:bold;}/*!sc*/
.kMfdvS::before{content:'';position:absolute;left:0;bottom:-3px;width:0;height:2px;background:#ae8d0b;transition:width 1s cubic-bezier(0.34, 0.04, 0.03, 1.4),background .3s;}/*!sc*/
.kMfdvS:hover::before{width:100%;}/*!sc*/
data-styled.g3[id="sc-6734a8ac-0"]{content:"kMfdvS,"}/*!sc*/
.iZgfEl{min-width:60px;min-height:60px;z-index:20;background:white;border:1px solid #a2a2a280;border-radius:5px;transform:scale3d(1, 1, 1);box-shadow:rgb(0 0 0 / 5%) 0px 0.5rem 2rem;}/*!sc*/
data-styled.g6[id="sc-bcPKhP"]{content:"iZgfEl,"}/*!sc*/
.gDpJFz{overflow-y:scroll;max-height:60vh;}/*!sc*/
data-styled.g7[id="sc-1acf9ea8-0"]{content:"gDpJFz,"}/*!sc*/
.eFANYk{position:sticky;top:0;background:white;}/*!sc*/
data-styled.g8[id="sc-1acf9ea8-1"]{content:"eFANYk,"}/*!sc*/
.eDOVVX{border:none;border-radius:0;background:white;width:100%;color:#262626;}/*!sc*/
.eDOVVX:focus,.eDOVVX:focus-visible{outline:none;}/*!sc*/
data-styled.g9[id="sc-1acf9ea8-2"]{content:"eDOVVX,"}/*!sc*/
.kgrQol{font-size:0.875rem;color:#666666;overflow:hidden;white-space:nowrap;wrap:no-wrap;}/*!sc*/
data-styled.g11[id="sc-1acf9ea8-4"]{content:"kgrQol,"}/*!sc*/
.jkKjCi{min-height:unset;position:fixed;top:55px;right:0px;width:24rem;overflow:hidden;margin:0 10px;}/*!sc*/
.jkKjCi mark{background:none;color:#ae8d0b;}/*!sc*/
@media screen and (max-width: 580px){.jkKjCi{width:96%;max-height:50%;}}/*!sc*/
data-styled.g12[id="sc-1acf9ea8-5"]{content:"jkKjCi,"}/*!sc*/
.bVheqH{width:1em;height:1em;display:flex;flex-direction:column;justify-content:space-between;cursor:pointer;}/*!sc*/
.fqWkYw{width:100%;height:21px;display:flex;flex-direction:column;justify-content:space-between;cursor:pointer;}/*!sc*/
data-styled.g13[id="sc-a7603314-0"]{content:"bVheqH,fqWkYw,"}/*!sc*/
.ibKFuN{background:#262626;height:2px;transition:all .3s;border-radius:2px;}/*!sc*/
.ibKFuN.is-close{opacity:0;}/*!sc*/
data-styled.g14[id="sc-a7603314-1"]{content:"ibKFuN,"}/*!sc*/
.ghYtHL{height:2px;position:relative;border-radius:2px;}/*!sc*/
.ghYtHL::before,.ghYtHL::after{content:'';position:absolute;border-radius:2px;top:0;left:0;width:100%;height:2px;background:#262626;transition:all .3s;}/*!sc*/
.ghYtHL::before{transform:rotate(45deg);}/*!sc*/
.ghYtHL::after{transform:rotate(-45deg);}/*!sc*/
.gGDuoS{height:2px;position:relative;border-radius:2px;}/*!sc*/
.gGDuoS::before,.gGDuoS::after{content:'';position:absolute;border-radius:2px;top:0;left:0;width:100%;height:2px;background:#262626;transition:all .3s;}/*!sc*/
data-styled.g15[id="sc-a7603314-2"]{content:"ghYtHL,gGDuoS,"}/*!sc*/
.frnmxU{width:24px;height:20px;position:fixed;top:22px;right:20px;}/*!sc*/
data-styled.g16[id="sc-45cbf200-0"]{content:"frnmxU,"}/*!sc*/
.dUhaPj{font-weight:400;padding-top:4rem;font-size:0.625rem;}/*!sc*/
data-styled.g17[id="sc-45cbf200-1"]{content:"dUhaPj,"}/*!sc*/
.caomCB{margin:0.5rem 0;}/*!sc*/
.caomCB a{transition:color .5s;}/*!sc*/
.caomCB a:hover{color:#ae8d0b;}/*!sc*/
.caomCB i{font-size:1.5rem;margin:0 0.5rem;}/*!sc*/
data-styled.g18[id="sc-45cbf200-2"]{content:"caomCB,"}/*!sc*/
.dKZbuZ{background:white;overflow:auto;position:fixed;width:100%;height:100%;z-index:10;transform:translateY(0);transition:transform 1s cubic-bezier(0.46, 0, 0.08, 1.11);}/*!sc*/
.dKZbuZ.hidden{transform:translateY(-100%);}/*!sc*/
.dKZbuZ h1{-webkit-text-stroke:1px;-webkit-text-fill-color:transparent;}/*!sc*/
.dKZbuZ h1 span{position:relative;}/*!sc*/
.dKZbuZ h1 span::after{content:'';position:absolute;left:0;bottom:-1rem;width:100%;height:1px;background:#ae8d0b;}/*!sc*/
data-styled.g19[id="sc-45cbf200-3"]{content:"dKZbuZ,"}/*!sc*/
.jrFtoa{margin:0 auto;padding:92px 0px;text-align:center;font-weight:bold;}/*!sc*/
data-styled.g20[id="sc-45cbf200-4"]{content:"jrFtoa,"}/*!sc*/
.hWRjRk{font-size:1.625rem;line-height:2.75rem;position:relative;transition:box-shadow .3s ease;cursor:pointer;}/*!sc*/
.hWRjRk:hover{box-shadow:inset 0 -0.5em 0 #e0c56e;transform:scale(1.2);}/*!sc*/
data-styled.g21[id="sc-45cbf200-5"]{content:"hWRjRk,"}/*!sc*/
.fMTZdl{transform:translateY(0.145rem);transition:color 0.3s ease;}/*!sc*/
.fMTZdl:hover{color:#e0c56e;}/*!sc*/
data-styled.g22[id="sc-ddb73611-0"]{content:"fMTZdl,"}/*!sc*/
.diYvzO{height:63px;width:100%;text-align:center;padding-top:0.625rem;font-size:0.625rem;font-style:italic;color:#ae8d0b;font-family:'Times New Roman',STSong,'宋体',serif;opacity:.6;}/*!sc*/
data-styled.g23[id="sc-ddb73611-1"]{content:"diYvzO,"}/*!sc*/
.bMSRkx{height:63px;width:100%;display:flex;justify-content:space-between;align-items:center;position:fixed;background-color:white;z-index:10;transform:translateY(0);transition:transform .5s ease;}/*!sc*/
data-styled.g24[id="sc-ddb73611-2"]{content:"bMSRkx,"}/*!sc*/
.bKOunC{flex:1 1 auto;display:flex;align-items:center;height:100%;justify-content:flex-end;}/*!sc*/
data-styled.g25[id="sc-ddb73611-3"]{content:"bKOunC,"}/*!sc*/
.epTqxR{flex:1 1 auto;display:flex;justify-content:flex-start;}/*!sc*/
.epTqxR img{margin-left:10px;z-index:11;width:63px;height:63px;float:left;cursor:pointer;}/*!sc*/
@media screen and (max-width: 580px){.epTqxR img{width:48px;height:48px;}}/*!sc*/
@media screen and (max-width: 350px){.epTqxR{display:none;}}/*!sc*/
data-styled.g26[id="sc-ddb73611-4"]{content:"epTqxR,"}/*!sc*/
.ffFWdj{text-align:right;font-size:0.875em;}/*!sc*/
.ffFWdj>div{margin-right:15px;}/*!sc*/
@media screen and (max-width: 580px){.ffFWdj>div{margin-right:16px;padding:1px 0;}}/*!sc*/
data-styled.g27[id="sc-ddb73611-5"]{content:"ffFWdj,"}/*!sc*/
.bKWZNp{flex:2 1 auto;display:flex;justify-content:space-evenly;letter-spacing:0.02em;align-items:center;}/*!sc*/
@media screen and (min-width: 780px){.bKWZNp{max-width:50%;}}/*!sc*/
@media screen and (min-width: 580px){.bKWZNp{max-width:390px;}}/*!sc*/
@media screen and (max-width: 580px){.bKWZNp{max-width:290px;}}/*!sc*/
.bKWZNp ol{padding:0 .5em;padding-top:2px;}/*!sc*/
.bKWZNp ol.current a{color:#ae8d0b;}/*!sc*/
data-styled.g28[id="sc-ddb73611-6"]{content:"bKWZNp,"}/*!sc*/
.bSHlEP{max-width:780px;margin:0 auto;padding:0px 48px 48px 48px;}/*!sc*/
@media screen and (max-width: 780px){.bSHlEP{max-width:580px;}}/*!sc*/
@media screen and (max-width: 580px){.bSHlEP{padding:0 20px 48px 20px;}}/*!sc*/
data-styled.g29[id="sc-f013877a-0"]{content:"bSHlEP,"}/*!sc*/
.gSdPkQ{margin:64px 0;display:flex;flex-wrap:wrap;justify-content:space-between;align-items:center;}/*!sc*/
.gSdPkQ>span{color:#666666;font-size:0.875rem;}/*!sc*/
data-styled.g46[id="sc-ca12bac4-0"]{content:"gSdPkQ,"}/*!sc*/
.ejTgVD{padding:.2em 0;display:flex;align-items:center;position:relative;}/*!sc*/
.ejTgVD i{transform:translateY(-0.1em);}/*!sc*/
.ejTgVD span{position:relative;}/*!sc*/
.ejTgVD span::before{content:'';position:absolute;left:0;bottom:0;width:0;height:2px;background:#ae8d0b;transition:width 1s cubic-bezier(0.34, 0.04, 0.03, 1.4),background .3s;}/*!sc*/
.ejTgVD span:hover::before{width:100%;}/*!sc*/
data-styled.g47[id="sc-ca12bac4-1"]{content:"ejTgVD,"}/*!sc*/
.gBJfHv{color:#323232;}/*!sc*/
.gBJfHv img,.gBJfHv picture,.gBJfHv video,.gBJfHv canvas,.gBJfHv svg,.gBJfHv pre{margin:1.5rem auto;display:block;}/*!sc*/
.gBJfHv p,.gBJfHv ul,.gBJfHv ol{line-height:1.7rem;}/*!sc*/
.gBJfHv blockquote{margin:1.5rem 0;}/*!sc*/
.gBJfHv a{position:relative;font-weight:bold;border-bottom:1px solid #ae8d0b;transition:box-shadow .5s;}/*!sc*/
.gBJfHv a:hover{box-shadow:inset 0 -0.5em 0 #e0c56e;}/*!sc*/
.gBJfHv code{color:#ae8d0b;background-color:#f3f3f3;border-radius:3px;padding:0.2rem 0.375rem;margin:0rem 1px;font-size:0.875rem;}/*!sc*/
.gBJfHv pre code{color:#323232;border-radius:0.5rem;padding:1rem 2rem;margin:unset;overflow:auto;}/*!sc*/
.gBJfHv blockquote{border-left:solid 2px;padding-left:1.5em;color:#666666;}/*!sc*/
.gBJfHv del{opacity:.33;}/*!sc*/
.gBJfHv ul li{display:block;position:relative;}/*!sc*/
.gBJfHv ul li::before{content:"•";position:absolute;color:#ae8d0b;left:-1rem;}/*!sc*/
@media screen and (min-width: 580px){.gBJfHv{letter-spacing:0.01em;text-align:justify;}.gBJfHv img,.gBJfHv picture,.gBJfHv video,.gBJfHv canvas,.gBJfHv svg,.gBJfHv pre{margin:1.6rem auto;display:block;}.gBJfHv blockquote{margin:1.6rem 0;}}/*!sc*/
.gBJfHv .hljs{background:#f3f3f3;}/*!sc*/
.gBJfHv .hljs-emphasis{font-style:italic;}/*!sc*/
.gBJfHv .hljs-strong{font-weight:bold;}/*!sc*/
.gBJfHv .hljs-link{text-decoration:underline;}/*!sc*/
.gBJfHv .hljs-comment,.gBJfHv .hljs-quote{color:#a79b87ba;font-style:italic;}/*!sc*/
.gBJfHv .hljs-params,.gBJfHv .hljs-type{color:#a79b87c4;}/*!sc*/
.gBJfHv .hljs-punctuation,.gBJfHv .hljs-attr{color:rgb(89 161 197);}/*!sc*/
.gBJfHv .hljs-selector-tag,.gBJfHv .hljs-name,.gBJfHv .hljs-meta,.gBJfHv .hljs-operator,.gBJfHv .hljs-char.escape_{color:#c56200;}/*!sc*/
.gBJfHv .hljs-keyword,.gBJfHv .hljs-deletion{color:#799f67;}/*!sc*/
.gBJfHv .hljs-regexp,.gBJfHv .hljs-selector-pseudo,.gBJfHv .hljs-selector-attr,.gBJfHv .hljs-variable.language_{color:#cc5e91;}/*!sc*/
.gBJfHv .hljs-subst,.gBJfHv .hljs-property,.gBJfHv .hljs-code,.gBJfHv .hljs-formula,.gBJfHv .hljs-section,.gBJfHv .hljs-title.function_{color:#e36b6b;}/*!sc*/
.gBJfHv .hljs-string,.gBJfHv .hljs-symbol,.gBJfHv .hljs-bullet,.gBJfHv .hljs-addition,.gBJfHv .hljs-selector-class,.gBJfHv .hljs-title.class_,.gBJfHv .hljs-title.class_.inherited__,.gBJfHv .hljs-meta .hljs-string{color:#c68032;}/*!sc*/
.gBJfHv .hljs-variable,.gBJfHv .hljs-template-variable,.gBJfHv .hljs-number,.gBJfHv .hljs-literal,.gBJfHv .hljs-link,.gBJfHv .hljs-built_in,.gBJfHv .hljs-title,.gBJfHv .hljs-selector-id,.gBJfHv .hljs-tag,.gBJfHv .hljs-doctag,.gBJfHv .hljs-attribute,.gBJfHv .hljs-template-tag,.gBJfHv .hljs-meta .hljs-keyword{color:#ae8d0b;}/*!sc*/
data-styled.g49[id="sc-1a42a81c-0"]{content:"gBJfHv,"}/*!sc*/
.goWJqV{margin:0 auto;--waline-theme-color:#292929;--waline-bgcolor:white;--waline-color:#666666;--waline-active-color:#ae8d0b;--waline-bgcolor-light:#99999915;--waline-border:1px solid #99999966;--waline-border-color:#99999966;--waline-info-bgcolor:#99999915;}/*!sc*/
.goWJqV .wl-btn.primary{background:#292929;color:white;}/*!sc*/
@media screen and (max-width: 580px){.goWJqV .wl-gif-popup .wl-gallery-column{display:grid!important;grid-template-columns:1fr 1fr 1fr;max-height:200px;}}/*!sc*/
.goWJqV .wl-gif-popup img{border-color:white;}/*!sc*/
.goWJqV .wl-gif-popup input{background:white;color:#262626;}/*!sc*/
data-styled.g50[id="sc-1e040c41-0"]{content:"goWJqV,"}/*!sc*/
.jqnJbz{max-width:min(700px, 100vw);margin-top:72px;animation:gWOUmS 1s ease;}/*!sc*/
@media screen and (max-width: 580px){.jqnJbz{margin-top:36px;}}/*!sc*/
data-styled.g51[id="sc-2b97d2e5-0"]{content:"jqnJbz,"}/*!sc*/
.gjFtUv{width:0;flex:2 1 0;display:flex;}/*!sc*/
@media screen and (min-width: 1080px){.gjFtUv .blank-spacer-left{flex:2 1 0;}}/*!sc*/
@media screen and (min-width: 780px){.gjFtUv .blank-spacer-right{flex:1 1 0;}}/*!sc*/
data-styled.g52[id="sc-2b97d2e5-1"]{content:"gjFtUv,"}/*!sc*/
.eiLuxW{max-width:min(18em,20vw);flex:1 1 0;margin-top:94px;position:sticky;align-self:flex-start;top:63px;animation:hBXrSV 1s ease;}/*!sc*/
@media screen and (max-width: 780px){.eiLuxW{display:none;}}/*!sc*/
data-styled.g53[id="sc-2b97d2e5-2"]{content:"eiLuxW,"}/*!sc*/
.fFWFyN{margin-bottom:3rem;}/*!sc*/
.fFWFyN h1{margin-top:.3rem;margin-bottom:0.5rem;}/*!sc*/
@media screen and (max-width: 580px){.fFWFyN{margin-bottom:2rem;}}/*!sc*/
data-styled.g54[id="sc-2b97d2e5-3"]{content:"fFWFyN,"}/*!sc*/
.jveDCI{font-size:0.875rem;position:relative;color:#666666;}/*!sc*/
.jveDCI .date{font-size:0.875rem;}/*!sc*/
.jveDCI::before{content:'';position:absolute;top:-0.75em;left:0;height:1px;width:100%;background:#ae8d0b;}/*!sc*/
data-styled.g55[id="sc-2b97d2e5-4"]{content:"jveDCI,"}/*!sc*/
.clmSlR{transition:opacity .3s,color .3s;color:#262626;}/*!sc*/
.clmSlR:hover{color:#ae8d0b;}/*!sc*/
data-styled.g56[id="sc-2b97d2e5-5"]{content:"clmSlR,"}/*!sc*/
.knWIyt{position:relative;max-height:calc(100vh - 120px);overflow-y:auto;}/*!sc*/
data-styled.g58[id="sc-2b97d2e5-7"]{content:"knWIyt,"}/*!sc*/
@keyframes gWOUmS{0%{opacity:0;transform:translateY(10px);}100%{opacity:1;transform:translateY(0);}}/*!sc*/
data-styled.g59[id="sc-keyframes-gWOUmS"]{content:"gWOUmS,"}/*!sc*/
@keyframes hBXrSV{0%{-webkit-transform:translateX(50px);transform:translateX(50px);opacity:0;}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1;}}/*!sc*/
data-styled.g60[id="sc-keyframes-hBXrSV"]{content:"hBXrSV,"}/*!sc*/
</style></head><body><div id="__next"><div style="display:none" class="sc-bcPKhP sc-1acf9ea8-5 iZgfEl jkKjCi"><div style="padding:1rem 1rem 0 1rem" class="sc-1acf9ea8-1 eFANYk"><input type="text" placeholder="搜索你感兴趣的内容，以空格分词" class="sc-1acf9ea8-2 eDOVVX"/></div><div style="padding:0.5rem 1rem" class="sc-1acf9ea8-0 gDpJFz"><div style="font-size:0.875rem;opacity:0.5"><div class="sc-1acf9ea8-4 kgrQol">搜索初始化中……</div></div></div></div><div class="sc-45cbf200-3 dKZbuZ hidden"><div style="padding-top:8rem" class="sc-45cbf200-4 jrFtoa"><h1><span>SANSUI&#x27;S BLOG</span></h1><div><span class="sc-45cbf200-5 hWRjRk">日间模式</span></div><div><span class="sc-45cbf200-5 hWRjRk"><a href="/categories">分类</a></span></div><div><span class="sc-45cbf200-5 hWRjRk"><a href="/atom.xml">RSS</a></span></div><div class="sc-45cbf200-1 dUhaPj"><div class="sc-45cbf200-2 caomCB"><a href="https://github.com/sansui233"><i class="icon-github-rounded"></i></a><a href="mailto:sansuilnm@gmail.com"><i class="icon-email-rounded"></i></a><a href="/rss"><i class="icon-rss-rounded"></i></a></div><div>Sansui 2022 All rights reserved</div></div></div><div class="sc-45cbf200-0 frnmxU"><div width="1em" height="1em" class="sc-a7603314-0 bVheqH"><div class="sc-a7603314-1 ibKFuN is-close"></div><div class="sc-a7603314-2 ghYtHL"></div><div class="sc-a7603314-1 ibKFuN is-close"></div></div></div></div><header class="sc-ddb73611-2 bMSRkx"><div class="sc-ddb73611-3 sc-ddb73611-4 bKOunC epTqxR"><a href="/"><img src="/avatar-white.png" alt="Sansui"/></a></div><nav class="sc-ddb73611-6 bKWZNp"><ol class=""><a class="sc-6734a8ac-0 kMfdvS" href="/">Posts</a></ol><ol class=""><a class="sc-6734a8ac-0 kMfdvS" href="/memos">Memos</a></ol><ol class=""><a class="sc-6734a8ac-0 kMfdvS" href="/about">About</a></ol></nav><div class="sc-ddb73611-3 sc-ddb73611-5 bKOunC ffFWdj"><div class="sc-ddb73611-0 fMTZdl"><i class="icon-search" style="font-size:1.725rem"></i></div><div style="margin-right:20px;width:22px"><div width="100%" height="21px" class="sc-a7603314-0 fqWkYw"><div class="sc-a7603314-1 ibKFuN"></div><div class="sc-a7603314-2 gGDuoS"></div><div class="sc-a7603314-1 ibKFuN"></div></div></div></div></header><div class="sc-ddb73611-1 diYvzO">人活着就是为了卡卡西</div><main><div style="display:flex;margin:auto"><div class="sc-2b97d2e5-1 gjFtUv"><div class="blank-spacer-left"></div><div class="sc-f013877a-0 sc-2b97d2e5-0 bSHlEP jqnJbz"><div class="sc-2b97d2e5-3 fFWFyN"><h1>关于 typescript 泛型中返回值类型约束的问题</h1><div style="display:flex"><div style="flex:1 1 0"><span style="flex:1 1 0" class="sc-2b97d2e5-4 jveDCI"><span class="date">2023-11-12 06:26</span> | <a class="sc-2b97d2e5-5 clmSlR" href="/tags/typescript"><span style="padding-right:0.1em">#</span>typescript</a> in <a class="sc-2b97d2e5-5 clmSlR" href="/categories/%E5%AD%A6%E4%B9%A0"><i style="padding-right:0.2em" class="icon-material-folder_open"></i>学习</a></span></div><div style="flex:0 0 0;font-size:0.875rem"><i style="padding-left:0.5em;padding-right:0.3em" class="icon-material-eye"></i><span class="waline-pageview-count" data-path=""></span></div></div></div><div class="sc-1a42a81c-0 gBJfHv"><p>最近遇到这么一个需求。</p>
<blockquote>
<p>定义一个函数接口，要求其返回值类型是 type A 的任意超集。</p>
</blockquote>
<p>于是我按直觉写下了：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> A  = { <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> }
<span class="hljs-keyword">type</span> <span class="hljs-title class_">FuncA</span>  = &lt;T <span class="hljs-keyword">extends</span> A&gt;<span class="hljs-function">() =&gt;</span> T
<span class="hljs-keyword">const</span> <span class="hljs-attr">f</span>: <span class="hljs-title class_">FuncA</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;ok&quot;</span> } 
}
</code></pre>
<p>人来看非常简单知道是什么意思，就是返回值包含所有 a 的属性，其他属性全是可有可无的。</p>
<p>这段代码扔给 GPT，它也看不出什么毛病。但事实上，在 return 时报了一个错：</p>
<pre><code class="hljs language-text">Type &#x27;() =&gt; A&#x27; is not assignable to type &#x27;FuncA&#x27;.
  Type &#x27;A&#x27; is not assignable to type &#x27;T&#x27;.
    &#x27;A&#x27; is assignable to the constraint of type &#x27;T&#x27;, but &#x27;T&#x27; could be instantiated with a different subtype of constraint &#x27;A&#x27;.ts(2322)
</code></pre>
<p>这个报错非常的不 helpful。因为平时， typescript 可以根据返回值推测出具体函数标注。比如</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>){
  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>
} <span class="hljs-comment">// 自动推断出函数的具体签名为 () =&gt; string</span>
</code></pre>
<p>那为什么上面的报错例子，不能做这样的推断呢？</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">type</span> A  = { <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> }
<span class="hljs-keyword">type</span> <span class="hljs-title class_">FuncA</span>  = &lt;T <span class="hljs-keyword">extends</span> A&gt;<span class="hljs-function">() =&gt;</span> T
<span class="hljs-keyword">const</span> <span class="hljs-attr">f</span>: <span class="hljs-title class_">FuncA</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;ok&quot;</span> } 
} 
<span class="hljs-comment">/* 推断出具体的签名类似于
() =&gt; {
  a: string;
  [name: string]: any
}
*/</span>
</code></pre>
<p>也就是说，a 是必选属性，其他属性全是 optional。</p>
<p>（先不讨论 Object 的 key 可以是 Symbol，只是为了看起来好理解，我只写了 string。要写全这里又要多写一个类型推断。）</p>
<p>当然这里又引发了另一个问题：你为什么不直接把 type A 定义附加任意可选属性？</p>
<p>好问题，这是一个正常的解决 TS2322 问题的思路。但是我就是想知道为什么泛型推断不能直接做这个……</p>
<p>我查了很多资料，没有人完美解释这个问题。但有一个相似的问题：如何让参数和返回值持有相同的泛型类型？</p>
<p>在 typescript 的 <a href="https://github.com/microsoft/TypeScript/issues/50027">github issue</a> 里有详细的案例说明，务必看看，很好懂，说是故意这么设计的。这里我将理由简短概括如下：</p>
<blockquote>
<p>如果 f 是上有一个额外的属性 prop，编译器如果推导出了返回值类型成 typeof f。之后你调用 f.prop，静态编译不会报错，但实际上有一个 runtime error，因为你的真实的返回值只是一个 <code>()=&gt;{}</code> ，没有prop 属性。</p>
</blockquote>
<p>但个人觉得这里静态编译应该报错，并不是一个 runtime 错误。前面说了，typescript 可以对返回值进行静态的类型的检查。以上面 issue 为例，理想的报错设计是长这样：</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">type</span> A = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
<span class="hljs-keyword">type</span> B = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;

<span class="hljs-comment">// 类型签名为 &lt;T extends A | B&gt;(value: T) =&gt; T 的实现</span>
<span class="hljs-keyword">function</span> f1&lt;T <span class="hljs-keyword">extends</span> A | B&gt;(<span class="hljs-attr">value</span>: T): T {
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {};  <span class="hljs-comment">// 推断出 T 此时是 typeof ()=&gt;{}，也就是 ()=&gt;{}</span>
}

<span class="hljs-keyword">let</span> <span class="hljs-attr">f</span>: <span class="hljs-built_in">any</span>= <span class="hljs-function">()=&gt;</span>{}
f.<span class="hljs-property">prop</span> = <span class="hljs-string">&quot;haha&quot;</span>

<span class="hljs-title function_">f1</span>(f) <span class="hljs-comment">// 这里传参报错，因为 typeof f 和 typeof ()=&gt;{} 不一致。本质上就是 ts2322 描述的问题，但不应该在上面报错</span>
</code></pre>
<p>当然上面的例子返回值类型已经定了是 <code>typeof ()=&gt;{}</code>，返回值再标注 T 显得十分多此一举。但是 f1 对只是对这个函数签名的一种实现。完全可以实现对这个函数签名有不同的实现，返回不同的 subtype。</p>
<blockquote>
<p>什么是 subtype？T extends A，T 就是 A 的 subtype</p>
</blockquote>
<p>这又引发了另一个问题：这和函数重载有什么区别？</p>
<p>当然有区别啊，最大的区别就是我能定义一个统一的函数接口，只要返回值满足最基本的约束 <code>A</code>。但可以是返回不同的 subtype，实现也分开写到不同的文件里，类似于 oop 语言中返回所有某基类的派生类。这才是完全体。</p>
<p>但现在的 typescript 完全做不到这一点，返回值只能是一个非常具体的 type，要么就抛出一个毫无说服力的 ts2322 错误。</p>
<p>如果要解决开头的问题，大概是以下三个思路：</p>
<ul>
<li>定义 A 时，把所有可能要用到的属性都写到可选属性里，或直接 <code>[name: string]: any</code>。</li>
<li>考虑业务场景，其他未知属性不留下会影响到什么吗。99% 的场景是没有必要的，也就是说这个需求就是没意义的。剩下的 1% 我没有遇到/想到。</li>
<li>根据输入参数的 T 写一个类型推导，手动将返回的类型设置为 a 的具体扩展类型。类似这样</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Extend</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = {
  [<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>
} &amp; {
  [K <span class="hljs-keyword">in</span> keyof T]: T[K]
}

<span class="hljs-keyword">type</span> A  = {<span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>}
<span class="hljs-keyword">type</span> <span class="hljs-title class_">FuncA</span>  = <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Extend</span>&lt;A&gt;
<span class="hljs-keyword">const</span> <span class="hljs-attr">f</span>: <span class="hljs-title class_">FuncA</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;ok&quot;</span>, <span class="hljs-attr">b</span>:<span class="hljs-string">&quot;extra&quot;</span>} 
} 
<span class="hljs-title function_">f</span>().<span class="hljs-property">a</span> <span class="hljs-comment">// a is string</span>
<span class="hljs-title function_">f</span>().<span class="hljs-property">b</span> <span class="hljs-comment">// b is any</span>
</code></pre>
<p>总之，在目前的 typescript 中，<strong>返回值类型不能是泛型</strong>。</p>
<p>当然这样也失去了扩展的类型检查，等于是用了函数的签名来检查的，和返回值的类型一点关系也没有。</p>
<p>现在 typescript 的静态检查器其实已经做了一些运行时的功能，比如条件语句判断以排除属性。但是，这些像运行时一样的检查只在静态类型不明确时才起作用。就这个 if，我已经遇到了好几次无法判断的 bug ，清空缓存并重启才恢复。</p>
<p>说回第二点，既然你允许传了任意值，也就说明在你这个库中，你也不知道其他附加值具体是拿来干什么的，大多无非遍历一下再过滤一下。如果是静态类型检查器来遍历，诶诶扩展属性怎么全是 any。最终还得用 JS 的运行时来做这个事情……所以有拿来做什么的话早就在 A 里增加 optional 属性了。这也是为什么说 99% 的场景这个需求其实不存在。</p>
<p>还有一个更重要的原因，那就是，ts 的类型体操，实在太他妈难写了。</p>
<hr/>
<p>可能没用的参考：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/56505560/how-to-fix-ts2322-could-be-instantiated-with-a-different-subtype-of-constraint">typescript - How to fix TS2322: &quot;could be instantiated with a different subtype of constraint &#x27;object&#x27;&quot;? - Stack Overflow</a></li>
<li><a href="https://github.com/microsoft/TypeScript/issues/50027">Could be instantiated with a different subtype of constraint · Issue #50027 · microsoft/TypeScript</a></li>
</ul></div><div style="text-align:right;opacity:0.5;font-size:0.875rem;margin:4rem 0 2rem 0">更新于 <!-- -->2023-11-12 06:26</div><div class="sc-ca12bac4-0 gSdPkQ"><div style="flex:1 1 auto"><a style="justify-content:flex-start" class="sc-ca12bac4-1 ejTgVD" href="/posts/thoughts-about-wubi-im"><span><i class="icon-arrow-left2"></i> <!-- -->大概是关于五笔打字更慢的一点碎碎念？</span></a></div><span></span><div style="flex:1 1 auto"><a style="justify-content:flex-end" class="sc-ca12bac4-1 ejTgVD" href="/posts/2023-10-09-the-little-prince-review"><span>重读《小王子》<!-- --> <i class="icon-arrow-right2"></i></span></a></div></div><div id="waline" class="sc-1e040c41-0 goWJqV">Waline</div></div><div class="blank-spacer-right"></div></div><div class="sc-2b97d2e5-2 eiLuxW"><nav><div style="font-size:1.25rem;font-weight:bold;padding-bottom:0.5rem;margin-bottom:0.5rem;border-bottom:solid 1px #ae8d0b">目录</div><div class="sc-2b97d2e5-7 knWIyt"><span style="opacity:0.6;font-size:0.9rem">这是一篇没有目录的文章。</span></div></nav></div></div></main><div class="sc-94026e7d-0 keCPoa"><a href="https://github.com/sansui233"><i class="icon-github-rounded"></i></a><a href="mailto:sansuilnm@gmail.com"><i class="icon-email-rounded"></i></a><a href="/rss"><i class="icon-rss-rounded"></i></a><div>Code &amp; Design by Sansui 2023<!-- --> <br/> <!-- -->All rights reserved</div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"meta":{"title":"关于 typescript 泛型中返回值类型约束的问题","date":"2023-11-12 06:26","tags":["typescript"],"categories":"学习","description":"关于 typescript 泛型中返回值类型约束的问题","keywords":"typescript, ts, generaic type, ts2322，泛型约束"},"mdxcode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    code: \"code\",\n    hr: \"hr\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"最近遇到这么一个需求。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"定义一个函数接口，要求其返回值类型是 type A 的任意超集。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"于是我按直觉写下了：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-typescript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" A  = { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"string\"\n        }), \" }\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FuncA\"\n        }), \"  = \u003cT \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" A\u003e\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" T\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"f\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FuncA\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\r\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ok\\\"\"\n        }), \" } \\r\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"人来看非常简单知道是什么意思，就是返回值包含所有 a 的属性，其他属性全是可有可无的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这段代码扔给 GPT，它也看不出什么毛病。但事实上，在 return 时报了一个错：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"Type '() =\u003e A' is not assignable to type 'FuncA'.\\r\\n  Type 'A' is not assignable to type 'T'.\\r\\n    'A' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint 'A'.ts(2322)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这个报错非常的不 helpful。因为平时， typescript 可以根据返回值推测出具体函数标注。比如\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-ts\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"foo\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \"){\\r\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1\\\"\"\n        }), \"\\r\\n} \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 自动推断出函数的具体签名为 () =\u003e string\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那为什么上面的报错例子，不能做这样的推断呢？\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-ts\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" A  = { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"string\"\n        }), \" }\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FuncA\"\n        }), \"  = \u003cT \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" A\u003e\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" T\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"f\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FuncA\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\r\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ok\\\"\"\n        }), \" } \\r\\n} \\r\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/* 推断出具体的签名类似于\\r\\n() =\u003e {\\r\\n  a: string;\\r\\n  [name: string]: any\\r\\n}\\r\\n*/\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"也就是说，a 是必选属性，其他属性全是 optional。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"（先不讨论 Object 的 key 可以是 Symbol，只是为了看起来好理解，我只写了 string。要写全这里又要多写一个类型推断。）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当然这里又引发了另一个问题：你为什么不直接把 type A 定义附加任意可选属性？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"好问题，这是一个正常的解决 TS2322 问题的思路。但是我就是想知道为什么泛型推断不能直接做这个……\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我查了很多资料，没有人完美解释这个问题。但有一个相似的问题：如何让参数和返回值持有相同的泛型类型？\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在 typescript 的 \", _jsx(_components.a, {\n        href: \"https://github.com/microsoft/TypeScript/issues/50027\",\n        children: \"github issue\"\n      }), \" 里有详细的案例说明，务必看看，很好懂，说是故意这么设计的。这里我将理由简短概括如下：\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"如果 f 是上有一个额外的属性 prop，编译器如果推导出了返回值类型成 typeof f。之后你调用 f.prop，静态编译不会报错，但实际上有一个 runtime error，因为你的真实的返回值只是一个 \", _jsx(_components.code, {\n          children: \"()=\u003e{}\"\n        }), \" ，没有prop 属性。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但个人觉得这里静态编译应该报错，并不是一个 runtime 错误。前面说了，typescript 可以对返回值进行静态的类型的检查。以上面 issue 为例，理想的报错设计是长这样：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-ts\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" A = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"void\"\n        }), \";\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" B = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"void\"\n        }), \";\\r\\n\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 类型签名为 \u003cT extends A | B\u003e(value: T) =\u003e T 的实现\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" f1\u003cT \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" A | B\u003e(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"value\"\n        }), \": T): T {\\r\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {};  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 推断出 T 此时是 typeof ()=\u003e{}，也就是 ()=\u003e{}\"\n        }), \"\\r\\n}\\r\\n\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"f\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"any\"\n        }), \"= \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"()=\u003e\"\n        }), \"{}\\r\\nf.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"prop\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"haha\\\"\"\n        }), \"\\r\\n\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"f1\"\n        }), \"(f) \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 这里传参报错，因为 typeof f 和 typeof ()=\u003e{} 不一致。本质上就是 ts2322 描述的问题，但不应该在上面报错\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"当然上面的例子返回值类型已经定了是 \", _jsx(_components.code, {\n        children: \"typeof ()=\u003e{}\"\n      }), \"，返回值再标注 T 显得十分多此一举。但是 f1 对只是对这个函数签名的一种实现。完全可以实现对这个函数签名有不同的实现，返回不同的 subtype。\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"什么是 subtype？T extends A，T 就是 A 的 subtype\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这又引发了另一个问题：这和函数重载有什么区别？\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"当然有区别啊，最大的区别就是我能定义一个统一的函数接口，只要返回值满足最基本的约束 \", _jsx(_components.code, {\n        children: \"A\"\n      }), \"。但可以是返回不同的 subtype，实现也分开写到不同的文件里，类似于 oop 语言中返回所有某基类的派生类。这才是完全体。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但现在的 typescript 完全做不到这一点，返回值只能是一个非常具体的 type，要么就抛出一个毫无说服力的 ts2322 错误。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果要解决开头的问题，大概是以下三个思路：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"定义 A 时，把所有可能要用到的属性都写到可选属性里，或直接 \", _jsx(_components.code, {\n          children: \"[name: string]: any\"\n        }), \"。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"考虑业务场景，其他未知属性不留下会影响到什么吗。99% 的场景是没有必要的，也就是说这个需求就是没意义的。剩下的 1% 我没有遇到/想到。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"根据输入参数的 T 写一个类型推导，手动将返回的类型设置为 a 的具体扩展类型。类似这样\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-typescript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Extend\"\n        }), \"\u003cT \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"object\"\n        }), \"\u003e = {\\r\\n  [\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"string\"\n        }), \"]: \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"any\"\n        }), \"\\r\\n} \u0026 {\\r\\n  [K \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" keyof T]: T[K]\\r\\n}\\r\\n\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" A  = {\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"string\"\n        }), \"}\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FuncA\"\n        }), \"  = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Extend\"\n        }), \"\u003cA\u003e\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"f\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FuncA\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\r\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ok\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"b\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"extra\\\"\"\n        }), \"} \\r\\n} \\r\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"f\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"a\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// a is string\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"f\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"b\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// b is any\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"总之，在目前的 typescript 中，\", _jsx(_components.strong, {\n        children: \"返回值类型不能是泛型\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当然这样也失去了扩展的类型检查，等于是用了函数的签名来检查的，和返回值的类型一点关系也没有。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"现在 typescript 的静态检查器其实已经做了一些运行时的功能，比如条件语句判断以排除属性。但是，这些像运行时一样的检查只在静态类型不明确时才起作用。就这个 if，我已经遇到了好几次无法判断的 bug ，清空缓存并重启才恢复。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"说回第二点，既然你允许传了任意值，也就说明在你这个库中，你也不知道其他附加值具体是拿来干什么的，大多无非遍历一下再过滤一下。如果是静态类型检查器来遍历，诶诶扩展属性怎么全是 any。最终还得用 JS 的运行时来做这个事情……所以有拿来做什么的话早就在 A 里增加 optional 属性了。这也是为什么说 99% 的场景这个需求其实不存在。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"还有一个更重要的原因，那就是，ts 的类型体操，实在太他妈难写了。\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"可能没用的参考：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://stackoverflow.com/questions/56505560/how-to-fix-ts2322-could-be-instantiated-with-a-different-subtype-of-constraint\",\n          children: \"typescript - How to fix TS2322: \\\"could be instantiated with a different subtype of constraint 'object'\\\"? - Stack Overflow\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/microsoft/TypeScript/issues/50027\",\n          children: \"Could be instantiated with a different subtype of constraint · Issue #50027 · microsoft/TypeScript\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerpt":" 最近遇到这么一个需求。  \u003e 定义一个函数接口，要求其返回值类型是 type A 的任意超集。  于是我按直觉写下了：   ```typescript type A  = { a: string } type FuncA  = \u003cT extends A\u003e() =\u003e T const f:","prevPost":{"title":"大概是关于五笔打字更慢的一点碎碎念？","link":"/posts/thoughts-about-wubi-im"},"nextPost":{"title":"重读《小王子》","link":"/posts/2023-10-09-the-little-prince-review"},"headings":[]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2023-11-11-typescript-generatic-type-proble-ts2322"},"buildId":"faKqQSdtEJqw5xxFStspi","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>