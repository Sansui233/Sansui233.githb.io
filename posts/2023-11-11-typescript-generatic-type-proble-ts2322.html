<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>关于 typescript 泛型中返回值类型约束的问题</title><meta name="description" content=" 最近遇到这么一个需求。  &gt; 定义一个函数接口，要求其返回值类型是 type A 的任意超集。  于是我按直觉写下了：   ```typescript type A  = { a: string } type FuncA  = &lt;T extends A&gt;() =&gt; T const f:"/><meta name="keywords" content="typescript, typescript, ts, generic type, ts2322, 泛型约束"/><meta name="description" content="A personal blog about work and life"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="6"/><link rel="preload" href="/_next/static/css/569bdfc9e57c1c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/569bdfc9e57c1c0a.css" data-n-g=""/><link rel="preload" href="/_next/static/css/5b5cb5c44da6cda0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5b5cb5c44da6cda0.css"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script defer="" src="/_next/static/chunks/758.f400b000a8c3a6be.js"></script><script defer="" src="/_next/static/chunks/21cf0578.a975db57c7712e4a.js"></script><script defer="" src="/_next/static/chunks/55039f80.17f3406edb0a49c6.js"></script><script defer="" src="/_next/static/chunks/226.d143d74f7008737a.js"></script><script defer="" src="/_next/static/chunks/118.880f6edb8b090141.js"></script><script src="/_next/static/chunks/webpack-bed5e9cfbf46355e.js" defer=""></script><script src="/_next/static/chunks/framework-21ce6fe579778655.js" defer=""></script><script src="/_next/static/chunks/main-ab8ff8a41b8d4a92.js" defer=""></script><script src="/_next/static/chunks/pages/_app-268a484819b6d13f.js" defer=""></script><script src="/_next/static/chunks/314-af9189bf47190a02.js" defer=""></script><script src="/_next/static/chunks/234-b5e211b1cf557e56.js" defer=""></script><script src="/_next/static/chunks/425-36e72cb05ccc32e1.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-9869d02ee1e4575a.js" defer=""></script><script src="/_next/static/c7GPTAPy3C1rXdGyz988s/_buildManifest.js" defer=""></script><script src="/_next/static/c7GPTAPy3C1rXdGyz988s/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="6.1.12">body{background:white;color:#1F2329;}/*!sc*/
data-styled.g1[id="sc-global-durfUv1"]{content:"sc-global-durfUv1,"}/*!sc*/
.cPWGjz{padding:24px 0 10px 0;text-align:center;font-size:0.625rem;}/*!sc*/
.cPWGjz div{margin:1.5rem auto;letter-spacing:0.2px;}/*!sc*/
.cPWGjz a:hover{color:#e0c56e;}/*!sc*/
.cPWGjz svg{font-size:1.5rem;margin:0 0.5rem;}/*!sc*/
data-styled.g2[id="sc-705178b-0"]{content:"cPWGjz,"}/*!sc*/
.iAQObY{width:1em;height:1em;display:flex;flex-direction:column;justify-content:space-between;cursor:pointer;}/*!sc*/
.bcRNvF{width:100%;height:1.15rem;display:flex;flex-direction:column;justify-content:space-between;cursor:pointer;}/*!sc*/
data-styled.g3[id="sc-98974ec8-0"]{content:"iAQObY,bcRNvF,"}/*!sc*/
.kkSwlU{background:#1F2329;height:2px;transition:all .3s;border-radius:2px;}/*!sc*/
.kkSwlU.is-close{opacity:0;}/*!sc*/
data-styled.g4[id="sc-98974ec8-1"]{content:"kkSwlU,"}/*!sc*/
.dNDvpg{height:2px;position:relative;border-radius:2px;}/*!sc*/
.dNDvpg::before,.dNDvpg::after{content:'';position:absolute;border-radius:2px;top:0;left:0;width:100%;height:2px;background:#1F2329;transition:all .3s;}/*!sc*/
.dNDvpg::before{transform:rotate(45deg);}/*!sc*/
.dNDvpg::after{transform:rotate(-45deg);}/*!sc*/
.cLsQWp{height:2px;position:relative;border-radius:2px;}/*!sc*/
.cLsQWp::before,.cLsQWp::after{content:'';position:absolute;border-radius:2px;top:0;left:0;width:100%;height:2px;background:#1F2329;transition:all .3s;}/*!sc*/
data-styled.g5[id="sc-98974ec8-2"]{content:"dNDvpg,cLsQWp,"}/*!sc*/
.euEbpV{width:24px;height:20px;position:fixed;top:22px;right:20px;}/*!sc*/
data-styled.g6[id="sc-d7f4a716-0"]{content:"euEbpV,"}/*!sc*/
.iPRoot{font-weight:400;padding-top:3rem;font-size:0.625rem;}/*!sc*/
data-styled.g7[id="sc-d7f4a716-1"]{content:"iPRoot,"}/*!sc*/
.kfxPkz{margin:1rem 0;}/*!sc*/
.kfxPkz a:hover{color:#e0c56e;}/*!sc*/
.kfxPkz svg{font-size:1.5rem;margin:0 0.25rem;}/*!sc*/
data-styled.g8[id="sc-d7f4a716-2"]{content:"kfxPkz,"}/*!sc*/
.ewTYkv{background:white;overflow:auto;position:fixed;width:100%;height:100%;z-index:10;transform:translateY(0);transition:transform 1s cubic-bezier(0.46,0,0.08,1.11);}/*!sc*/
.ewTYkv h1 span{position:relative;}/*!sc*/
.ewTYkv h1 span::before{content:'';position:absolute;left:0;bottom:0;width:100%;border-radius:0.5em;height:0.5em;background:#e0c56e;mix-blend-mode:multiply;}/*!sc*/
data-styled.g9[id="sc-d7f4a716-3"]{content:"ewTYkv,"}/*!sc*/
.jWaeMB{margin:0 auto;padding:92px 0px;text-align:center;font-weight:bold;}/*!sc*/
data-styled.g10[id="sc-d7f4a716-4"]{content:"jWaeMB,"}/*!sc*/
.knKiOw{font-size:1.625rem;line-height:2.75rem;position:relative;transition:box-shadow .3s ease;cursor:pointer;}/*!sc*/
.knKiOw:hover{color:#e0c56e;transform:scale(1.2);}/*!sc*/
data-styled.g11[id="sc-d7f4a716-5"]{content:"knKiOw,"}/*!sc*/
.gZNrVS{transition:color 0.3s ease;cursor:pointer;}/*!sc*/
.gZNrVS:hover{color:#e0c56e;}/*!sc*/
data-styled.g17[id="sc-e8400407-0"]{content:"gZNrVS,"}/*!sc*/
.iCsNw{height:63px;width:100%;text-align:center;padding-top:0.625rem;font-size:0.625rem;font-style:italic;color:#ae8d0b;font-family:'Times New Roman',STSong,'宋体',serif;opacity:.6;}/*!sc*/
data-styled.g18[id="sc-e8400407-1"]{content:"iCsNw,"}/*!sc*/
.kDjIbE{height:63px;width:100%;display:flex;justify-content:space-between;align-items:center;position:fixed;background-color:white;z-index:10;transform:translateY(0);transition:transform .5s ease;}/*!sc*/
data-styled.g19[id="sc-e8400407-2"]{content:"kDjIbE,"}/*!sc*/
.dKuiwG{flex:1 1 auto;display:flex;justify-content:flex-start;align-items:center;font-weight:600;width:210px;}/*!sc*/
.dKuiwG span{padding:0 0.5rem;}/*!sc*/
@media screen and (max-width:780px){.dKuiwG{width:100px;}.dKuiwG span{display:none;}}/*!sc*/
@media screen and (max-width:350px){.dKuiwG{display:none;}}/*!sc*/
data-styled.g20[id="sc-e8400407-3"]{content:"dKuiwG,"}/*!sc*/
.gtCrWX{flex:1 1 auto;display:flex;align-items:center;justify-content:flex-end;font-size:0.875em;width:210px;}/*!sc*/
.gtCrWX>div{margin-right:15px;}/*!sc*/
@media screen and (max-width:780px){.gtCrWX{width:100px;}}/*!sc*/
data-styled.g21[id="sc-e8400407-4"]{content:"gtCrWX,"}/*!sc*/
.eapisl{flex:2 1 auto;display:flex;justify-content:space-evenly;letter-spacing:0.02em;align-items:stretch;height:63px;}/*!sc*/
.eapisl a{text-align:center;flex-grow:1;padding-left:0.5rem;padding-right:0.5rem;padding-top:20px;font-weight:600;background:white;}/*!sc*/
.eapisl a:hover{background:#e0c56e;transition:background linear .5s;}/*!sc*/
.eapisl a.current{background:#1F2329;color:white;}/*!sc*/
@media screen and (min-width:780px){.eapisl{max-width:50%;}.eapisl a{flex-grow:0;padding-left:1.5rem;padding-right:1.5rem;}}/*!sc*/
@media screen and (min-width:580px){.eapisl{max-width:390px;}}/*!sc*/
max-width:290px;/*!sc*/
@media screen and (max-width:580px){max-width:290px;}/*!sc*/
data-styled.g22[id="sc-e8400407-5"]{content:"eapisl,"}/*!sc*/
.foGCWN{min-width:60px;min-height:60px;z-index:20;background:white;border-radius:0.75rem;transform:scale3d(1,1,1);box-shadow:0 0 2px 0px #ae8d0b33,0 0 8px 0px #ae8d0b33;}/*!sc*/
data-styled.g42[id="sc-238d0601-0"]{content:"foGCWN,"}/*!sc*/
.biFlEK{overflow-y:scroll;max-height:60vh;}/*!sc*/
data-styled.g43[id="sc-df26da6c-0"]{content:"biFlEK,"}/*!sc*/
.boefea{position:sticky;top:0;background:white;}/*!sc*/
data-styled.g44[id="sc-df26da6c-1"]{content:"boefea,"}/*!sc*/
.crTJGE{border:none;border-radius:0;background:white;width:100%;color:#1F2329;}/*!sc*/
.crTJGE:focus,.crTJGE:focus-visible{outline:none;}/*!sc*/
data-styled.g45[id="sc-df26da6c-2"]{content:"crTJGE,"}/*!sc*/
.kiOLzY{font-size:0.875rem;color:#777;overflow:hidden;white-space:nowrap;wrap:no-wrap;}/*!sc*/
data-styled.g47[id="sc-df26da6c-4"]{content:"kiOLzY,"}/*!sc*/
.fGanDw{min-height:unset;position:fixed;top:55px;right:0px;width:24rem;overflow:hidden;margin:0 10px;}/*!sc*/
.fGanDw mark{background:none;color:#ae8d0b;}/*!sc*/
@media screen and (max-width:580px){.fGanDw{width:96%;max-height:50%;}}/*!sc*/
data-styled.g48[id="sc-df26da6c-5"]{content:"fGanDw,"}/*!sc*/
.dYdYHA{position:fixed;bottom:2rem;right:1rem;height:2.5rem;width:2.5rem;font-size:1.25rem;border-radius:50%;border:0;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);color:#989898;z-index:10;cursor:pointer;}/*!sc*/
.dYdYHA svg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);-webkit-transform:translate(-50%,-50%);}/*!sc*/
@media (any-hover:hover){.dYdYHA:hover{background:#e0c56e;color:#1F2329;}}/*!sc*/
@media (any-hover:none){.dYdYHA:active{background:#e0c56e;color:#1F2329;}}/*!sc*/
data-styled.g49[id="sc-16102fec-0"]{content:"dYdYHA,"}/*!sc*/
.kCaFVH{margin:64px 0;display:flex;flex-wrap:wrap;justify-content:space-between;align-items:center;}/*!sc*/
.kCaFVH>span{color:#777;font-size:0.875rem;}/*!sc*/
data-styled.g50[id="sc-6d487db6-0"]{content:"kCaFVH,"}/*!sc*/
.VGMst{padding:.2em 0;display:flex;align-items:center;position:relative;}/*!sc*/
.VGMst svg{transform:translateY(-0.05em);}/*!sc*/
.VGMst span{position:relative;}/*!sc*/
.VGMst span::before{content:'';position:absolute;left:0;bottom:0;width:0;height:2px;border-radius:2px;background:#e0c56e;transition:width 1s cubic-bezier(0.34,0.04,0.03,1.4),background .3s;}/*!sc*/
.VGMst span:hover::before{width:100%;}/*!sc*/
data-styled.g51[id="sc-6d487db6-1"]{content:"VGMst,"}/*!sc*/
.eEpWRd{color:#343a3b;}/*!sc*/
.eEpWRd h1,.eEpWRd h2,.eEpWRd h3,.eEpWRd h4,.eEpWRd h5{color:#1F2329;}/*!sc*/
.eEpWRd h6{color:#777;}/*!sc*/
.eEpWRd hr{background-color:#a2a2a243;}/*!sc*/
.eEpWRd img,.eEpWRd picture,.eEpWRd video,.eEpWRd canvas,.eEpWRd svg,.eEpWRd pre{margin:1.5rem auto;display:block;}/*!sc*/
.eEpWRd img,.eEpWRd picture{border-radius:1rem;box-shadow:rgb(0 0 0 / 15%) 0px 2px 6px;}/*!sc*/
.eEpWRd blockquote{margin:1.5rem 0;}/*!sc*/
.eEpWRd a{position:relative;font-weight:bold;color:#1F2329;transition:box-shadow .3s ease;box-shadow:inset 0 -2px 0 #e0c56e;}/*!sc*/
.eEpWRd a:hover{box-shadow:inset 0 -0.5em 0 #e0c56e;}/*!sc*/
.eEpWRd a:hover::before{height:0.4em;}/*!sc*/
.eEpWRd code{color:#ae8d0b;background-color:#f3f3f3;border-radius:3px;padding:0.2rem 0.375rem;margin:0rem 1px;font-size:0.875rem;}/*!sc*/
.eEpWRd pre code{color:#343a3b;border-radius:0.5rem;padding:1rem 2rem;margin:unset;overflow:auto;}/*!sc*/
.eEpWRd blockquote{border-left:solid 2px;padding-left:1.5em;color:#777;}/*!sc*/
.eEpWRd del{opacity:.33;}/*!sc*/
.eEpWRd ul li{display:block;position:relative;}/*!sc*/
.eEpWRd ul li::before{content:"•";position:absolute;color:#ae8d0b;left:-1rem;}/*!sc*/
@media screen and (min-width:580px){.eEpWRd img,.eEpWRd picture,.eEpWRd video,.eEpWRd canvas,.eEpWRd svg,.eEpWRd pre{margin:1.6rem auto;display:block;}.eEpWRd blockquote{margin:1.6rem 0;}}/*!sc*/
.eEpWRd .hljs{background:#f3f3f3;}/*!sc*/
.eEpWRd .hljs-emphasis{font-style:italic;}/*!sc*/
.eEpWRd .hljs-strong{font-weight:bold;}/*!sc*/
.eEpWRd .hljs-link{text-decoration:underline;}/*!sc*/
.eEpWRd .hljs-comment,.eEpWRd .hljs-quote{color:#a79b87ba;font-style:italic;}/*!sc*/
.eEpWRd .hljs-params,.eEpWRd .hljs-type{color:#a79b87c4;}/*!sc*/
.eEpWRd .hljs-punctuation,.eEpWRd .hljs-attr{color:rgb(89 161 197);}/*!sc*/
.eEpWRd .hljs-selector-tag,.eEpWRd .hljs-name,.eEpWRd .hljs-meta,.eEpWRd .hljs-operator,.eEpWRd .hljs-char.escape_{color:#c56200;}/*!sc*/
.eEpWRd .hljs-keyword,.eEpWRd .hljs-deletion{color:#799f67;}/*!sc*/
.eEpWRd .hljs-regexp,.eEpWRd .hljs-selector-pseudo,.eEpWRd .hljs-selector-attr,.eEpWRd .hljs-variable.language_{color:#cc5e91;}/*!sc*/
.eEpWRd .hljs-subst,.eEpWRd .hljs-property,.eEpWRd .hljs-code,.eEpWRd .hljs-formula,.eEpWRd .hljs-section,.eEpWRd .hljs-title.function_{color:#e36b6b;}/*!sc*/
.eEpWRd .hljs-string,.eEpWRd .hljs-symbol,.eEpWRd .hljs-bullet,.eEpWRd .hljs-addition,.eEpWRd .hljs-selector-class,.eEpWRd .hljs-title.class_,.eEpWRd .hljs-title.class_.inherited__,.eEpWRd .hljs-meta .hljs-string{color:#c68032;}/*!sc*/
.eEpWRd .hljs-variable,.eEpWRd .hljs-template-variable,.eEpWRd .hljs-number,.eEpWRd .hljs-literal,.eEpWRd .hljs-link,.eEpWRd .hljs-built_in,.eEpWRd .hljs-title,.eEpWRd .hljs-selector-id,.eEpWRd .hljs-tag,.eEpWRd .hljs-doctag,.eEpWRd .hljs-attribute,.eEpWRd .hljs-template-tag,.eEpWRd .hljs-meta .hljs-keyword{color:#ae8d0b;}/*!sc*/
data-styled.g55[id="sc-dcdd791a-0"]{content:"eEpWRd,"}/*!sc*/
.hzfBGG{margin-top:72px;margin:0 auto;padding:60px 20px;max-width:800px;width:56%;}/*!sc*/
.hzfBGG .toc-btn{display:none;}/*!sc*/
@media screen and (max-width:1400px){.hzfBGG{width:52%;}}/*!sc*/
@media screen and (max-width:1200px){.hzfBGG{width:75%;padding-left:80px;margin:unset;}}/*!sc*/
@media screen and (max-width:1000px){.hzfBGG{width:85%;margin:0 auto;padding-left:20px;}.hzfBGG .toc-btn{display:unset;}}/*!sc*/
@media screen and (max-width:580px){.hzfBGG{padding:48px 20px;width:100%;}}/*!sc*/
data-styled.g56[id="sc-bb2d5861-0"]{content:"hzfBGG,"}/*!sc*/
.fRjCIo{position:fixed;top:128px;animation:gaJTjH 0.3s ease;will-change:transform;transition:top 0.3s ease;max-width:18rem;max-height:calc(100vh - 128px);padding:0 1rem;line-height:1.75rem;overflow:auto;left:78%;width:22%;}/*!sc*/
.fRjCIo .close-btn{display:none;z-index:1;}/*!sc*/
@media screen and (max-width:1200px){.fRjCIo{left:76%;width:24%;}}/*!sc*/
@media screen and (max-width:1000px){.fRjCIo{top:unset;left:unset;bottom:9rem;animation:unset;border-radius:0.75rem;background:white;box-shadow:rgb(0 0 0 / 15%) 0px 0px 7px;max-height:calc(100vh - 128px - 9rem);width:250px;padding-top:1rem;padding-bottom:1rem;right:7px;transition:opacity .3s ease;opacity:0;pointer-events:none;}.fRjCIo .close-btn{position:sticky;float:right;top:0;display:flex;font-weight:600;justify-content:space-between;align-items:center;visibility:hidden;color:#989898;font-size:1rem;cursor:pointer;}.fRjCIo .close-btn:hover{color:#ae8d0b;}}/*!sc*/
@media screen and (max-width:580px){.fRjCIo{right:2%;bottom:0;max-height:unset;height:60vh;max-width:unset;opacity:unset;width:96%;transition:transform .3s ease;transform:translateY(100%);}}/*!sc*/
data-styled.g58[id="sc-bb2d5861-2"]{content:"fRjCIo,"}/*!sc*/
.dUdLVX{margin-top:0;margin-bottom:0;text-align:center;}/*!sc*/
data-styled.g59[id="sc-bb2d5861-3"]{content:"dUdLVX,"}/*!sc*/
.hlaSGQ{color:#989898;font-weight:600;margin-top:1rem;font-size:0.875rem;text-align:center;}/*!sc*/
data-styled.g60[id="sc-bb2d5861-4"]{content:"hlaSGQ,"}/*!sc*/
.dRKsSG{margin-top:1rem;padding-bottom:1.5rem;margin-bottom:1.5rem;font-size:0.875rem;font-weight:600;text-align:center;}/*!sc*/
.dRKsSG .category{font-size:0.875rem;line-height:1.5rem;padding-right:0.5rem;}/*!sc*/
.dRKsSG .tag{font-size:0.875rem;line-height:1;}/*!sc*/
data-styled.g61[id="sc-bb2d5861-5"]{content:"dRKsSG,"}/*!sc*/
.kGojYw{transition:opacity .3s,color .3s;color:#1F2329;}/*!sc*/
.kGojYw:hover{color:#ae8d0b;}/*!sc*/
data-styled.g62[id="sc-bb2d5861-6"]{content:"kGojYw,"}/*!sc*/
.iETSwH{transition:background .3s,color .3s;background:#efefef;color:#343a3b;display:inline-block;padding:0.3em 0.5em;margin:1px;border-radius:2em;}/*!sc*/
.iETSwH svg{margin-right:3px;}/*!sc*/
.iETSwH:hover{background:#e0c56e;}/*!sc*/
data-styled.g63[id="sc-bb2d5861-7"]{content:"iETSwH,"}/*!sc*/
.fecqCB{border-radius:0.75rem;}/*!sc*/
data-styled.g64[id="sc-bb2d5861-8"]{content:"fecqCB,"}/*!sc*/
.bKoXAG{position:relative;}/*!sc*/
data-styled.g65[id="sc-bb2d5861-9"]{content:"bKoXAG,"}/*!sc*/
.cfbHfw{margin:0 auto;--waline-theme-color:#292929;--waline-bg-color:white;--waline-color:#777;--waline-active-color:#ae8d0b;--waline-bg-color-light:#99999915;--waline-border:1px solid #99999966;--waline-border-color:#99999966;--waline-info-bgcolor:#99999915;}/*!sc*/
.cfbHfw .wl-btn.primary{background:#292929;color:white;}/*!sc*/
@media screen and (max-width:580px){.cfbHfw .wl-gif-popup .wl-gallery-column{display:grid!important;grid-template-columns:1fr 1fr 1fr;max-height:200px;}}/*!sc*/
.cfbHfw .wl-gif-popup img{border-color:white;}/*!sc*/
.cfbHfw .wl-gif-popup input{background:white;color:#1F2329;}/*!sc*/
data-styled.g67[id="sc-fc27347a-0"]{content:"cfbHfw,"}/*!sc*/
@keyframes gaJTjH{0%{-webkit-transform:translateX(50px);transform:translateX(50px);opacity:0;}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1;}}/*!sc*/
data-styled.g68[id="sc-keyframes-gaJTjH"]{content:"gaJTjH,"}/*!sc*/
</style></head><body><div id="__next"><div style="display:none" class="sc-238d0601-0 sc-df26da6c-5 foGCWN fGanDw"><div style="padding:1rem 1rem 0 1rem" class="sc-df26da6c-1 boefea"><input type="text" placeholder="搜索你感兴趣的内容，以空格分词" class="sc-df26da6c-2 crTJGE"/></div><div style="padding:0.5rem 1rem" class="sc-df26da6c-0 biFlEK"><div style="font-size:0.875rem;opacity:0.5"><div class="sc-df26da6c-4 kiOLzY">搜索初始化中……</div></div></div></div><div style="transform:translateY(-100%)" class="sc-d7f4a716-3 ewTYkv"><div style="padding-top:8rem" class="sc-d7f4a716-4 jWaeMB"><h1><span>SANSUI&#x27;S BLOG</span></h1><div><span class="sc-d7f4a716-5 knKiOw">系统外观</span></div><div><span class="sc-d7f4a716-5 knKiOw"><a href="/categories">分类标签</a></span></div><div><span class="sc-d7f4a716-5 knKiOw"><a href="/atom.xml">RSS</a></span></div><div class="sc-d7f4a716-1 iPRoot"><div class="sc-d7f4a716-2 kfxPkz"><a href="https://github.com/sansui233"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a><a href="mailto:sansuilnm@gmail.com"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail"><rect width="20" height="16" x="2" y="4" rx="2"></rect><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path></svg></a><a href="/rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></div><div style="margin:1rem auto">Sansui 2023<br/>All rights reserved</div></div></div><div class="sc-d7f4a716-0 euEbpV"><div width="1em" height="1em" class="sc-98974ec8-0 iAQObY"><div class="sc-98974ec8-1 kkSwlU is-close"></div><div class="sc-98974ec8-2 dNDvpg"></div><div class="sc-98974ec8-1 kkSwlU is-close"></div></div></div></div><header class="sc-e8400407-2 kDjIbE"><div class="sc-e8400407-3 dKuiwG"><a style="padding:0 1rem" href="/"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 72 72" width="36"><path d="M68.24 44.97a1 1 0 0 0 .73-1.21m0 0a1 1 0 0 0-1.21-.73l-4.61 1.15c1.06-5.18.9-11.77-1.14-20.18 0-7-1.45-14.23-3.24-14.91C56.78 8.34 47.01 15 46.01 18c-7-2-13-2-20 0-1-3-10.77-9.66-12.76-8.91-1.79.67-3.24 7.91-3.24 14.91-2.05 8.41-2.2 15-1.14 20.18l-4.61-1.15a.995.995 0 0 0-1.21.73c-.13.54.19 1.08.73 1.21l5.64 1.41c.33 1.14.72 2.21 1.18 3.2L5.93 50a1 1 0 0 0 .09 2h.09l5.49-.5c.44.75.92 1.46 1.42 2.11L8.7 55.05a.996.996 0 0 0 .32 1.94c.1 0 .21-.02.32-.05l5.08-1.69c6.8 7.11 17.32 7.75 21.6 7.75s14.8-.63 21.6-7.75l5.08 1.69c.11.04.21.05.32.05.42 0 .81-.26.95-.68a1 1 0 0 0-.63-1.26l-4.32-1.44c.51-.66.98-1.36 1.42-2.11l5.49.5h.09c.51 0 .95-.39 1-.91.05-.55-.36-1.04-.91-1.09l-4.67-.42c.45-.99.84-2.06 1.18-3.2l5.64-1.41M21.02 46c-5-1-7-5-6-10 .81-4.04 4.59-7.63 9-7 4.39.63 6.81 4.04 6.64 8.74-.18 4.98-4.64 9.26-9.64 8.26Zm21.45 1.28c-.64.32-1.36.48-2.09.48-.67 0-1.36-.14-2.01-.41a5.557 5.557 0 0 1-2.35-1.83c-.61.81-1.41 1.44-2.35 1.83-1.37.57-2.87.54-4.1-.07a1.01 1.01 0 0 1-.45-1.34c.25-.49.85-.69 1.34-.45.7.35 1.61.36 2.44.02 1.01-.42 1.78-1.28 2.16-2.44.03-.09.08-.17.13-.25-.7-.31-1.18-1.01-1.18-1.82 0-1.1.9-2 2-2s2 .9 2 2c0 .81-.49 1.51-1.18 1.82.05.08.1.16.13.25.38 1.15 1.15 2.02 2.16 2.44.83.34 1.74.34 2.44-.02.49-.25 1.09-.05 1.34.45s.05 1.09-.45 1.34ZM51.02 46c-5 1-9.46-3.28-9.64-8.26-.17-4.71 2.25-8.11 6.64-8.74 4.41-.63 8.19 2.96 9 7 1 5-1 9-6 10Z"></path><path d="M26 33c-.55 0-1-.45-1-1 0-.45.3-.81.7-.94-.16-.09-.32-.19-.5-.25C23 30 20 31 18.38 34.34c-1.6 3.29-1.17 7.39 2.48 8.79 3.31 1.27 7.01-.77 7.53-4.63.35-2.62-.16-4.96-1.41-6.41-.04.51-.46.92-.98.92ZM53.62 34.34a7.517 7.517 0 0 0-1.64-2.24.98.98 0 0 1-.98.9c-.55 0-1-.45-1-1 0-.4.24-.74.57-.9-1.27-.63-2.63-.72-3.78-.3-2.52.92-3.68 4.05-3.19 7.69.52 3.85 4.23 5.9 7.53 4.63 3.64-1.4 4.07-5.49 2.48-8.79Z"></path></svg><span>Sansui&#x27;s &#x27;s blog</span></a></div><nav class="sc-e8400407-5 eapisl"><a class="" href="/">文章</a><a class="" href="/memos">说说</a><a class="" href="/about">关于</a></nav><div class="sc-e8400407-4 gtCrWX"><div class="sc-e8400407-0 gZNrVS"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.3-4.3"></path></svg></div><div style="margin-right:20px;width:22px"><div width="100%" height="1.15rem" class="sc-98974ec8-0 bcRNvF"><div class="sc-98974ec8-1 kkSwlU"></div><div class="sc-98974ec8-2 cLsQWp"></div><div class="sc-98974ec8-1 kkSwlU"></div></div></div></div></header><div class="sc-e8400407-1 iCsNw">人活着就是为了卡卡西</div><main><article class="sc-bb2d5861-0 hzfBGG"><h1 class="sc-bb2d5861-3 dUdLVX">关于 typescript 泛型中返回值类型约束的问题</h1><div class="sc-bb2d5861-4 hlaSGQ">11 月 12 日, 2024</div><div class="sc-bb2d5861-5 dRKsSG"><div style="display:inline-block;max-width:50%"><span class="category"><a class="sc-bb2d5861-6 kGojYw" href="/categories/%E5%AD%A6%E4%B9%A0"><svg xmlns="http://www.w3.org/2000/svg" width="1.1em" height="1.1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-folder" style="margin-left:0.5em;margin-right:0.15em;padding-bottom:0.1em"><path d="M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"></path></svg>学习</a></span><span class="tag"><a class="sc-bb2d5861-7 iETSwH" href="/tags/typescript"><svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="0.875em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-tag"><path d="M12 2H2v10l9.29 9.29c.94.94 2.48.94 3.42 0l6.58-6.58c.94-.94.94-2.48 0-3.42L12 2Z"></path><path d="M7 7h.01"></path></svg>typescript</a></span></div></div><div class="sc-dcdd791a-0 eEpWRd"><p>最近遇到这么一个需求。</p>
<blockquote>
<p>定义一个函数接口，要求其返回值类型是 type A 的任意超集。</p>
</blockquote>
<p>于是我按直觉写下了：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> A  = { <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> }
<span class="hljs-keyword">type</span> <span class="hljs-title class_">FuncA</span>  = &lt;T <span class="hljs-keyword">extends</span> A&gt;<span class="hljs-function">() =&gt;</span> T
<span class="hljs-keyword">const</span> <span class="hljs-attr">f</span>: <span class="hljs-title class_">FuncA</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;ok&quot;</span> } 
}
</code></pre>
<p>人来看非常简单知道是什么意思，就是返回值包含所有 a 的属性，其他属性全是可有可无的。</p>
<p>这段代码扔给 GPT，它也看不出什么毛病。但事实上，在 return 时报了一个错：</p>
<pre><code class="hljs language-text">Type &#x27;() =&gt; A&#x27; is not assignable to type &#x27;FuncA&#x27;.
  Type &#x27;A&#x27; is not assignable to type &#x27;T&#x27;.
    &#x27;A&#x27; is assignable to the constraint of type &#x27;T&#x27;, but &#x27;T&#x27; could be instantiated with a different subtype of constraint &#x27;A&#x27;.ts(2322)
</code></pre>
<p>这个报错非常的不 helpful。因为平时， typescript 可以根据返回值推测出具体函数标注。比如</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>){
  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>
} <span class="hljs-comment">// 自动推断出函数的具体签名为 () =&gt; string</span>
</code></pre>
<p>那为什么上面的报错例子，不能做这样的推断呢？</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">type</span> A  = { <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> }
<span class="hljs-keyword">type</span> <span class="hljs-title class_">FuncA</span>  = &lt;T <span class="hljs-keyword">extends</span> A&gt;<span class="hljs-function">() =&gt;</span> T
<span class="hljs-keyword">const</span> <span class="hljs-attr">f</span>: <span class="hljs-title class_">FuncA</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;ok&quot;</span> } 
} 
<span class="hljs-comment">/* 推断出具体的签名类似于
() =&gt; {
  a: string;
  [name: string]: any
}
*/</span>
</code></pre>
<p>也就是说，a 是必选属性，其他属性全是 optional。</p>
<p>（先不讨论 Object 的 key 可以是 Symbol，只是为了看起来好理解，我只写了 string。要写全这里又要多写一个类型推断。）</p>
<p>当然这里又引发了另一个问题：你为什么不直接把 type A 定义附加任意可选属性？</p>
<p>好问题，这是一个正常的解决 TS2322 问题的思路。但是我就是想知道为什么泛型推断不能直接做这个……</p>
<p>我查了很多资料，没有人完美解释这个问题。但有一个相似的问题：如何让参数和返回值持有相同的泛型类型？</p>
<p>在 typescript 的 <a href="https://github.com/microsoft/TypeScript/issues/50027">github issue</a> 里有详细的案例说明，务必看看，很好懂，说是故意这么设计的。这里我将理由简短概括如下：</p>
<blockquote>
<p>如果 f 是上有一个额外的属性 prop，编译器如果推导出了返回值类型成 typeof f。之后你调用 f.prop，静态编译不会报错，但实际上有一个 runtime error，因为你的真实的返回值只是一个 <code>()=&gt;{}</code> ，没有prop 属性。</p>
</blockquote>
<p>但个人觉得这里静态编译应该报错，并不是一个 runtime 错误。前面说了，typescript 可以对返回值进行静态的类型的检查。以上面 issue 为例，理想的报错设计是长这样：</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">type</span> A = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
<span class="hljs-keyword">type</span> B = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;

<span class="hljs-comment">// 类型签名为 &lt;T extends A | B&gt;(value: T) =&gt; T 的实现</span>
<span class="hljs-keyword">function</span> f1&lt;T <span class="hljs-keyword">extends</span> A | B&gt;(<span class="hljs-attr">value</span>: T): T {
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {};  <span class="hljs-comment">// 推断出 T 此时是 typeof ()=&gt;{}，也就是 ()=&gt;{}</span>
}

<span class="hljs-keyword">let</span> <span class="hljs-attr">f</span>: <span class="hljs-built_in">any</span>= <span class="hljs-function">()=&gt;</span>{}
f.<span class="hljs-property">prop</span> = <span class="hljs-string">&quot;haha&quot;</span>

<span class="hljs-title function_">f1</span>(f) <span class="hljs-comment">// 这里传参报错，因为 typeof f 和 typeof ()=&gt;{} 不一致。本质上就是 ts2322 描述的问题，但不应该在上面报错</span>
</code></pre>
<p>当然上面的例子返回值类型已经定了是 <code>typeof ()=&gt;{}</code>，返回值再标注 T 显得十分多此一举。但是 f1 对只是对这个函数签名的一种实现。完全可以实现对这个函数签名有不同的实现，返回不同的 subtype。</p>
<blockquote>
<p>什么是 subtype？T extends A，T 就是 A 的 subtype</p>
</blockquote>
<p>这又引发了另一个问题：这和函数重载有什么区别？</p>
<p>当然有区别啊，最大的区别就是我能定义一个统一的函数接口，只要返回值满足最基本的约束 <code>A</code>。但可以是返回不同的 subtype，实现也分开写到不同的文件里，类似于 oop 语言中返回所有某基类的派生类。这才是完全体。</p>
<p>但现在的 typescript 完全做不到这一点，返回值只能是一个非常具体的 type，要么就抛出一个毫无说服力的 ts2322 错误。</p>
<p>如果要解决开头的问题，大概是以下三个思路：</p>
<ul>
<li>定义 A 时，把所有可能要用到的属性都写到可选属性里，或直接 <code>[name: string]: any</code>。</li>
<li>考虑业务场景，其他未知属性不留下会影响到什么吗。99% 的场景是没有必要的，也就是说这个需求就是没意义的。剩下的 1% 我没有遇到/想到。</li>
<li>根据输入参数的 T 写一个类型推导，手动将返回的类型设置为 a 的具体扩展类型。类似这样</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Extend</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = {
  [<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>
} &amp; {
  [K <span class="hljs-keyword">in</span> keyof T]: T[K]
}

<span class="hljs-keyword">type</span> A  = {<span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>}
<span class="hljs-keyword">type</span> <span class="hljs-title class_">FuncA</span>  = <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Extend</span>&lt;A&gt;
<span class="hljs-keyword">const</span> <span class="hljs-attr">f</span>: <span class="hljs-title class_">FuncA</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;ok&quot;</span>, <span class="hljs-attr">b</span>:<span class="hljs-string">&quot;extra&quot;</span>} 
} 
<span class="hljs-title function_">f</span>().<span class="hljs-property">a</span> <span class="hljs-comment">// a is string</span>
<span class="hljs-title function_">f</span>().<span class="hljs-property">b</span> <span class="hljs-comment">// b is any</span>
</code></pre>
<p>总之，在目前的 typescript 中，<strong>返回值类型不能是泛型</strong>。</p>
<p>当然这样也失去了扩展的类型检查，等于是用了函数的签名来检查的，和返回值的类型一点关系也没有。</p>
<p>现在 typescript 的静态检查器其实已经做了一些运行时的功能，比如条件语句判断以排除属性。但是，这些像运行时一样的检查只在静态类型不明确时才起作用。就这个 if，我已经遇到了好几次无法判断的 bug ，清空缓存并重启才恢复。</p>
<p>说回第二点，既然你允许传了任意值，也就说明在你这个库中，你也不知道其他附加值具体是拿来干什么的，大多无非遍历一下再过滤一下。如果是静态类型检查器来遍历，诶诶扩展属性怎么全是 any。最终还得用 JS 的运行时来做这个事情……所以有拿来做什么的话早就在 A 里增加 optional 属性了。这也是为什么说 99% 的场景这个需求其实不存在。</p>
<p>还有一个更重要的原因，那就是，ts 的类型体操，实在太他妈难写了。</p>
<hr/>
<p>可能没用的参考：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/56505560/how-to-fix-ts2322-could-be-instantiated-with-a-different-subtype-of-constraint">typescript - How to fix TS2322: &quot;could be instantiated with a different subtype of constraint &#x27;object&#x27;&quot;? - Stack Overflow</a></li>
<li><a href="https://github.com/microsoft/TypeScript/issues/50027">Could be instantiated with a different subtype of constraint · Issue #50027 · microsoft/TypeScript</a></li>
</ul></div><section><div style="text-align:right;opacity:0.5;font-size:0.875rem;margin:4rem 0 0 0">更新于 <!-- -->2023-11-12 06:26</div><div style="text-align:right;opacity:0.5;font-size:0.875rem"><svg xmlns="http://www.w3.org/2000/svg" width="1.1em" height="1.1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-eye" style="margin:0 0.2rem;padding-bottom:0.1em"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path><circle cx="12" cy="12" r="3"></circle></svg><span class="waline-pageview-count" data-path=""></span></div></section><div class="sc-6d487db6-0 kCaFVH"><div style="flex:1 1 auto"><a style="justify-content:flex-start" class="sc-6d487db6-1 VGMst" href="/posts/thoughts-about-wubi-im"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left"><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg><span style="margin:0 0.5em">大概是关于五笔打字更慢的一点碎碎念？</span></a></div><span></span><div style="flex:1 1 auto"><a style="justify-content:flex-end" class="sc-6d487db6-1 VGMst" href="/posts/2023-10-09-the-little-prince-review"><span style="margin:0 0.5em">重读《小王子》</span><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right"><path d="M5 12h14"></path><path d="m12 5 7 7-7 7"></path></svg></a></div></div><div id="waline" class="sc-fc27347a-0 cfbHfw">Waline</div><button class="sc-16102fec-0 dYdYHA toc-btn" style="bottom:5rem"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu-square"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M7 8h10"></path><path d="M7 12h10"></path><path d="M7 16h10"></path></svg></button></article><aside class="sc-bb2d5861-2 fRjCIo"><div class="close-btn"><svg xmlns="http://www.w3.org/2000/svg" width="1.25em" height="1.25em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x" style="margin-left:.5rem"><path d="M18 6 6 18"></path><path d="m6 6 12 12"></path></svg></div><section class="sc-bb2d5861-1 efNHce"><nav class="sc-bb2d5861-8 fecqCB"><div style="font-weight:bold;margin-bottom:0.5rem">目录</div><div class="sc-bb2d5861-9 bKoXAG"><span style="opacity:0.6;font-size:0.875rem">这是一篇没有目录的文章。</span></div></nav></section></aside></main><footer class="sc-705178b-0 cPWGjz"><a href="https://github.com/sansui233"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a><a href="mailto:sansuilnm@gmail.com"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail"><rect width="20" height="16" x="2" y="4" rx="2"></rect><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path></svg></a><a href="/rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a><div>Code &amp; Design by Sansui 2023<!-- --> <br/> <!-- -->All rights reserved</div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"meta":{"title":"关于 typescript 泛型中返回值类型约束的问题","date":"2023-11-12 06:26","tags":["typescript"],"categories":"学习","description":null,"keywords":"typescript, ts, generic type, ts2322，泛型约束"},"mdxcode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    code: \"code\",\n    hr: \"hr\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"最近遇到这么一个需求。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"定义一个函数接口，要求其返回值类型是 type A 的任意超集。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"于是我按直觉写下了：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-typescript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" A  = { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"string\"\n        }), \" }\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FuncA\"\n        }), \"  = \u003cT \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" A\u003e\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" T\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"f\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FuncA\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ok\\\"\"\n        }), \" } \\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"人来看非常简单知道是什么意思，就是返回值包含所有 a 的属性，其他属性全是可有可无的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这段代码扔给 GPT，它也看不出什么毛病。但事实上，在 return 时报了一个错：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"Type '() =\u003e A' is not assignable to type 'FuncA'.\\n  Type 'A' is not assignable to type 'T'.\\n    'A' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint 'A'.ts(2322)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这个报错非常的不 helpful。因为平时， typescript 可以根据返回值推测出具体函数标注。比如\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-ts\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"foo\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \"){\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1\\\"\"\n        }), \"\\n} \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 自动推断出函数的具体签名为 () =\u003e string\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那为什么上面的报错例子，不能做这样的推断呢？\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-ts\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" A  = { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"string\"\n        }), \" }\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FuncA\"\n        }), \"  = \u003cT \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" A\u003e\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" T\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"f\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FuncA\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ok\\\"\"\n        }), \" } \\n} \\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/* 推断出具体的签名类似于\\n() =\u003e {\\n  a: string;\\n  [name: string]: any\\n}\\n*/\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"也就是说，a 是必选属性，其他属性全是 optional。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"（先不讨论 Object 的 key 可以是 Symbol，只是为了看起来好理解，我只写了 string。要写全这里又要多写一个类型推断。）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当然这里又引发了另一个问题：你为什么不直接把 type A 定义附加任意可选属性？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"好问题，这是一个正常的解决 TS2322 问题的思路。但是我就是想知道为什么泛型推断不能直接做这个……\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我查了很多资料，没有人完美解释这个问题。但有一个相似的问题：如何让参数和返回值持有相同的泛型类型？\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在 typescript 的 \", _jsx(_components.a, {\n        href: \"https://github.com/microsoft/TypeScript/issues/50027\",\n        children: \"github issue\"\n      }), \" 里有详细的案例说明，务必看看，很好懂，说是故意这么设计的。这里我将理由简短概括如下：\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"如果 f 是上有一个额外的属性 prop，编译器如果推导出了返回值类型成 typeof f。之后你调用 f.prop，静态编译不会报错，但实际上有一个 runtime error，因为你的真实的返回值只是一个 \", _jsx(_components.code, {\n          children: \"()=\u003e{}\"\n        }), \" ，没有prop 属性。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但个人觉得这里静态编译应该报错，并不是一个 runtime 错误。前面说了，typescript 可以对返回值进行静态的类型的检查。以上面 issue 为例，理想的报错设计是长这样：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-ts\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" A = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"void\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" B = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"void\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 类型签名为 \u003cT extends A | B\u003e(value: T) =\u003e T 的实现\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" f1\u003cT \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" A | B\u003e(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"value\"\n        }), \": T): T {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {};  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 推断出 T 此时是 typeof ()=\u003e{}，也就是 ()=\u003e{}\"\n        }), \"\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"f\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"any\"\n        }), \"= \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"()=\u003e\"\n        }), \"{}\\nf.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"prop\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"haha\\\"\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"f1\"\n        }), \"(f) \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 这里传参报错，因为 typeof f 和 typeof ()=\u003e{} 不一致。本质上就是 ts2322 描述的问题，但不应该在上面报错\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"当然上面的例子返回值类型已经定了是 \", _jsx(_components.code, {\n        children: \"typeof ()=\u003e{}\"\n      }), \"，返回值再标注 T 显得十分多此一举。但是 f1 对只是对这个函数签名的一种实现。完全可以实现对这个函数签名有不同的实现，返回不同的 subtype。\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"什么是 subtype？T extends A，T 就是 A 的 subtype\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这又引发了另一个问题：这和函数重载有什么区别？\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"当然有区别啊，最大的区别就是我能定义一个统一的函数接口，只要返回值满足最基本的约束 \", _jsx(_components.code, {\n        children: \"A\"\n      }), \"。但可以是返回不同的 subtype，实现也分开写到不同的文件里，类似于 oop 语言中返回所有某基类的派生类。这才是完全体。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但现在的 typescript 完全做不到这一点，返回值只能是一个非常具体的 type，要么就抛出一个毫无说服力的 ts2322 错误。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果要解决开头的问题，大概是以下三个思路：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"定义 A 时，把所有可能要用到的属性都写到可选属性里，或直接 \", _jsx(_components.code, {\n          children: \"[name: string]: any\"\n        }), \"。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"考虑业务场景，其他未知属性不留下会影响到什么吗。99% 的场景是没有必要的，也就是说这个需求就是没意义的。剩下的 1% 我没有遇到/想到。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"根据输入参数的 T 写一个类型推导，手动将返回的类型设置为 a 的具体扩展类型。类似这样\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-typescript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Extend\"\n        }), \"\u003cT \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"object\"\n        }), \"\u003e = {\\n  [\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"string\"\n        }), \"]: \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"any\"\n        }), \"\\n} \u0026 {\\n  [K \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" keyof T]: T[K]\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" A  = {\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"string\"\n        }), \"}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FuncA\"\n        }), \"  = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Extend\"\n        }), \"\u003cA\u003e\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"f\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FuncA\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ok\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"b\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"extra\\\"\"\n        }), \"} \\n} \\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"f\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"a\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// a is string\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"f\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"b\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// b is any\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"总之，在目前的 typescript 中，\", _jsx(_components.strong, {\n        children: \"返回值类型不能是泛型\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当然这样也失去了扩展的类型检查，等于是用了函数的签名来检查的，和返回值的类型一点关系也没有。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"现在 typescript 的静态检查器其实已经做了一些运行时的功能，比如条件语句判断以排除属性。但是，这些像运行时一样的检查只在静态类型不明确时才起作用。就这个 if，我已经遇到了好几次无法判断的 bug ，清空缓存并重启才恢复。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"说回第二点，既然你允许传了任意值，也就说明在你这个库中，你也不知道其他附加值具体是拿来干什么的，大多无非遍历一下再过滤一下。如果是静态类型检查器来遍历，诶诶扩展属性怎么全是 any。最终还得用 JS 的运行时来做这个事情……所以有拿来做什么的话早就在 A 里增加 optional 属性了。这也是为什么说 99% 的场景这个需求其实不存在。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"还有一个更重要的原因，那就是，ts 的类型体操，实在太他妈难写了。\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"可能没用的参考：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://stackoverflow.com/questions/56505560/how-to-fix-ts2322-could-be-instantiated-with-a-different-subtype-of-constraint\",\n          children: \"typescript - How to fix TS2322: \\\"could be instantiated with a different subtype of constraint 'object'\\\"? - Stack Overflow\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/microsoft/TypeScript/issues/50027\",\n          children: \"Could be instantiated with a different subtype of constraint · Issue #50027 · microsoft/TypeScript\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerpt":" 最近遇到这么一个需求。  \u003e 定义一个函数接口，要求其返回值类型是 type A 的任意超集。  于是我按直觉写下了：   ```typescript type A  = { a: string } type FuncA  = \u003cT extends A\u003e() =\u003e T const f:","prevPost":{"title":"大概是关于五笔打字更慢的一点碎碎念？","link":"/posts/thoughts-about-wubi-im"},"nextPost":{"title":"重读《小王子》","link":"/posts/2023-10-09-the-little-prince-review"},"headings":[]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2023-11-11-typescript-generatic-type-proble-ts2322"},"buildId":"c7GPTAPy3C1rXdGyz988s","isFallback":false,"dynamicIds":[2771,5762],"gsp":true,"scriptLoader":[]}</script></body></html>